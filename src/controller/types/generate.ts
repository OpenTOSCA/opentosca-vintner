import * as assert from '#assert'
import * as check from '#check'
import registry from '#controller/types/plugins'
import {METADATA} from '#controller/types/types'
import * as files from '#files'
import {NodeType} from '#spec/node-type'
import {ServiceTemplate, TOSCA_DEFINITIONS_VERSION} from '#spec/service-template'
import * as utils from '#utils'
import Queue from '#utils/queue'
import path from 'path'

export type TypesGenerateOptions = {lib: string}

// TODO: generate types
export default async function (options: TypesGenerateOptions) {
    assert.isDefined(options.lib)

    const dirs = new Queue<string>()
    dirs.add(path.resolve(options.lib))
    while (!dirs.isEmpty()) {
        const dir = dirs.next()
        files.listDirectories(dir).forEach(it => dirs.add(path.resolve(dir, it)))

        for (const templateFilename of files.listFiles(dir)) {
            if (!templateFilename.endsWith('.yaml')) continue

            const templateFilepath = path.resolve(dir, templateFilename)

            const templateString = files.loadFile(templateFilepath)
            const templateData: ServiceTemplate = files.loadYAML<ServiceTemplate>(templateFilepath)
            if (check.isUndefined(templateData.tosca_definitions_version)) continue
            if (templateData.tosca_definitions_version !== TOSCA_DEFINITIONS_VERSION.TOSCA_SIMPLE_YAML_1_3) continue

            if (check.isUndefined(templateData.metadata)) continue

            // TODO: get this from rules by simply checking if rule.component isA this.type
            const generate = templateData.metadata[METADATA.VINTNER_GENERATE]
            if (check.isUndefined(generate)) continue

            const types = Object.entries(templateData.node_types || {})
            // TODO: if (types.length !== 1) throw new Error(`"${resolved}" has not exactly one node type defined`)
            const [name, type] = utils.first(types)
            assert.isDefined(type.derived_from)

            const node_types: {[key: string]: NodeType} = {}

            for (const variant of generate.split(', ')) {
                const [technology, ...hosting] = variant.split('::')
                assert.isDefined(technology)
                assert.isDefined(hosting)

                // TODO: actually we would need to check the type hierarchy node type is derived from "software.application"
                if (
                    [
                        'go.application',
                        'node.application',
                        'python.application',
                        'dotnet.application',
                        'java.application',
                    ].includes(type.derived_from)
                ) {
                    const plugin = registry.get(`software.application::${variant}`)

                    // TODO: migrate "." to "::"
                    node_types[`${name}.${variant.replaceAll('::', '.')}`] = plugin.generate(name, type)
                }
            }

            const implementationFilename = templateFilename.replace('.yaml', '.implementation.yaml')
            const implementationFilepath = path.resolve(dir, implementationFilename)

            // Do not import itself
            const implementationImports = check.isDefined(templateData.imports)
                ? utils
                      .copy(templateData.imports)
                      .filter(it => it !== implementationFilename)
                      .filter(it => it !== './' + implementationFilename)
                : []
            implementationImports.push(templateFilename)

            const search = new RegExp(String.raw`# \[OPENTOSCA\_VINTNER\_GENERATION\_MARK\].*`, 'g')
            const replace = indent(`${GENERATION_MARK}\n\n${GENERATION_NOTICE}\n\n${files.toYAML(node_types)}`)
            const implementationString = search.test(templateString)
                ? templateString.replace(search, replace)
                : templateString + '\n' + replace

            files.storeFile(templateFilepath, implementationString)
        }
    }
}

const GENERATION_MARK = '# [OPENTOSCA_VINTNER_GENERATION_MARK]'

const GENERATION_NOTICE = `
################################################################
#
# WARNING: Do not edit! This following content is autogenerated!
#
################################################################
`.trim()

function indent(str: string, spaces = 4) {
    const padding = ' '.repeat(spaces)
    return str
        .split('\n')
        .map(line => padding + line)
        .join('\n')
}

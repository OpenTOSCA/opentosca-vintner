###################################################
#
# WARNING: Do not edit! This file is autogenerated!
#
###################################################

tosca_definitions_version: tosca_simple_yaml_1_3
description: TOSCA Profile for OpenTOSCA Vintner (Core)
metadata:
    vintner_normative: 'true'
    template_name: TOSCA Vintner Profile (Core)
    template_author: Miles StÃ¶tzner
    template_contact: miles.stoetzner@iste.uni-stuttgart.de
    template_link: https://vintner.opentosca.org
    template_version: 1.0.0-draft
    template_id: tosca-vintner-profile
    template_license: https://www.apache.org/licenses/LICENSE-2.0
    acknowledgments: Partially funded by the [German Federal Ministry for Economic Affairs and Climate Action (BMWK)](https://www.bmwk.de) as part of the research project [SofDCar (19S21002)](https://sofdcar.de).
    vintner_orchestrator: unfurl
artifact_types:
    artifact:
        derived_from: tosca.artifacts.Root
        description: The "root" artifact type manages the root artifact type all other artifact types inherit from.
    source.archive:
        derived_from: artifact
        description: The "source.archive" artifact type manages a generic archive that holds distribution files of a component.
        properties:
            extra_opts:
                type: list
                description: extra options when extracting the archive
                entry_schema:
                    type: string
                required: false
                default: []
    system.package:
        derived_from: artifact
        description: The "system.package" artifact type manages a package that is installed via a system package manager. It expects the package name in the "file" key.
        properties:
            script:
                type: string
                required: false
                description: URL of an installation script
                default: ''
            repository:
                type: string
                required: false
                description: name of the repository (required if source is set)
                default: ''
            key:
                type: string
                required: false
                description: URL of the apt key which signs the apt repository (required if source is set)
                default: ''
            source:
                type: string
                required: false
                description: source of the repository
                default: ''
            dependencies:
                type: string
                required: false
                description: Comma separated list of apt packages that are additionally installed
                default: ''
            env:
                type: string
                required: false
                description: Space separated env variables
                default: ''
    container.image:
        derived_from: artifact
        description: The "container.image" artifact type manages a generic container image. It expects the image reference in the "file" key.
    machine.image:
        derived_from: artifact
        description: The "machine.image" artifact type manages a generic machine image. It expects the image reference in the "file" key.
    dbms.image:
        derived_from: artifact
        description: The "dbms.image" artifact type manages a generic DBMS image. It expects the image reference in the "file" key.
    cache.image:
        derived_from: artifact
        description: The "cache.image" artifact type manages a generic cache image. It expects the image reference in the "file" key.
interface_types:
    interface:
        derived_from: tosca.interfaces.Root
        description: The "interface" interface type manages the root interface type all other interface types inherit from.
        metadata:
            vintner_normative: 'true'
    management:
        derived_from: interface
        description: The "management" interface type manages the standard lifecycle management of components.
        metadata:
            vintner_normative: 'true'
        operations:
            create:
                description: create lifecycle management operation, i.e., an inline-bash script
            configure:
                description: configure lifecycle management operation, i.e., an inline-bash script
            start:
                description: start lifecycle management operation, i.e., an inline-bash script
            stop:
                description: stop lifecycle management operation, i.e., an inline-bash script
            delete:
                description: delete lifecycle management operation, i.e., an inline-bash script
node_types:
    node:
        derived_from: tosca.nodes.Root
        description: The abstract "node" node type defines the root node type all other node types inherit from.
        metadata:
            vintner_normative: 'true'
            vintner_abstract: 'true'
    cloud.provider:
        derived_from: node
        description: The abstract "cloud.provider" node type defines an abstract cloud provider, which is capable of hosting cloud services.
        metadata:
            vintner_normative: 'true'
            vintner_abstract: 'true'
        capabilities:
            host:
                type: tosca.capabilities.Compute
    cloud.service:
        derived_from: node
        description: The abstract "cloud.service" node type defines an generic cloud service, which is hosted on a cloud provider and which is hosting an instance of a cloud service offering.
        metadata:
            vintner_normative: 'true'
            vintner_abstract: 'true'
        capabilities:
            host:
                type: tosca.capabilities.Compute
        requirements:
            - host:
                  capability: tosca.capabilities.Compute
                  relationship: tosca.relationships.HostedOn
    software.application:
        derived_from: node
        description: The abstract "software.application" node type defines a generic software application. It requires a hosting and its lifecycle is managed by the management interface.
        metadata:
            vintner_normative: 'true'
            vintner_abstract: 'true'
        properties:
            application_name:
                type: string
                description: name of the application
            _management_create:
                type: string
                metadata:
                    vintner_ignore: 'true'
                default:
                    eval:
                        python: '{{ "project" | get_dir }}/vintner_utils.py#get_operation'
                        args:
                            - management
                            - create
            _management_configure:
                type: string
                metadata:
                    vintner_ignore: 'true'
                default:
                    eval:
                        python: '{{ "project" | get_dir }}/vintner_utils.py#get_operation'
                        args:
                            - management
                            - configure
            _management_start:
                type: string
                metadata:
                    vintner_ignore: 'true'
                default:
                    eval:
                        python: '{{ "project" | get_dir }}/vintner_utils.py#get_operation'
                        args:
                            - management
                            - start
            _management_stop:
                type: string
                metadata:
                    vintner_ignore: 'true'
                default:
                    eval:
                        python: '{{ "project" | get_dir }}/vintner_utils.py#get_operation'
                        args:
                            - management
                            - stop
            _management_delete:
                type: string
                metadata:
                    vintner_ignore: 'true'
                default:
                    eval:
                        python: '{{ "project" | get_dir }}/vintner_utils.py#get_operation'
                        args:
                            - management
                            - delete
        requirements:
            - host:
                  capability: tosca.capabilities.Compute
                  relationship: tosca.relationships.HostedOn
        interfaces:
            management:
                type: management
    service.application:
        derived_from: software.application
        description: The abstract "service.application" node type defines a generic software application, which provides a service. It is not normative how this component is implemented. This could be implemented by a Kubernetes Deployment Resource along with a Kubernetes Service Resource on Kubernetes or by a Systemd Service Unit on a virtual machine.
        metadata:
            vintner_normative: 'true'
            vintner_abstract: 'true'
        properties:
            application_language:
                type: string
                description: the programming/ platform language of the application, e.g., node22
            application_port:
                type: string
                description: the port the application listens on, e.g., 3000
                metadata:
                    vintner_name: PORT
            application_protocol:
                type: string
                description: the protocol the application uses, e.g., http
        attributes:
            application_address:
                type: string
                description: the address under which the application can be reached, i.e., the IP or a domain name
            application_endpoint:
                type: string
                description: the endpoint under which the application can be reached, i.e., the protocol, IP and port concatenated
                default:
                    concat:
                        - eval: .::application_protocol
                        - '://'
                        - eval: .::application_address
                        - ':'
                        - eval: .::application_port
    software.runtime:
        derived_from: software.application
        description: The abstract "software.runtime" node type defines a generic software runtime.
        metadata:
            vintner_normative: 'true'
            vintner_abstract: 'true'
        capabilities:
            host:
                type: tosca.capabilities.Compute
    container.runtime:
        derived_from: software.runtime
        description: The abstract "container.runtime" node type defines a generic container runtime.
        metadata:
            vintner_normative: 'true'
            vintner_abstract: 'true'
    machine:
        derived_from: node
        description: The abstract "machine" node type defines a generic computing machine.
        metadata:
            vintner_normative: 'true'
            vintner_abstract: 'true'
        properties:
            machine_name:
                type: string
                description: name of the machine
        attributes:
            application_address:
                type: string
                description: the address under which the machine can be publicly reached, i.e., the IP or a domain name
            management_address:
                type: string
                description: the address under which the machine can be privately reached, i.e., the IP or a domain name
    local.machine:
        derived_from: machine
        description: The "local.machine" node type manages a local machine, i.e., localhost. It is capable of hosting, e.g., software components.
        metadata:
            vintner_normative: 'true'
            vintner_abstract: 'true'
        capabilities:
            host:
                type: tosca.capabilities.Compute
    remote.machine:
        derived_from: machine
        description: The "remote.machine" node type manages a remote machine, i.e., a machine that is not localhost. It is capable of hosting, e.g., software components.
        metadata:
            vintner_normative: 'true'
        properties:
            machine_name:
                type: string
                description: name of the machine
            ports:
                type: list
                description: ports to open
                entry_schema:
                    type: string
            flavor:
                type: string
                description: flavor of the machine, i.e., cpu, memory, disk size encoded as string
                default: m1.medium
            network:
                type: string
                description: network to connect to
            ssh_user:
                type: string
                description: ssh user to connect to the machine
            ssh_key_name:
                type: string
                description: ssh key name to connect to the machine
            ssh_key_file:
                type: string
                description: ssh key file to connect to the machine, i.e., the absolute path to the ssh key file on the filesystem of the orchestrator
        capabilities:
            host:
                type: tosca.capabilities.Compute
            endpoint:
                type: unfurl.capabilities.Endpoint.Ansible
                properties:
                    connection: ssh
                    host:
                        eval: .parent::management_address
        attributes:
            application_address:
                default:
                    eval: .::management_address
    virtual.machine:
        derived_from: remote.machine
        description: The "virtual.machine" node type manages a virtual machine.
    physical.machine:
        derived_from: remote.machine
        description: The "physical.machine" node type manages a physical machine.
    database:
        derived_from: node
        description: The abstract "database" node type defines a generic database. It requires a DBMS to run.
        metadata:
            vintner_normative: 'true'
            vintner_abstract: 'true'
        requirements:
            - host:
                  capability: tosca.capabilities.Compute
                  relationship: tosca.relationships.HostedOn
    relational.database:
        derived_from: database
        description: The abstract "relational.database" node type defines a generic relational database. It requires a relational DBMS to run.
        metadata:
            vintner_normative: 'true'
            vintner_abstract: 'true'
    dbms:
        derived_from: software.application
        description: The abstract "dbms" node type defines a generic DBMS.
        metadata:
            vintner_normative: 'true'
            vintner_abstract: 'true'
    relational.dbms:
        derived_from: dbms
        description: The abstract "relational.dbms" node type defines a generic relational DBMS.
        metadata:
            vintner_normative: 'true'
            vintner_abstract: 'true'
    cache:
        derived_from: software.application
        description: The abstract "cache" node type defines a generic caching service.
        properties:
            cache_name:
                type: string
                description: name of the cache
            cache_port:
                type: string
                description: port the cache listens on
        attributes:
            application_address:
                type: string
                description: the address under which the cache can be reached, i.e., the IP or a domain name
            application_endpoint:
                type: string
                description: the endpoint under which the cache can be reached, i.e., the protocol, IP and port concatenated
                default:
                    concat:
                        - eval: .::application_protocol
                        - '://'
                        - eval: .::application_address
                        - ':'
                        - eval: .::application_port
    storage:
        derived_from: node
        description: The abstract "storage" node type defines a generic storage service.
        metadata:
            vintner_normative: 'true'
    block.storage:
        derived_from: storage
        description: The abstract "block.storage" node type defines a generic block storage.
        metadata:
            vintner_normative: 'true'
    object.storage:
        derived_from: storage
        description: The abstract "object.storage" node type defines a generic object storage.
        metadata:
            vintner_normative: 'true'
        properties:
            storage_name:
                type: string
                description: name of the storage
            storage_dialect:
                type: string
                description: dialect of the storage, e.g., s3
            storage_user:
                type: string
            storage_token:
                type: string
        attributes:
            storage_endpoint:
                type: string
            storage_token:
                type: string
        requirements:
            - host:
                  capability: tosca.capabilities.Compute
                  relationship: tosca.relationships.HostedOn
    file.storage:
        derived_from: storage
        description: The abstract "file.storage" node type defines a generic file storage.
        metadata:
            vintner_normative: 'true'
    ingress:
        derived_from: node
        description: The "ingress" node type manages a generic ingress service, which is a reverse proxy that exposes an upstream application. It is not normative how this component is implemented. This could be implemented by an Ingress resource on Kubernetes or by a reverse proxy, such as NGINX or Caddy, on a virtual machine.
        metadata:
            vintner_normative: 'true'
        properties:
            application_name:
                type: string
                description: name of the upstream application
                default:
                    eval: .::.requirements::[.name=application]::.target::application_name
            application_port:
                type: string
                description: port the upstream application listens on
                default:
                    eval: .::.requirements::[.name=application]::.target::application_port
            application_protocol:
                type: string
                description: protocol the upstream application uses
                default:
                    eval: .::.requirements::[.name=application]::.target::application_protocol
        attributes:
            application_address:
                type: string
                description: the address under which the upstream application is exposed by the ingress, i.e., the IP or a domain name
        requirements:
            - application:
                  capability: tosca.capabilities.Endpoint
                  relationship: tosca.relationships.ConnectsTo
            - host:
                  capability: tosca.capabilities.Compute
                  relationship: tosca.relationships.HostedOn

    # [OPENTOSCA_VINTNER_GENERATION_MARK]

    ################################################################
    #
    # WARNING: Do not edit! This following content is autogenerated!
    #
    ################################################################

    virtual.machine~virtual.machine#machine.image::ansible@openstack.provider:
        derived_from: virtual.machine
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            os_region_name:
                type: string
                default:
                    get_input: os_region_name
            os_auth_type:
                type: string
                default:
                    get_input: os_auth_type
            os_auth_url:
                type: string
                default:
                    get_input: os_auth_url
            os_identity_api_version:
                type: string
                default:
                    get_input: os_identity_api_version
            os_interface:
                type: string
                default:
                    get_input: os_interface
            os_application_credential_id:
                type: string
                default:
                    get_input: os_application_credential_id
            os_application_credential_secret:
                type: string
                default:
                    get_input: os_application_credential_secret
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                            environment:
                                OS_AUTH_TYPE:
                                    eval: .::os_auth_type
                                OS_AUTH_URL:
                                    eval: .::os_auth_url
                                OS_IDENTITY_API_VERSION:
                                    eval: .::os_identity_api_version
                                OS_REGION_NAME:
                                    eval: .::os_region_name
                                OS_INTERFACE:
                                    eval: .::os_interface
                                OS_APPLICATION_CREDENTIAL_ID:
                                    eval: .::os_application_credential_id
                                OS_APPLICATION_CREDENTIAL_SECRET:
                                    eval: .::os_application_credential_secret
                        inputs:
                            playbook:
                                q:
                                    - name: Create security group
                                      openstack.cloud.security_group:
                                          name: '{{ SELF.machine_name }}'
                                    - name: Open ports
                                      openstack.cloud.security_group_rule:
                                          security_group: '{{ SELF.machine_name }}'
                                          protocol: tcp
                                          port_range_min: '{{ item }}'
                                          port_range_max: '{{ item }}'
                                          remote_ip_prefix: 0.0.0.0/0
                                          direction: ingress
                                          ethertype: IPv4
                                      loop: '{{ SELF.ports | join("::") | split("::") | map("int") }}'
                                    - name: Create VM
                                      openstack.cloud.server:
                                          state: present
                                          name: '{{ SELF.machine_name }}'
                                          image: '{{  ".artifacts::machine_image::file" | eval }}'
                                          key_name: default
                                          flavor: '{{ SELF.flavor }}'
                                          network: '{{ SELF.network }}'
                                          security_groups: "{{ 'default,' + SELF.machine_name }}"
                                          auto_ip: false
                                          timeout: 360
                                      register: server_info
                                    - name: Set attributes
                                      set_fact:
                                          management_address: '{{ server_info.server.accessIPv4 }}'
                            resultTemplate: |
                                name: SELF
                                attributes:
                                    management_address: '{{ outputs.management_address | trim }}'
                        outputs:
                            management_address:
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: Delete VM
                                      openstack.cloud.server:
                                          state: absent
                                          name: '{{ SELF.machine_name }}'
                                          delete_fip: true
                                          timeout: 360
                                    - name: Delete security group
                                      openstack.cloud.security_group:
                                          state: absent
                                          name: '{{ SELF.machine_name }}'
    virtual.machine~virtual.machine#machine.image::terraform@openstack.provider:
        derived_from: virtual.machine
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            os_region_name:
                type: string
                default:
                    get_input: os_region_name
            os_auth_type:
                type: string
                default:
                    get_input: os_auth_type
            os_auth_url:
                type: string
                default:
                    get_input: os_auth_url
            os_identity_api_version:
                type: string
                default:
                    get_input: os_identity_api_version
            os_interface:
                type: string
                default:
                    get_input: os_interface
            os_application_credential_id:
                type: string
                default:
                    get_input: os_application_credential_id
            os_application_credential_secret:
                type: string
                default:
                    get_input: os_application_credential_secret
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                outputs:
                    management_address: management_address
                inputs:
                    main:
                        terraform:
                            - required_providers:
                                  - openstack:
                                        source: terraform-provider-openstack/openstack
                                        version: ~> 1.48.0
                              required_version: '>= 0.14.0'
                        provider:
                            openstack:
                                - application_credential_id: '{{ SELF.os_application_credential_id }}'
                                  application_credential_secret: '{{ SELF.os_application_credential_secret }}'
                                  auth_url: '{{ SELF.os_auth_url }}'
                                  region: '{{ SELF.os_region_name }}'
                        output:
                            management_address:
                                - value: ${yamldecode(openstack_compute_instance_v2.machine.access_ip_v4)}
                        resource:
                            openstack_compute_instance_v2:
                                machine:
                                    - flavor_name: '{{ SELF.flavor }}'
                                      image_name: '{{  ".artifacts::machine_image::file" | eval }}'
                                      key_pair: default
                                      name: '{{ SELF.machine_name }}'
                                      network:
                                          - name: '{{ SELF.network }}'
                                      security_groups:
                                          - default
                                          - ${openstack_networking_secgroup_v2.ports.name}
                            openstack_networking_secgroup_rule_v2:
                                port:
                                    - direction: ingress
                                      ethertype: IPv4
                                      for_each: ${toset(split("::", "{{ SELF.ports | join("::") }}"))}
                                      port_range_max: ${each.value}
                                      port_range_min: ${each.value}
                                      protocol: tcp
                                      remote_ip_prefix: 0.0.0.0/0
                                      security_group_id: ${openstack_networking_secgroup_v2.ports.id}
                            openstack_networking_secgroup_v2:
                                ports:
                                    - name: '{{ SELF.machine_name }}'
    cache~software.application#apt.package::ansible@*->local.machine:
        derived_from: cache
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: run setup script
                                      ansible.builtin.shell: curl -fsSL {{ ".artifacts::apt_package::script" | eval }} | sudo -E bash -
                                      args:
                                          executable: /bin/bash
                                      when: '".artifacts::apt_package::script" | eval != ""'
                                    - name: add apt key
                                      ansible.builtin.apt_key:
                                          url: '{{ ".artifacts::apt_package::key" | eval }}'
                                          keyring: /usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg
                                          state: present
                                      when: '".artifacts::apt_package::key" | eval != ""'
                                    - name: add apt repository
                                      ansible.builtin.apt_repository:
                                          repo: deb [signed-by=/usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg] {{ ".artifacts::apt_package::source" | eval }}
                                          filename: '{{ ".artifacts::apt_package::repository" | eval }}'
                                          state: present
                                      when: '".artifacts::apt_package::source" | eval != ""'
                                    - name: update apt cache
                                      ansible.builtin.apt:
                                          update_cache: 'yes'
                                    - name: install dependencies
                                      ansible.builtin.apt:
                                          name: '{{ ".artifacts::apt_package::dependencies" | eval | split(",") | map("trim") }}'
                                          state: present
                                      when: '".artifacts::apt_package::dependencies" | eval != ""'
                                    - name: install package
                                      ansible.builtin.apt:
                                          name: '{{ ".artifacts::apt_package::file" | eval }}'
                                          state: present
                                      environment: '{{ ".artifacts::apt_package::env" | eval | split | map("split", "=") | community.general.dict }}'
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
                                    - name: uninstall package
                                      ansible.builtin.apt:
                                          name: '{{ ".artifacts::apt_package::file" | eval }}'
                                          state: absent
    cache~software.application#apt.package::terraform@*->local.machine:
        derived_from: cache
        metadata:
            vintner_generated: 'true'
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            local_file:
                                tmp_create:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Run setup script 
                                        if [[ "{{ ".artifacts::apt_package::script" | eval }}" != "" ]]; then 
                                            curl -fsSL {{ ".artifacts::apt_package::script" | eval }} | sudo -E bash -
                                        fi

                                        # Add apt key
                                        if [[ "{{ ".artifacts::apt_package::key" | eval }}" != "" ]]; then 
                                            curl -1sLf {{ ".artifacts::apt_package::key" | eval }} | gpg --dearmor --yes -o /usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg
                                        fi

                                        # Add apt repository
                                        if [[ "{{ ".artifacts::apt_package::source" | eval }}" != "" ]]; then 
                                            echo "deb [signed-by=/usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg] {{ ".artifacts::apt_package::source" | eval }}" | tee {{ ".artifacts::apt_package::repository" | eval }}
                                        fi

                                        # Update apt cache
                                        apt-get update -y

                                        # Install dependencies
                                        if [[ "{{ ".artifacts::apt_package::dependencies" | eval }}" != "" ]]; then 
                                            apt-get install {{ ".artifacts::apt_package::dependencies" | eval | split(",") | map("trim") }} -y
                                        fi

                                        # Install package
                                        {{ ".artifacts::apt_package::env" | eval }} apt-get install {{ ".artifacts::apt_package::file" | eval }} -y

                                        # Create application directory
                                        mkdir -p {{ SELF.application_directory }}

                                        # Create application environment
                                        cat <<EOF > {{ SELF.application_directory }}/.env
                                        CACHE_NAME="{{ SELF.cache_name }}"
                                        CACHE_PORT="{{ SELF.cache_port }}"
                                        EOF>>

                                        # Create vintner directory
                                        mkdir -p {{ SELF.application_directory }}/.vintner

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/create.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/create.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/create.sh
                                    filename: /tmp/create-cache.sh
                                tmp_configure:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/configure.sh
                                    filename: /tmp/configure-cache.sh
                                tmp_start:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/start.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/start.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/start.sh
                                    filename: /tmp/start-cache.sh
                                tmp_stop:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/stop.sh
                                    filename: /tmp/stop-cache.sh
                                tmp_delete:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/delete.sh

                                        # Delete application directory
                                        rm -rf "{{ SELF.application_directory }}"

                                        # Uninstall package
                                        apt-get uninstall {{ ".artifacts::apt_package::file" | eval }} -y
                                    filename: /tmp/delete-cache.sh
                            terraform_data:
                                local:
                                    - provisioner:
                                          depends_on:
                                              - local_file.tmp_artifact
                                              - local_file.tmp_create
                                              - local_file.tmp_configure
                                              - local_file.tmp_start
                                              - local_file.tmp_stop
                                              - local_file.tmp_delete
                                          local-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-cache.sh
                                                    - sudo bash /tmp/configure-cache.sh
                                                    - sudo bash /tmp/start-cache.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-cache.sh
                                                    - sudo bash /tmp/delete-cache.sh
                                                when: destroy
    cache~software.application#apt.package::ansible@*->remote.machine:
        derived_from: cache
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: run setup script
                                      ansible.builtin.shell: curl -fsSL {{ ".artifacts::apt_package::script" | eval }} | sudo -E bash -
                                      args:
                                          executable: /bin/bash
                                      when: '".artifacts::apt_package::script" | eval != ""'
                                    - name: add apt key
                                      ansible.builtin.apt_key:
                                          url: '{{ ".artifacts::apt_package::key" | eval }}'
                                          keyring: /usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg
                                          state: present
                                      when: '".artifacts::apt_package::key" | eval != ""'
                                    - name: add apt repository
                                      ansible.builtin.apt_repository:
                                          repo: deb [signed-by=/usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg] {{ ".artifacts::apt_package::source" | eval }}
                                          filename: '{{ ".artifacts::apt_package::repository" | eval }}'
                                          state: present
                                      when: '".artifacts::apt_package::source" | eval != ""'
                                    - name: update apt cache
                                      ansible.builtin.apt:
                                          update_cache: 'yes'
                                    - name: install dependencies
                                      ansible.builtin.apt:
                                          name: '{{ ".artifacts::apt_package::dependencies" | eval | split(",") | map("trim") }}'
                                          state: present
                                      when: '".artifacts::apt_package::dependencies" | eval != ""'
                                    - name: install package
                                      ansible.builtin.apt:
                                          name: '{{ ".artifacts::apt_package::file" | eval }}'
                                          state: present
                                      environment: '{{ ".artifacts::apt_package::env" | eval | split | map("split", "=") | community.general.dict }}'
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
                                    - name: uninstall package
                                      ansible.builtin.apt:
                                          name: '{{ ".artifacts::apt_package::file" | eval }}'
                                          state: absent
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
    cache~software.application#apt.package::terraform@*->remote.machine:
        derived_from: cache
        metadata:
            vintner_generated: 'true'
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            os_ssh_host:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            terraform_data:
                                vm:
                                    - connection:
                                          - host: '{{ SELF.os_ssh_host }}'
                                            private_key: ${file("{{ SELF.os_ssh_key_file }}")}
                                            type: ssh
                                            user: '{{ SELF.os_ssh_user }}'
                                      provisioner:
                                          file:
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Run setup script 
                                                    if [[ "{{ ".artifacts::apt_package::script" | eval }}" != "" ]]; then 
                                                        curl -fsSL {{ ".artifacts::apt_package::script" | eval }} | sudo -E bash -
                                                    fi

                                                    # Add apt key
                                                    if [[ "{{ ".artifacts::apt_package::key" | eval }}" != "" ]]; then 
                                                        curl -1sLf {{ ".artifacts::apt_package::key" | eval }} | gpg --dearmor --yes -o /usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg
                                                    fi

                                                    # Add apt repository
                                                    if [[ "{{ ".artifacts::apt_package::source" | eval }}" != "" ]]; then 
                                                        echo "deb [signed-by=/usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg] {{ ".artifacts::apt_package::source" | eval }}" | tee {{ ".artifacts::apt_package::repository" | eval }}
                                                    fi

                                                    # Update apt cache
                                                    apt-get update -y

                                                    # Install dependencies
                                                    if [[ "{{ ".artifacts::apt_package::dependencies" | eval }}" != "" ]]; then 
                                                        apt-get install {{ ".artifacts::apt_package::dependencies" | eval | split(",") | map("trim") }} -y
                                                    fi

                                                    # Install package
                                                    {{ ".artifacts::apt_package::env" | eval }} apt-get install {{ ".artifacts::apt_package::file" | eval }} -y

                                                    # Create application directory
                                                    mkdir -p {{ SELF.application_directory }}

                                                    # Create application environment
                                                    cat <<EOF > {{ SELF.application_directory }}/.env
                                                    CACHE_NAME="{{ SELF.cache_name }}"
                                                    CACHE_PORT="{{ SELF.cache_port }}"
                                                    EOF>>

                                                    # Create vintner directory
                                                    mkdir -p {{ SELF.application_directory }}/.vintner

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/create.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/create.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/create.sh
                                                destination: /tmp/create-cache.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/configure.sh
                                                destination: /tmp/configure-cache.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/start.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/start.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/start.sh
                                                destination: /tmp/start-cache.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/stop.sh
                                                destination: /tmp/stop-cache.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/delete.sh

                                                    # Delete application directory
                                                    rm -rf "{{ SELF.application_directory }}"

                                                    # Uninstall package
                                                    apt-get uninstall {{ ".artifacts::apt_package::file" | eval }} -y
                                                destination: /tmp/delete-cache.sh
                                          remote-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-cache.sh
                                                    - sudo bash /tmp/configure-cache.sh
                                                    - sudo bash /tmp/start-cache.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-cache.sh
                                                    - sudo bash /tmp/delete-cache.sh
                                                when: destroy
    cache~software.application#tar.archive::ansible@*->local.machine:
        derived_from: cache
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: install operational dependencies
                                      ansible.builtin.apt:
                                          name: unzip
                                          update_cache: 'yes'
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: extract deployment artifact in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          extra_opts: '{{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}'
                                      when: not (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")
                                    - name: extract deployment artifact from URL in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          remote_src: 'yes'
                                          extra_opts: '{{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}'
                                      when: (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")
                                    - name: create vintner directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}/.vintner'
                                          state: directory
                                    - name: create .env file
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.env'
                                          content: |-
                                              CACHE_NAME="{{ SELF.cache_name }}"
                                              CACHE_PORT="{{ SELF.cache_port }}"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "start" missing
                                      when: SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "stop" missing
                                      when: SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
    cache~software.application#tar.archive::terraform@*->local.machine:
        derived_from: cache
        metadata:
            vintner_generated: 'true'
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            local_file:
                                tmp_artifact:
                                    source: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                    filename: /tmp/artifact-cache
                                    count: '{{ (not (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")) | ternary(1, 0) }}'
                                tmp_create:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Create application directory
                                        mkdir -p {{ SELF.application_directory }}

                                        # Create application environment
                                        cat <<EOF > {{ SELF.application_directory }}/.env
                                        CACHE_NAME="{{ SELF.cache_name }}"
                                        CACHE_PORT="{{ SELF.cache_port }}"
                                        EOF>>

                                        # Download deployment artifact if required
                                        if [[ "{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}" == http* ]]; then 
                                            wget -O /tmp/artifact-cache {{ ".artifacts::*::[.type=tar.archive]::file" | eval }} 
                                        fi

                                        # Extract deployment artifact
                                        tar -xzf /tmp/artifact-cache -C {{ SELF.application_directory }} {{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}

                                        # Create vintner directory
                                        mkdir -p {{ SELF.application_directory }}/.vintner

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/create.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/create.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/create.sh
                                    filename: /tmp/create-cache.sh
                                tmp_configure:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/configure.sh
                                    filename: /tmp/configure-cache.sh
                                tmp_start:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Assert operation
                                        if [[ "{{ SELF._management_start | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                            echo 'Management operation "start" missing'
                                            exit 1 
                                        fi

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/start.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/start.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/start.sh
                                    filename: /tmp/start-cache.sh
                                tmp_stop:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Assert operation
                                        if [[ "{{ SELF._management_stop | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                            echo 'Management operation "stop" missing'
                                            exit 1 
                                        fi

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/stop.sh
                                    filename: /tmp/stop-cache.sh
                                tmp_delete:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/delete.sh

                                        # Delete application directory
                                        rm -rf "{{ SELF.application_directory }}"
                                    filename: /tmp/delete-cache.sh
                            terraform_data:
                                local:
                                    - depends_on:
                                          - local_file.tmp_artifact
                                          - local_file.tmp_create
                                          - local_file.tmp_configure
                                          - local_file.tmp_start
                                          - local_file.tmp_stop
                                          - local_file.tmp_delete
                                      provisioner:
                                          local-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-cache.sh
                                                    - sudo bash /tmp/configure-cache.sh
                                                    - sudo bash /tmp/start-cache.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-cache.sh
                                                    - sudo bash /tmp/delete-cache.sh
                                                when: destroy
    cache~software.application#tar.archive::ansible@*->remote.machine:
        derived_from: cache
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: extract deployment artifact in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          extra_opts: '{{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}'
                                      when: not (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")
                                    - name: extract deployment artifact from URL in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          remote_src: 'yes'
                                          extra_opts: '{{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}'
                                      when: (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")
                                    - name: create vintner directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}/.vintner'
                                          state: directory
                                    - name: create .env file
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.env'
                                          content: |-
                                              CACHE_NAME="{{ SELF.cache_name }}"
                                              CACHE_PORT="{{ SELF.cache_port }}"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "start" missing
                                      when: SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "stop" missing
                                      when: SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
    cache~software.application#tar.archive::terraform@*->remote.machine:
        derived_from: cache
        metadata:
            vintner_generated: 'true'
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            os_ssh_host:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            terraform_data:
                                vm:
                                    - connection:
                                          - host: '{{ SELF.os_ssh_host }}'
                                            private_key: ${file("{{ SELF.os_ssh_key_file }}")}
                                            type: ssh
                                            user: '{{ SELF.os_ssh_user }}'
                                      provisioner:
                                          file:
                                              - source: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                                destination: /tmp/artifact-cache
                                                count: '{{ (not (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")) | ternary(1, 0) }}'
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Create application directory
                                                    mkdir -p {{ SELF.application_directory }}

                                                    # Create application environment
                                                    cat <<EOF > {{ SELF.application_directory }}/.env
                                                    CACHE_NAME="{{ SELF.cache_name }}"
                                                    CACHE_PORT="{{ SELF.cache_port }}"
                                                    EOF>>

                                                    # Download deployment artifact if required
                                                    if [[ "{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}" == http* ]]; then 
                                                        wget -O /tmp/artifact-cache {{ ".artifacts::*::[.type=tar.archive]::file" | eval }} 
                                                    fi

                                                    # Extract deployment artifact
                                                    tar -xzf /tmp/artifact-cache -C {{ SELF.application_directory }} {{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}

                                                    # Create vintner directory
                                                    mkdir -p {{ SELF.application_directory }}/.vintner

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/create.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/create.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/create.sh
                                                destination: /tmp/create-cache.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/configure.sh
                                                destination: /tmp/configure-cache.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Assert operation
                                                    if [[ "{{ SELF._management_start | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                                        echo 'Management operation "start" missing'
                                                        exit 1 
                                                    fi

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/start.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/start.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/start.sh
                                                destination: /tmp/start-cache.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Assert operation
                                                    if [[ "{{ SELF._management_stop | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                                        echo 'Management operation "stop" missing'
                                                        exit 1 
                                                    fi

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/stop.sh
                                                destination: /tmp/stop-cache.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/delete.sh

                                                    # Delete application directory
                                                    rm -rf "{{ SELF.application_directory }}"
                                                destination: /tmp/delete-cache.sh
                                          remote-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-cache.sh
                                                    - sudo bash /tmp/configure-cache.sh
                                                    - sudo bash /tmp/start-cache.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-cache.sh
                                                    - sudo bash /tmp/delete-cache.sh
                                                when: destroy
    cache~software.application#zip.archive::ansible@*->local.machine:
        derived_from: cache
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: install operational dependencies
                                      ansible.builtin.apt:
                                          name: unzip
                                          update_cache: 'yes'
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: extract deployment artifact in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          extra_opts: '{{ ".artifacts::*::[.type=zip.archive]::extra_opts" | eval | map_value }}'
                                      when: not (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")
                                    - name: extract deployment artifact from URL in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          remote_src: 'yes'
                                          extra_opts: '{{ ".artifacts::*::[.type=zip.archive]::extra_opts" | eval | map_value }}'
                                      when: (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")
                                    - name: create vintner directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}/.vintner'
                                          state: directory
                                    - name: create .env file
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.env'
                                          content: |-
                                              CACHE_NAME="{{ SELF.cache_name }}"
                                              CACHE_PORT="{{ SELF.cache_port }}"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "start" missing
                                      when: SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "stop" missing
                                      when: SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
    cache~software.application#zip.archive::terraform@*->local.machine:
        derived_from: cache
        metadata:
            vintner_generated: 'true'
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            local_file:
                                tmp_artifact:
                                    source: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                    filename: /tmp/artifact-cache
                                    count: '{{ (not (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")) | ternary(1, 0) }}'
                                tmp_create:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Create application directory
                                        mkdir -p {{ SELF.application_directory }}

                                        # Create application environment
                                        cat <<EOF > {{ SELF.application_directory }}/.env
                                        CACHE_NAME="{{ SELF.cache_name }}"
                                        CACHE_PORT="{{ SELF.cache_port }}"
                                        EOF>>

                                        # Download deployment artifact if required
                                        if [[ "{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}" == http* ]]; then 
                                            wget -O /tmp/artifact-cache {{ ".artifacts::*::[.type=zip.archive]::file" | eval }} 
                                        fi

                                        # Extract deployment artifact
                                        unzip /tmp/artifact-cache -d {{ SELF.application_directory }} {{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}

                                        # Create vintner directory
                                        mkdir -p {{ SELF.application_directory }}/.vintner

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/create.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/create.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/create.sh
                                    filename: /tmp/create-cache.sh
                                tmp_configure:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/configure.sh
                                    filename: /tmp/configure-cache.sh
                                tmp_start:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Assert operation
                                        if [[ "{{ SELF._management_start | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                            echo 'Management operation "start" missing'
                                            exit 1 
                                        fi

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/start.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/start.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/start.sh
                                    filename: /tmp/start-cache.sh
                                tmp_stop:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Assert operation
                                        if [[ "{{ SELF._management_stop | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                            echo 'Management operation "stop" missing'
                                            exit 1 
                                        fi

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/stop.sh
                                    filename: /tmp/stop-cache.sh
                                tmp_delete:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/delete.sh

                                        # Delete application directory
                                        rm -rf "{{ SELF.application_directory }}"
                                    filename: /tmp/delete-cache.sh
                            terraform_data:
                                local:
                                    - depends_on:
                                          - local_file.tmp_artifact
                                          - local_file.tmp_create
                                          - local_file.tmp_configure
                                          - local_file.tmp_start
                                          - local_file.tmp_stop
                                          - local_file.tmp_delete
                                      provisioner:
                                          local-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-cache.sh
                                                    - sudo bash /tmp/configure-cache.sh
                                                    - sudo bash /tmp/start-cache.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-cache.sh
                                                    - sudo bash /tmp/delete-cache.sh
                                                when: destroy
    cache~software.application#zip.archive::ansible@*->remote.machine:
        derived_from: cache
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: install operational dependencies
                                      ansible.builtin.apt:
                                          name: unzip
                                          update_cache: 'yes'
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: extract deployment artifact in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          extra_opts: '{{ ".artifacts::*::[.type=zip.archive]::extra_opts" | eval | map_value }}'
                                      when: not (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")
                                    - name: extract deployment artifact from URL in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          remote_src: 'yes'
                                          extra_opts: '{{ ".artifacts::*::[.type=zip.archive]::extra_opts" | eval | map_value }}'
                                      when: (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")
                                    - name: create vintner directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}/.vintner'
                                          state: directory
                                    - name: create .env file
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.env'
                                          content: |-
                                              CACHE_NAME="{{ SELF.cache_name }}"
                                              CACHE_PORT="{{ SELF.cache_port }}"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "start" missing
                                      when: SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "stop" missing
                                      when: SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
    cache~software.application#zip.archive::terraform@*->remote.machine:
        derived_from: cache
        metadata:
            vintner_generated: 'true'
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            os_ssh_host:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            terraform_data:
                                vm:
                                    - connection:
                                          - host: '{{ SELF.os_ssh_host }}'
                                            private_key: ${file("{{ SELF.os_ssh_key_file }}")}
                                            type: ssh
                                            user: '{{ SELF.os_ssh_user }}'
                                      provisioner:
                                          file:
                                              - source: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                                destination: /tmp/artifact-cache
                                                count: '{{ (not (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")) | ternary(1, 0) }}'
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Create application directory
                                                    mkdir -p {{ SELF.application_directory }}

                                                    # Create application environment
                                                    cat <<EOF > {{ SELF.application_directory }}/.env
                                                    CACHE_NAME="{{ SELF.cache_name }}"
                                                    CACHE_PORT="{{ SELF.cache_port }}"
                                                    EOF>>

                                                    # Download deployment artifact if required
                                                    if [[ "{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}" == http* ]]; then 
                                                        wget -O /tmp/artifact-cache {{ ".artifacts::*::[.type=zip.archive]::file" | eval }} 
                                                    fi

                                                    # Extract deployment artifact
                                                    unzip /tmp/artifact-cache -d {{ SELF.application_directory }} {{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}

                                                    # Create vintner directory
                                                    mkdir -p {{ SELF.application_directory }}/.vintner

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/create.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/create.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/create.sh
                                                destination: /tmp/create-cache.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/configure.sh
                                                destination: /tmp/configure-cache.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Assert operation
                                                    if [[ "{{ SELF._management_start | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                                        echo 'Management operation "start" missing'
                                                        exit 1 
                                                    fi

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/start.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/start.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/start.sh
                                                destination: /tmp/start-cache.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Assert operation
                                                    if [[ "{{ SELF._management_stop | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                                        echo 'Management operation "stop" missing'
                                                        exit 1 
                                                    fi

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/stop.sh
                                                destination: /tmp/stop-cache.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/delete.sh

                                                    # Delete application directory
                                                    rm -rf "{{ SELF.application_directory }}"
                                                destination: /tmp/delete-cache.sh
                                          remote-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-cache.sh
                                                    - sudo bash /tmp/configure-cache.sh
                                                    - sudo bash /tmp/start-cache.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-cache.sh
                                                    - sudo bash /tmp/delete-cache.sh
                                                when: destroy
    object.storage~object.storage::ansible@gcp.cloudstorage:
        derived_from: object.storage
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            gcp_service_account_file:
                type: string
                default:
                    get_input: gcp_service_account_file
            gcp_region:
                type: string
                default:
                    get_input: gcp_region
            gcp_project:
                type: string
                default:
                    get_input: gcp_project
        attributes:
            storage_endpoint:
                type: string
                default: '{{ SELF.storage_name }}'
            storage_token:
                type: string
                default: ''
            storage_dialect:
                type: string
                default: gcp
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                            environment:
                                GCP_SERVICE_ACCOUNT_FILE:
                                    eval: .::gcp_service_account_file
                                GCP_AUTH_KIND: serviceaccount
                        inputs:
                            playbook:
                                q:
                                    - name: create bucket
                                      google.cloud.gcp_storage_bucket:
                                          name: '{{ SELF.storage_name }}'
                                          location: EU
                                          project: '{{ SELF.gcp_project }}'
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                            environment:
                                GCP_SERVICE_ACCOUNT_FILE:
                                    eval: .::gcp_service_account_file
                                GCP_AUTH_KIND: serviceaccount
                        inputs:
                            playbook:
                                q:
                                    - name: delete bucket
                                      google.cloud.gcp_storage_bucket:
                                          name: '{{ SELF.storage_name }}'
                                          project: '{{ SELF.gcp_project }}'
                                          state: absent
    object.storage~object.storage::terraform@gcp.cloudstorage:
        derived_from: object.storage
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            gcp_service_account_file:
                type: string
                default:
                    get_input: gcp_service_account_file
            gcp_region:
                type: string
                default:
                    get_input: gcp_region
            gcp_project:
                type: string
                default:
                    get_input: gcp_project
        attributes:
            storage_endpoint:
                type: string
                default: '{{ SELF.storage_name }}'
            storage_token:
                type: string
                default: ''
            storage_dialect:
                type: string
                default: gcp
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                            environment:
                                GOOGLE_APPLICATION_CREDENTIALS:
                                    eval: .::gcp_service_account_file
                    delete:
                        implementation:
                            primary: Terraform
                            environment:
                                GOOGLE_APPLICATION_CREDENTIALS:
                                    eval: .::gcp_service_account_file
            defaults:
                inputs:
                    main:
                        terraform:
                            - required_providers:
                                  - google:
                                        source: hashicorp/google
                                        version: 5.39.1
                        provider:
                            google:
                                - credentials: '{{ SELF.gcp_service_account_file }}'
                                  project: '{{ SELF.gcp_project }}'
                                  region: '{{ SELF.gcp_region }}'
                        resource:
                            google_storage_bucket:
                                bucket:
                                    - name: '{{ SELF.storage_name }}'
                                      location: EU
                                      force_destroy: true
    object.storage~object.storage::ansible@minio.server->docker.engine->local.machine:
        derived_from: object.storage
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: create bucket
                                      dubzland.minio.minio_bucket:
                                          name: '{{ SELF.storage_name }}'
                                          auth:
                                              access_key: '{{ HOST.access_key }}'
                                              secret_key: '{{ HOST.secret_key }}'
                                              url: '{{ HOST.application_endpoint }}'
                                    - name: create user
                                      dubzland.minio.minio_user:
                                          access_key: '{{ SELF.storage_user }}'
                                          secret_key: '{{ SELF.storage_token }}'
                                          auth:
                                              access_key: '{{ HOST.access_key }}'
                                              secret_key: '{{ HOST.secret_key }}'
                                              url: '{{ HOST.application_endpoint }}'
                                    - name: create policy
                                      dubzland.minio.minio_policy:
                                          name: '{{ SELF.user_name }}'
                                          statements:
                                              - effect: Allow
                                                action: s3:*
                                                resource: arn:aws:s3:::*
                                          auth:
                                              access_key: '{{ HOST.access_key }}'
                                              secret_key: '{{ HOST.secret_key }}'
                                              url: '{{ HOST.application_endpoint }}'
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: delete policy
                                      dubzland.minio.minio_policy:
                                          name: '{{ SELF.user_name }}'
                                          statements:
                                              - effect: Allow
                                                action: s3:*
                                                resource: arn:aws:s3:::*
                                          auth:
                                              access_key: '{{ HOST.access_key }}'
                                              secret_key: '{{ HOST.secret_key }}'
                                              url: '{{ HOST.application_endpoint }}'
                                          state: absent
                                    - name: delete user
                                      dubzland.minio.minio_user:
                                          access_key: '{{ SELF.storage_user }}'
                                          secret_key: '{{ SELF.storage_token }}'
                                          auth:
                                              access_key: '{{ HOST.access_key }}'
                                              secret_key: '{{ HOST.secret_key }}'
                                              url: '{{ HOST.application_endpoint }}'
                                          state: absent
                                    - name: delete bucket
                                      dubzland.minio.minio_bucket:
                                          name: '{{ SELF.storage_name }}'
                                          auth:
                                              access_key: '{{ HOST.access_key }}'
                                              secret_key: '{{ HOST.secret_key }}'
                                              url: '{{ HOST.application_endpoint }}'
                                          state: absent
    object.storage~object.storage::compose@minio.server->docker.engine->local.machine:
        derived_from: object.storage
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: touch compose
                                      register: compose
                                      ansible.builtin.tempfile:
                                          suffix: '{{ SELF.storage_name }}-{{ HOST.cache_name }}.database.compose.yaml.compose.yaml'
                                    - name: create compose
                                      ansible.builtin.copy:
                                          dest: '{{ compose.path }}'
                                          content: '{{ manifest | to_yaml }}'
                                      vars:
                                          manifest:
                                              name: '{{ SELF.storage_name }}-{{ HOST.cache_name }}'
                                              services:
                                                  job:
                                                      container_name: '{{ SELF.storage_name }}-{{ HOST.cache_name }}'
                                                      image: minio/mc:{{ ".artifacts::cache_image::file" | eval }}
                                                      network_mode: host
                                                      command:
                                                          - /bin/bash
                                                          - '-c'
                                                          - mc alias set minio {{ HOST.application_endpoint }} {{ HOST.access_key }} {{ HOST.secret_key }} && mc mb minio/{{ SELF.storage_name }} && mc admin user add minio {{ SELF.storage_user }} {{ SELF.storage_token }} && mc admin policy attach minio readwrite user={{ SELF.storage_user }}
                                    - name: apply compose
                                      ansible.builtin.shell: docker compose -f {{ compose.path }} up -d
                                      args:
                                          executable: /usr/bin/bash
                                      environment: {}
                                    - name: let it cook
                                      ansible.builtin.pause:
                                          seconds: 10
                                    - name: unapply compose
                                      ansible.builtin.shell: docker compose -f {{ compose.path }} down
                                      args:
                                          executable: /usr/bin/bash
                                      environment: {}
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: touch compose
                                      register: compose
                                      ansible.builtin.tempfile:
                                          suffix: '{{ SELF.storage_name }}-{{ HOST.cache_name }}.database.compose.yaml.compose.yaml'
                                    - name: create compose
                                      ansible.builtin.copy:
                                          dest: '{{ compose.path }}'
                                          content: '{{ manifest | to_yaml }}'
                                      vars:
                                          manifest:
                                              name: '{{ SELF.storage_name }}-{{ HOST.cache_name }}'
                                              services:
                                                  job:
                                                      container_name: '{{ SELF.storage_name }}-{{ HOST.cache_name }}'
                                                      image: minio/mc:{{ ".artifacts::cache_image::file" | eval }}
                                                      network_mode: host
                                                      command:
                                                          - /bin/bash
                                                          - '-c'
                                                          - mc alias set minio {{ HOST.application_endpoint }} {{ HOST.access_key }} {{ HOST.secret_key }} && mc admin policy detach minio readwrite user={{ SELF.storage_user }} && mc admin user rm minio {{ SELF.storage_user }} && mc rm --recursive minio/{{ SELF.storage_name }}
                                    - name: apply compose
                                      ansible.builtin.shell: docker compose -f {{ compose.path }} up -d
                                      args:
                                          executable: /usr/bin/bash
                                      environment: {}
                                    - name: let it cook
                                      ansible.builtin.pause:
                                          seconds: 10
                                    - name: unapply compose
                                      ansible.builtin.shell: docker compose -f {{ compose.path }} down
                                      args:
                                          executable: /usr/bin/bash
                                      environment: {}
    object.storage~object.storage::terraform@minio.server->docker.engine->local.machine:
        derived_from: object.storage
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        terraform:
                            - required_providers:
                                  - minio:
                                        source: aminueza/minio
                                        version: 2.5.0
                              required_version: '>= 0.14.0'
                        provider:
                            minio:
                                - minio_server: '{{ HOST.application_endpoint }}'
                                  minio_user: '{{ HOST.access_key }}'
                                  minio_password: '{{ HOST.secret_key }}'
                        resource:
                            minio_s3_bucket:
                                bucket:
                                    - bucket: '{{ SELF.storage_name }}'
                            minio_iam_user:
                                user:
                                    - name: '{{ SELF.storage_user }}'
                                      secret: '{{ SELF.storage_token }}'
                            minio_iam_policy:
                                depends_on:
                                    - minio_s3_bucket.bucket
                                    - minio_iam_user.user
                                policy:
                                    - name: '{{ SELF.storage_user }}'
                                      policy: '{ "Version":"2012-10-17", "Statement": [ { "Effect": "Allow", "Action": ["s3:*"], "Principal": "{{ SELF.storage_user }}", "Resource": "arn:aws:s3:::*" } ] }'
    object.storage~object.storage::ansible@minio.server->docker.engine->remote.machine:
        derived_from: object.storage
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            os_ssh_host:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: create bucket
                                      dubzland.minio.minio_bucket:
                                          name: '{{ SELF.storage_name }}'
                                          auth:
                                              access_key: '{{ HOST.access_key }}'
                                              secret_key: '{{ HOST.secret_key }}'
                                              url: '{{ HOST.application_endpoint }}'
                                    - name: create user
                                      dubzland.minio.minio_user:
                                          access_key: '{{ SELF.storage_user }}'
                                          secret_key: '{{ SELF.storage_token }}'
                                          auth:
                                              access_key: '{{ HOST.access_key }}'
                                              secret_key: '{{ HOST.secret_key }}'
                                              url: '{{ HOST.application_endpoint }}'
                                    - name: create policy
                                      dubzland.minio.minio_policy:
                                          name: '{{ SELF.user_name }}'
                                          statements:
                                              - effect: Allow
                                                action: s3:*
                                                resource: arn:aws:s3:::*
                                          auth:
                                              access_key: '{{ HOST.access_key }}'
                                              secret_key: '{{ HOST.secret_key }}'
                                              url: '{{ HOST.application_endpoint }}'
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: delete policy
                                      dubzland.minio.minio_policy:
                                          name: '{{ SELF.user_name }}'
                                          statements:
                                              - effect: Allow
                                                action: s3:*
                                                resource: arn:aws:s3:::*
                                          auth:
                                              access_key: '{{ HOST.access_key }}'
                                              secret_key: '{{ HOST.secret_key }}'
                                              url: '{{ HOST.application_endpoint }}'
                                          state: absent
                                    - name: delete user
                                      dubzland.minio.minio_user:
                                          access_key: '{{ SELF.storage_user }}'
                                          secret_key: '{{ SELF.storage_token }}'
                                          auth:
                                              access_key: '{{ HOST.access_key }}'
                                              secret_key: '{{ HOST.secret_key }}'
                                              url: '{{ HOST.application_endpoint }}'
                                          state: absent
                                    - name: delete bucket
                                      dubzland.minio.minio_bucket:
                                          name: '{{ SELF.storage_name }}'
                                          auth:
                                              access_key: '{{ HOST.access_key }}'
                                              secret_key: '{{ HOST.secret_key }}'
                                              url: '{{ HOST.application_endpoint }}'
                                          state: absent
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
    object.storage~object.storage::compose@minio.server->docker.engine->remote.machine:
        derived_from: object.storage
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            os_ssh_host:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: touch compose
                                      register: compose
                                      ansible.builtin.tempfile:
                                          suffix: '{{ SELF.storage_name }}-{{ HOST.cache_name }}.database.compose.yaml'
                                    - name: create compose
                                      ansible.builtin.copy:
                                          dest: '{{ compose.path }}'
                                          content: '{{ manifest | to_yaml }}'
                                      vars:
                                          manifest:
                                              name: '{{ SELF.storage_name }}-{{ HOST.cache_name }}'
                                              services:
                                                  job:
                                                      container_name: '{{ SELF.storage_name }}-{{ HOST.cache_name }}'
                                                      image: minio/mc:{{ ".artifacts::cache_image::file" | eval }}
                                                      network_mode: host
                                                      command:
                                                          - /bin/bash
                                                          - '-c'
                                                          - mc alias set minio {{ HOST.application_endpoint }} {{ HOST.access_key }} {{ HOST.secret_key }} && mc mb minio/{{ SELF.storage_name }} && mc admin user add minio {{ SELF.storage_user }} {{ SELF.storage_token }} && mc admin policy attach minio readwrite user={{ SELF.storage_user }}
                                    - name: add ssh credentials
                                      community.general.ssh_config:
                                          user: "{{ lookup('env', 'USER') }}"
                                          host: '{{ SELF.os_ssh_host }}'
                                          remote_user: '{{ SELF.os_ssh_user }}'
                                          identity_file: '{{ SELF.os_ssh_key_file }}'
                                          strict_host_key_checking: 'no'
                                          user_known_hosts_file: /dev/null
                                    - name: apply compose
                                      ansible.builtin.shell: docker compose -f {{ compose.path }} up -d
                                      args:
                                          executable: /usr/bin/bash
                                      environment:
                                          DOCKER_HOST: ssh://{{ SELF.os_ssh_host }}
                                    - name: remove ssh credentials
                                      community.general.ssh_config:
                                          user: "{{ lookup('env', 'USER') }}"
                                          host: '{{ SELF.os_ssh_host }}'
                                          state: absent
                                    - name: let it cook
                                      ansible.builtin.pause:
                                          seconds: 10
                                    - name: add ssh credentials
                                      community.general.ssh_config:
                                          user: "{{ lookup('env', 'USER') }}"
                                          host: '{{ SELF.os_ssh_host }}'
                                          remote_user: '{{ SELF.os_ssh_user }}'
                                          identity_file: '{{ SELF.os_ssh_key_file }}'
                                          strict_host_key_checking: 'no'
                                          user_known_hosts_file: /dev/null
                                    - name: unapply compose
                                      ansible.builtin.shell: docker compose -f {{ compose.path }} down
                                      args:
                                          executable: /usr/bin/bash
                                      environment:
                                          DOCKER_HOST: ssh://{{ SELF.os_ssh_host }}
                                    - name: remove ssh credentials
                                      community.general.ssh_config:
                                          user: "{{ lookup('env', 'USER') }}"
                                          host: '{{ SELF.os_ssh_host }}'
                                          state: absent
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: touch compose
                                      register: compose
                                      ansible.builtin.tempfile:
                                          suffix: '{{ SELF.storage_name }}-{{ HOST.cache_name }}.database.compose.yaml'
                                    - name: create compose
                                      ansible.builtin.copy:
                                          dest: '{{ compose.path }}'
                                          content: '{{ manifest | to_yaml }}'
                                      vars:
                                          manifest:
                                              name: '{{ SELF.storage_name }}-{{ HOST.cache_name }}'
                                              services:
                                                  job:
                                                      container_name: '{{ SELF.storage_name }}-{{ HOST.cache_name }}'
                                                      image: minio/mc:{{ ".artifacts::cache_image::file" | eval }}
                                                      network_mode: host
                                                      command:
                                                          - /bin/bash
                                                          - '-c'
                                                          - mc alias set minio {{ HOST.application_endpoint }} {{ HOST.access_key }} {{ HOST.secret_key }} && mc admin policy detach minio readwrite user={{ SELF.storage_user }} && mc admin user rm minio {{ SELF.storage_user }} && mc rm --recursive minio/{{ SELF.storage_name }}
                                    - name: add ssh credentials
                                      community.general.ssh_config:
                                          user: "{{ lookup('env', 'USER') }}"
                                          host: '{{ SELF.os_ssh_host }}'
                                          remote_user: '{{ SELF.os_ssh_user }}'
                                          identity_file: '{{ SELF.os_ssh_key_file }}'
                                          strict_host_key_checking: 'no'
                                          user_known_hosts_file: /dev/null
                                    - name: apply compose
                                      ansible.builtin.shell: docker compose -f {{ compose.path }} up -d
                                      args:
                                          executable: /usr/bin/bash
                                      environment:
                                          DOCKER_HOST: ssh://{{ SELF.os_ssh_host }}
                                    - name: remove ssh credentials
                                      community.general.ssh_config:
                                          user: "{{ lookup('env', 'USER') }}"
                                          host: '{{ SELF.os_ssh_host }}'
                                          state: absent
                                    - name: let it cook
                                      ansible.builtin.pause:
                                          seconds: 10
                                    - name: add ssh credentials
                                      community.general.ssh_config:
                                          user: "{{ lookup('env', 'USER') }}"
                                          host: '{{ SELF.os_ssh_host }}'
                                          remote_user: '{{ SELF.os_ssh_user }}'
                                          identity_file: '{{ SELF.os_ssh_key_file }}'
                                          strict_host_key_checking: 'no'
                                          user_known_hosts_file: /dev/null
                                    - name: unapply compose
                                      ansible.builtin.shell: docker compose -f {{ compose.path }} down
                                      args:
                                          executable: /usr/bin/bash
                                      environment:
                                          DOCKER_HOST: ssh://{{ SELF.os_ssh_host }}
                                    - name: remove ssh credentials
                                      community.general.ssh_config:
                                          user: "{{ lookup('env', 'USER') }}"
                                          host: '{{ SELF.os_ssh_host }}'
                                          state: absent
    object.storage~object.storage::terraform@minio.server->docker.engine->remote.machine:
        derived_from: object.storage
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            os_ssh_host:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        terraform:
                            - required_providers:
                                  - minio:
                                        source: aminueza/minio
                                        version: 2.5.0
                                    ssh:
                                        source: AndrewChubatiuk/ssh
                                        version: 0.2.3
                              required_version: '>= 0.14.0'
                        data:
                            ssh_tunnel:
                                mysql:
                                    - remote:
                                          host: '{{ HOST.application_address }}'
                                          port: '{{ HOST.application_port }}'
                        provider:
                            minio:
                                - minio_server: '{{ HOST.application_endpoint }}'
                                  minio_user: '{{ HOST.access_key }}'
                                  minio_password: '{{ HOST.secret_key }}'
                            ssh:
                                - auth:
                                      private_key:
                                          content: ${file(pathexpand("{{ SELF.os_ssh_key_file }}"))}
                                  server:
                                      host: '{{ HOST.management_address }}'
                                      port: 22
                                  user: '{{ SELF.os_ssh_user }}'
                        resource:
                            minio_s3_bucket:
                                bucket:
                                    - bucket: '{{ SELF.storage_name }}'
                            minio_iam_user:
                                user:
                                    - name: '{{ SELF.storage_user }}'
                                      secret: '{{ SELF.storage_token }}'
                            minio_iam_policy:
                                depends_on:
                                    - minio_s3_bucket.bucket
                                    - minio_iam_user.user
                                policy:
                                    - name: '{{ SELF.storage_user }}'
                                      policy: '{ "Version":"2012-10-17", "Statement": [ { "Effect": "Allow", "Action": ["s3:*"], "Principal": "{{ SELF.storage_user }}", "Resource": "arn:aws:s3:::*" } ] }'
    object.storage~object.storage::ansible@minio.server->kubernetes.cluster:
        derived_from: object.storage
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            k8s_host:
                type: string
                default:
                    get_input: k8s_host
            k8s_ca_cert_file:
                type: string
                default:
                    get_input: k8s_ca_cert_file
            k8s_client_cert_file:
                type: string
                default:
                    get_input: k8s_client_cert_file
            k8s_client_key_file:
                type: string
                default:
                    get_input: k8s_client_key_file
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: create bucket
                                      block:
                                          - name: forward port
                                            ansible.builtin.shell: kubectl --server {{ SELF.k8s_host }} --certificate-authority {{ SELF.k8s_ca_cert_file }} --client-certificate {{ SELF.k8s_client_cert_file }} --client-key {{ SELF.k8s_client_key_file }} port-forward service/{{ HOST.cache_name }} {{ HOST.cache_port }}:{{ HOST.cache_port }}
                                            args:
                                                executable: /usr/bin/bash
                                            async: 30
                                            poll: 0
                                          - name: create bucket
                                            dubzland.minio.minio_bucket:
                                                name: '{{ SELF.storage_name }}'
                                                auth:
                                                    access_key: '{{ HOST.access_key }}'
                                                    secret_key: '{{ HOST.secret_key }}'
                                                    url: '{{ HOST.application_endpoint }}'
                                          - name: create user
                                            dubzland.minio.minio_user:
                                                access_key: '{{ SELF.storage_user }}'
                                                secret_key: '{{ SELF.storage_token }}'
                                                auth:
                                                    access_key: '{{ HOST.access_key }}'
                                                    secret_key: '{{ HOST.secret_key }}'
                                                    url: '{{ HOST.application_endpoint }}'
                                          - name: create policy
                                            dubzland.minio.minio_policy:
                                                name: '{{ SELF.user_name }}'
                                                statements:
                                                    - effect: Allow
                                                      action: s3:*
                                                      resource: arn:aws:s3:::*
                                                auth:
                                                    access_key: '{{ HOST.access_key }}'
                                                    secret_key: '{{ HOST.secret_key }}'
                                                    url: '{{ HOST.application_endpoint }}'
                                      always:
                                          - name: unforward port
                                            ansible.builtin.shell: pkill -f "port-forward service/{{ HOST.cache_name }}"
                                            args:
                                                executable: /usr/bin/bash
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: delete bucket
                                      block:
                                          - name: forward port
                                            ansible.builtin.shell: kubectl --server {{ SELF.k8s_host }} --certificate-authority {{ SELF.k8s_ca_cert_file }} --client-certificate {{ SELF.k8s_client_cert_file }} --client-key {{ SELF.k8s_client_key_file }} port-forward service/{{ HOST.cache_name }} {{ HOST.cache_port }}:{{ HOST.cache_port }}
                                            args:
                                                executable: /usr/bin/bash
                                            async: 30
                                            poll: 0
                                          - name: delete policy
                                            dubzland.minio.minio_policy:
                                                name: '{{ SELF.user_name }}'
                                                statements:
                                                    - effect: Allow
                                                      action: s3:*
                                                      resource: arn:aws:s3:::*
                                                auth:
                                                    access_key: '{{ HOST.access_key }}'
                                                    secret_key: '{{ HOST.secret_key }}'
                                                    url: '{{ HOST.application_endpoint }}'
                                                state: absent
                                          - name: delete user
                                            dubzland.minio.minio_user:
                                                access_key: '{{ SELF.storage_user }}'
                                                secret_key: '{{ SELF.storage_token }}'
                                                auth:
                                                    access_key: '{{ HOST.access_key }}'
                                                    secret_key: '{{ HOST.secret_key }}'
                                                    url: '{{ HOST.application_endpoint }}'
                                                state: absent
                                          - name: delete bucket
                                            dubzland.minio.minio_bucket:
                                                name: '{{ SELF.storage_name }}'
                                                auth:
                                                    access_key: '{{ HOST.access_key }}'
                                                    secret_key: '{{ HOST.secret_key }}'
                                                    url: '{{ HOST.application_endpoint }}'
                                                state: absent
                                      always:
                                          - name: unforward port
                                            ansible.builtin.shell: pkill -f "port-forward service/{{ HOST.cache_name }}"
                                            args:
                                                executable: /usr/bin/bash
    object.storage~object.storage::kubernetes@minio.server->kubernetes.cluster:
        derived_from: object.storage
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            k8s_host:
                type: string
                default:
                    get_input: k8s_host
            k8s_ca_cert_file:
                type: string
                default:
                    get_input: k8s_ca_cert_file
            k8s_client_cert_file:
                type: string
                default:
                    get_input: k8s_client_cert_file
            k8s_client_key_file:
                type: string
                default:
                    get_input: k8s_client_key_file
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: touch manifest
                                      register: manifest
                                      ansible.builtin.tempfile:
                                          suffix: '{{ SELF.storage_name }}-{{ HOST.cache_name }}.object-storage.manifest.yaml'
                                    - name: create manifest
                                      ansible.builtin.copy:
                                          dest: '{{ manifest.path }}'
                                          content: '{{ job | to_yaml }}'
                                      vars:
                                          job:
                                              apiVersion: batch/v1
                                              kind: Job
                                              metadata:
                                                  name: '{{ SELF.storage_name }}-{{ HOST.cache_name }}'
                                              spec:
                                                  template:
                                                      spec:
                                                          restartPolicy: Never
                                                          containers:
                                                              - name: '{{ SELF.storage_name }}-{{ HOST.cache_name }}'
                                                                image: minio/mc:{{ ".artifacts::cache_image::file" | eval }}
                                                                command:
                                                                    - /bin/bash
                                                                    - '-c'
                                                                    - mc alias set minio {{ HOST.application_endpoint }} {{ HOST.access_key }} {{ HOST.secret_key }} && mc mb minio/{{ SELF.storage_name }} && mc admin user add minio {{ SELF.storage_user }} {{ SELF.storage_token }} && mc admin policy attach minio readwrite user={{ SELF.storage_user }}
                                    - name: apply manifest
                                      ansible.builtin.shell: kubectl --server {{ SELF.k8s_host }} --certificate-authority {{ SELF.k8s_ca_cert_file }} --client-certificate {{ SELF.k8s_client_cert_file }} --client-key {{ SELF.k8s_client_key_file }} apply -f {{ manifest.path }}
                                      args:
                                          executable: /usr/bin/bash
                                    - name: wait for deployment
                                      ansible.builtin.shell: kubectl --server {{ SELF.k8s_host }} --certificate-authority {{ SELF.k8s_ca_cert_file }} --client-certificate {{ SELF.k8s_client_cert_file }} --client-key {{ SELF.k8s_client_key_file }} wait --for=condition=complete --timeout=30s job/{{ SELF.storage_name }}-{{ HOST.cache_name }}
                                      args:
                                          executable: /usr/bin/bash
                                    - name: cleanup
                                      ansible.builtin.shell: kubectl --server {{ SELF.k8s_host }} --certificate-authority {{ SELF.k8s_ca_cert_file }} --client-certificate {{ SELF.k8s_client_cert_file }} --client-key {{ SELF.k8s_client_key_file }} delete -f {{ manifest.path }}
                                      args:
                                          executable: /usr/bin/bash
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: touch manifest
                                      register: manifest
                                      ansible.builtin.tempfile:
                                          suffix: '{{ SELF.storage_name }}-{{ HOST.cache_name }}.object-storage.manifest.yaml'
                                    - name: create manifest
                                      ansible.builtin.copy:
                                          dest: '{{ manifest.path }}'
                                          content: '{{ job | to_yaml }}'
                                      vars:
                                          job:
                                              apiVersion: batch/v1
                                              kind: Job
                                              metadata:
                                                  name: '{{ SELF.storage_name }}-{{ HOST.cache_name }}'
                                              spec:
                                                  template:
                                                      spec:
                                                          restartPolicy: Never
                                                          containers:
                                                              - name: '{{ SELF.storage_name }}-{{ HOST.cache_name }}'
                                                                image: minio/mc:{{ ".artifacts::cache_image::file" | eval }}
                                                                command:
                                                                    - /bin/bash
                                                                    - '-c'
                                                                    - mc alias set minio {{ HOST.application_endpoint }} {{ HOST.access_key }} {{ HOST.secret_key }} && mc admin policy detach minio readwrite user={{ SELF.storage_user }} && mc admin user rm minio {{ SELF.storage_user }} && mc rm --recursive minio/{{ SELF.storage_name }}
                                    - name: apply manifest
                                      ansible.builtin.shell: kubectl --server {{ SELF.k8s_host }} --certificate-authority {{ SELF.k8s_ca_cert_file }} --client-certificate {{ SELF.k8s_client_cert_file }} --client-key {{ SELF.k8s_client_key_file }} apply -f {{ manifest.path }}
                                      args:
                                          executable: /usr/bin/bash
                                    - name: wait for deployment
                                      ansible.builtin.shell: kubectl --server {{ SELF.k8s_host }} --certificate-authority {{ SELF.k8s_ca_cert_file }} --client-certificate {{ SELF.k8s_client_cert_file }} --client-key {{ SELF.k8s_client_key_file }} wait --for=condition=complete --timeout=30s job/{{ SELF.storage_name }}-{{ HOST.cache_name }}
                                      args:
                                          executable: /usr/bin/bash
                                    - name: cleanup
                                      ansible.builtin.shell: kubectl --server {{ SELF.k8s_host }} --certificate-authority {{ SELF.k8s_ca_cert_file }} --client-certificate {{ SELF.k8s_client_cert_file }} --client-key {{ SELF.k8s_client_key_file }} delete -f {{ manifest.path }}
                                      args:
                                          executable: /usr/bin/bash
    object.storage~object.storage::terraform@minio.server->kubernetes.cluster:
        derived_from: object.storage
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            k8s_host:
                type: string
                default:
                    get_input: k8s_host
            k8s_ca_cert_file:
                type: string
                default:
                    get_input: k8s_ca_cert_file
            k8s_client_cert_file:
                type: string
                default:
                    get_input: k8s_client_cert_file
            k8s_client_key_file:
                type: string
                default:
                    get_input: k8s_client_key_file
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        terraform: []
                        provider: {}
                        resource:
                            terraform_data:
                                forward_port:
                                    - input: 127.0.0.1:{{ HOST.cache_port }}
                                      provisioner:
                                          local-exec:
                                              command: |-
                                                  (nohup kubectl --server {{ SELF.k8s_host }} --certificate-authority {{ SELF.k8s_ca_cert_file }} --client-certificate {{ SELF.k8s_client_cert_file }} --client-key {{ SELF.k8s_client_key_file }} port-forward service/{{ HOST.cache_name }} {{ HOST.cache_port }}:{{ HOST.cache_port }} > /dev/null 2>&1 &)
                                                  sleep 5s
                                              interpreter:
                                                  - /bin/bash
                                                  - '-c'
                                unforward_port:
                                    - depends_on:
                                          - minio_iam_policy.policy
                                      provisioner:
                                          local-exec:
                                              command: pkill -f "port-forward service/{{ HOST.cache_name }}"
                                              interpreter:
                                                  - /bin/bash
                                                  - '-c'
                            minio_s3_bucket:
                                bucket:
                                    - bucket: '{{ SELF.storage_name }}'
                            minio_iam_user:
                                user:
                                    - name: '{{ SELF.storage_user }}'
                                      secret: '{{ SELF.storage_token }}'
                            minio_iam_policy:
                                depends_on:
                                    - minio_s3_bucket.bucket
                                    - minio_iam_user.user
                                policy:
                                    - name: '{{ SELF.storage_user }}'
                                      policy: '{ "Version":"2012-10-17", "Statement": [ { "Effect": "Allow", "Action": ["s3:*"], "Principal": "{{ SELF.storage_user }}", "Resource": "arn:aws:s3:::*" } ] }'
    ingress~ingress::ansible@kubernetes.cluster:
        derived_from: ingress
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            k8s_host:
                type: string
                default:
                    get_input: k8s_host
            k8s_ca_cert_file:
                type: string
                default:
                    get_input: k8s_ca_cert_file
            k8s_client_cert_file:
                type: string
                default:
                    get_input: k8s_client_cert_file
            k8s_client_key_file:
                type: string
                default:
                    get_input: k8s_client_key_file
        attributes:
            application_address:
                type: string
                default: not implemented
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                            environment:
                                K8S_AUTH_HOST:
                                    eval: .::k8s_host
                                K8S_AUTH_SSL_CA_CERT:
                                    eval: .::k8s_ca_cert_file
                                K8S_AUTH_CERT_FILE:
                                    eval: .::k8s_client_cert_file
                                K8S_AUTH_KEY_FILE:
                                    eval: .::k8s_client_key_file
                        inputs:
                            playbook:
                                q:
                                    - name: apply service
                                      kubernetes.core.k8s:
                                          definition:
                                              apiVersion: v1
                                              kind: Service
                                              metadata:
                                                  name: '{{ SELF.application_name }}-external'
                                                  namespace: default
                                              spec:
                                                  ports:
                                                      - name: '{{ SELF.application_protocol }}'
                                                        port: 80
                                                        targetPort: '{{ SELF.application_port }}'
                                                  selector:
                                                      app: '{{ SELF.application_name }}'
                                                  type: LoadBalancer
    ingress~ingress::kubernetes@kubernetes.cluster:
        derived_from: ingress
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            k8s_host:
                type: string
                default:
                    get_input: k8s_host
            k8s_ca_cert_file:
                type: string
                default:
                    get_input: k8s_ca_cert_file
            k8s_client_cert_file:
                type: string
                default:
                    get_input: k8s_client_cert_file
            k8s_client_key_file:
                type: string
                default:
                    get_input: k8s_client_key_file
        attributes:
            application_address:
                type: string
                default: not implemented
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: touch manifest
                                      register: manifest
                                      ansible.builtin.tempfile:
                                          suffix: '{{ SELF.application_name }}.ingress.manifest.yaml'
                                    - name: create manifest
                                      ansible.builtin.copy:
                                          dest: '{{ manifest.path }}'
                                          content: '{{ service | to_yaml }}'
                                      vars:
                                          service:
                                              apiVersion: v1
                                              kind: Service
                                              metadata:
                                                  name: '{{ SELF.application_name }}-external'
                                              spec:
                                                  ports:
                                                      - name: '{{ SELF.application_protocol }}'
                                                        port: '{{ SELF.application_port }}'
                                                        targetPort: '{{ SELF.application_port }}'
                                                  selector:
                                                      app: '{{ SELF.application_name }}'
                                                  type: LoadBalancer
                                    - name: apply manifest
                                      ansible.builtin.shell: kubectl --server {{ SELF.k8s_host }} --certificate-authority {{ SELF.k8s_ca_cert_file }} --client-certificate {{ SELF.k8s_client_cert_file }} --client-key {{ SELF.k8s_client_key_file }} apply -f {{ manifest.path }}
                                      args:
                                          executable: /usr/bin/bash
    ingress~ingress::terraform@kubernetes.cluster:
        derived_from: ingress
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            k8s_host:
                type: string
                default:
                    get_input: k8s_host
            k8s_ca_cert_file:
                type: string
                default:
                    get_input: k8s_ca_cert_file
            k8s_client_cert_file:
                type: string
                default:
                    get_input: k8s_client_cert_file
            k8s_client_key_file:
                type: string
                default:
                    get_input: k8s_client_key_file
        attributes:
            application_address:
                type: string
                default: not implemented
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        terraform:
                            - required_providers:
                                  - kubernetes:
                                        source: hashicorp/kubernetes
                                        version: 2.31.0
                              required_version: '>= 0.14.0'
                        provider:
                            kubernetes:
                                - client_certificate: ${file("{{ SELF.k8s_client_cert_file }}")}
                                  client_key: ${file("{{ SELF.k8s_client_key_file }}")}
                                  cluster_ca_certificate: ${file("{{ SELF.k8s_ca_cert_file }}")}
                                  host: '{{ SELF.k8s_host }}'
                        resource:
                            kubernetes_service_v1:
                                application:
                                    - metadata:
                                          - name: '{{ SELF.application_name }}-external'
                                      wait_for_load_balancer: false
                                      spec:
                                          - port:
                                                - name: '{{ SELF.application_protocol }}'
                                                  port: 80
                                                  target_port: '{{ SELF.application_port }}'
                                            selector:
                                                app: '{{ SELF.application_name }}'
                                            type: LoadBalancer
    ingress~ingress::ansible@local.machine:
        derived_from: ingress
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        attributes:
            application_address:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::application_address
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: add apt key
                                      ansible.builtin.apt_key:
                                          url: https://dl.cloudsmith.io/public/caddy/stable/gpg.key
                                          keyring: /usr/share/keyrings/caddy-stable-archive-keyring.gpg
                                          state: present
                                    - name: add apt repository
                                      ansible.builtin.apt_repository:
                                          repo: deb [signed-by=/usr/share/keyrings/caddy-stable-archive-keyring.gpg] https://dl.cloudsmith.io/public/caddy/stable/deb/debian any-version main
                                          filename: caddy-stable
                                          state: present
                                    - name: install package
                                      ansible.builtin.apt:
                                          name: caddy
                                          state: present
                                          update_cache: 'yes'
                                    - name: configure caddy
                                      ansible.builtin.copy:
                                          dest: /etc/caddy/Caddyfile
                                          content: |
                                              :80 {
                                                      reverse_proxy localhost:{{ SELF.application_port }}
                                              }
                                    - name: restart caddy
                                      ansible.builtin.systemd:
                                          name: caddy
                                          state: reloaded
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: uninstall package
                                      ansible.builtin.apt:
                                          name: caddy
                                          state: absent
    ingress~ingress::terraform@local.machine:
        derived_from: ingress
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        attributes:
            application_address:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::application_address
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            local_file:
                                tmp_script:
                                    content: |

                                        #!/usr/bin/bash
                                        set -e

                                        # Install caddy
                                        apt-get install -y debian-keyring debian-archive-keyring apt-transport-https curl
                                        curl -1sLf https://dl.cloudsmith.io/public/caddy/stable/gpg.key | gpg --dearmor --yes -o /usr/share/keyrings/caddy-stable-archive-keyring.gpg
                                        curl -1sLf https://dl.cloudsmith.io/public/caddy/stable/debian.deb.txt | tee /etc/apt/sources.list.d/caddy-stable.list
                                        apt-get update
                                        apt-get install caddy -y

                                        # Configure caddy
                                        cat <<EOF > /etc/caddy/Caddyfile
                                        :80 {
                                                reverse_proxy localhost:{{ SELF.application_port }}
                                        }
                                        EOF

                                        # Restart caddy
                                        systemctl reload caddy
                                    destination: /tmp/install-ingress.sh
                            terraform_data:
                                local:
                                    - depends_on:
                                          - local_file.tmp_script
                                      provisioner:
                                          local-exec:
                                              - inline:
                                                    - sudo bash /tmp/install-ingress.sh
    ingress~ingress::ansible@remote.machine:
        derived_from: ingress
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
        attributes:
            application_address:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::application_address
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: add apt key
                                      ansible.builtin.apt_key:
                                          url: https://dl.cloudsmith.io/public/caddy/stable/gpg.key
                                          keyring: /usr/share/keyrings/caddy-stable-archive-keyring.gpg
                                          state: present
                                    - name: add apt repository
                                      ansible.builtin.apt_repository:
                                          repo: deb [signed-by=/usr/share/keyrings/caddy-stable-archive-keyring.gpg] https://dl.cloudsmith.io/public/caddy/stable/deb/debian any-version main
                                          filename: caddy-stable
                                          state: present
                                    - name: install package
                                      ansible.builtin.apt:
                                          name: caddy
                                          state: present
                                          update_cache: 'yes'
                                    - name: configure caddy
                                      ansible.builtin.copy:
                                          dest: /etc/caddy/Caddyfile
                                          content: |
                                              :80 {
                                                      reverse_proxy localhost:{{ SELF.application_port }}
                                              }
                                    - name: restart caddy
                                      ansible.builtin.systemd:
                                          name: caddy
                                          state: reloaded
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: uninstall package
                                      ansible.builtin.apt:
                                          name: caddy
                                          state: absent
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
    ingress~ingress::terraform@remote.machine:
        derived_from: ingress
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            os_ssh_host:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
        attributes:
            application_address:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::application_address
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            terraform_data:
                                vm:
                                    - connection:
                                          - host: '{{ SELF.os_ssh_host }}'
                                            private_key: ${file("{{ SELF.os_ssh_key_file }}")}
                                            type: ssh
                                            user: '{{ SELF.os_ssh_user }}'
                                      provisioner:
                                          file:
                                              - content: |

                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Install caddy
                                                    apt-get install -y debian-keyring debian-archive-keyring apt-transport-https curl
                                                    curl -1sLf https://dl.cloudsmith.io/public/caddy/stable/gpg.key | gpg --dearmor --yes -o /usr/share/keyrings/caddy-stable-archive-keyring.gpg
                                                    curl -1sLf https://dl.cloudsmith.io/public/caddy/stable/debian.deb.txt | tee /etc/apt/sources.list.d/caddy-stable.list
                                                    apt-get update
                                                    apt-get install caddy -y

                                                    # Configure caddy
                                                    cat <<EOF > /etc/caddy/Caddyfile
                                                    :80 {
                                                            reverse_proxy localhost:{{ SELF.application_port }}
                                                    }
                                                    EOF

                                                    # Restart caddy
                                                    systemctl reload caddy
                                                destination: /tmp/install-ingress.sh
                                          remote-exec:
                                              - inline:
                                                    - sudo bash /tmp/install-ingress.sh

###################################################
#
# WARNING: Do not edit! This file is autogenerated!
#
###################################################

tosca_definitions_version: tosca_simple_yaml_1_3
description: TOSCA Profile for OpenTOSCA Vintner (Extended)
metadata:
    vintner_normative: 'true'
    template_name: TOSCA Vintner Profile (Extended)
    template_author: Miles St√∂tzner
    template_contact: miles.stoetzner@iste.uni-stuttgart.de
    template_link: https://vintner.opentosca.org
    template_version: 1.0.0-draft
    template_id: tosca-vintner-profile
    template_license: https://www.apache.org/licenses/LICENSE-2.0
    acknowledgments: Partially funded by the [German Federal Ministry for Economic Affairs and Climate Action (BMWK)](https://www.bmwk.de) as part of the research project [SofDCar (19S21002)](https://sofdcar.de).
    vintner_orchestrator: unfurl
imports:
    - tosca-vintner-profile-core.yaml
artifact_types:
    docker.image:
        derived_from: container.image
        description: The "docker.image" artifact type manages a concrete Docker Image. It expects the Docker Image reference in the "file" key.
    zip.archive:
        derived_from: source.archive
        description: The "zip.archive" artifact type manages a ZIP archive, which contains the distribution files of a component.
    tar.archive:
        derived_from: source.archive
        description: The "tar.archive" artifact type manages a TAR archive, which contains the distribution files of a component
    apt.package:
        derived_from: system.package
        description: The "apt.package" artifact type manages a package that is installed via the apt package manager.
        properties:
            script:
                type: string
                required: false
                description: URL of an installation script
            repository:
                type: string
                required: false
                description: name of the repository (required if source is set)
            key:
                type: string
                required: false
                description: URL of the apt key which signs the apt repository (required if source is set)
            source:
                type: string
                required: false
                description: source of the repository
            dependencies:
                type: string
                required: false
                description: Comma separated list of apt packages that are additionally installed
            env:
                type: string
                required: false
                description: Space separated env variables
                default: ''
node_types:
    nodejs.runtime:
        derived_from: software.runtime
        description: The "nodejs.runtime" node type manages the Node.js runtime, which is a software runtime that runs on a machine. It is capable of hosting Node.js components
        metadata:
            vintner_normative: 'true'
        properties:
            application_name:
                type: string
                default: nodejs
                description: the name of the application
        artifacts:
            apt_package:
                type: apt.package
                description: the apt package to install Node.js
                file: nodejs
                properties:
                    script: https://deb.nodesource.com/setup_18.x
        attributes:
            management_address:
                type: string
                description: the management address of the host
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
        capabilities:
            host:
                type: tosca.capabilities.Compute
            endpoint:
                type: unfurl.capabilities.Endpoint.Ansible
                properties:
                    connection: ssh
                    host:
                        eval: .parent::management_address
    nodejs.service.application:
        derived_from: service.application
        description: The "nodejs.service.application" node type manages a Node.js service application.
        metadata:
            vintner_normative: 'true'
            vintner_abstract: 'true'
        properties:
            application_language:
                type: string
                default: nodejs18
        interfaces:
            management:
                type: management
                operations:
                    configure: npm ci
                    start: npm start
    reactjs.service.application:
        derived_from: service.application
        description: The "reactjs.service.application" node type manages a React.js service application.
        metadata:
            vintner_normative: 'true'
            vintner_abstract: 'true'
        properties:
            application_language:
                type: string
                default: nodejs18
    python.runtime:
        derived_from: software.runtime
        description: The "python.runtime" node type manages the Python runtime, which is a software runtime that runs on a machine. It is capable of hosting Python components.
        metadata:
            vintner_normative: 'true'
        artifacts:
            apt_package:
                type: apt.package
                file: python-is-python3
                properties:
                    dependencies:
                        type: string
                        default: python3 python3-pip python3-venv
        attributes:
            management_address:
                type: string
                description: the management address of the host
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
        capabilities:
            host:
                type: tosca.capabilities.Compute
            endpoint:
                type: unfurl.capabilities.Endpoint.Ansible
                properties:
                    connection: ssh
                    host:
                        eval: .parent::management_address
    python.service.application:
        derived_from: service.application
        description: The "python.service.application" node type manages a Python service application.
        metadata:
            vintner_normative: 'true'
            vintner_abstract: 'true'
        properties:
            application_language:
                type: string
                default: python3
        interfaces:
            management:
                type: management
                operations:
                    configure: pip install -r requirements.txt
                    start: python main.py
    go.service.application:
        derived_from: service.application
        description: The "go.service.application" node type manages a Go service application.
        metadata:
            vintner_normative: 'true'
            vintner_abstract: 'true'
        properties:
            application_language:
                type: string
                default: go122
    java.runtime:
        derived_from: software.runtime
        description: The "java.runtime" node type manages the Java runtime, which is a software runtime that runs on a machine. It is capable of hosting Java components.
        metadata:
            vintner_normative: 'true'
        properties:
            application_name:
                type: string
                default: java
        artifacts:
            apt_package:
                type: apt.package
                file: openjdk-18-jre-headless
        attributes:
            management_address:
                type: string
                description: the management address of the host
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
        capabilities:
            host:
                type: tosca.capabilities.Compute
            endpoint:
                type: unfurl.capabilities.Endpoint.Ansible
                properties:
                    connection: ssh
                    host:
                        eval: .parent::management_address
    java.service.application:
        derived_from: service.application
        description: The "java.service.application" node type manages a Java service application.
        metadata:
            vintner_normative: 'true'
            vintner_abstract: 'true'
        properties:
            application_language:
                type: string
                default: java21
    dotnet.runtime:
        derived_from: software.runtime
        description: The "dotnet.runtime" node type manages the .NET runtime, which is a software runtime that runs on a machine. It is capable of hosting .NET components.
        metadata:
            vintner_normative: 'true'
        properties:
            application_name:
                type: string
                default: java
        artifacts:
            apt_package:
                type: apt.package
                file: dotnet-sdk-8.0
        attributes:
            management_address:
                type: string
                description: the management address of the host
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
        capabilities:
            host:
                type: tosca.capabilities.Compute
            endpoint:
                type: unfurl.capabilities.Endpoint.Ansible
                properties:
                    connection: ssh
                    host:
                        eval: .parent::management_address
    csharp.service.application:
        derived_from: service.application
        description: The "csharp.service.application" node type manages a C# service application.
        metadata:
            vintner_normative: 'true'
            vintner_abstract: 'true'
        properties:
            application_language:
                type: string
                default: dotnet8
    binary.service.application:
        derived_from: service.application
        description: The "binary.service.application" node type manages a binary service application.
        metadata:
            vintner_normative: 'true'
            vintner_abstract: 'true'
        properties:
            application_language:
                type: string
                default: binary
        interfaces:
            management:
                type: management
                operations:
                    start: ./{{ SELF.application_name }}
    gcp.provider:
        derived_from: cloud.provider
        description: The abstract "gcp.provider" node type defines a Google Cloud Platform (GCP) project.
        metadata:
            vintner_normative: 'true'
            vintner_abstract: 'true'
        properties:
            _hosting:
                type: string
                default: gcp
            gcp_region:
                type: string
                description: the region of the GCP project
            gcp_service_account_file:
                type: string
                description: the service account file of the GCP project, i.e., the absolute path to the serivce account file on the filesystem of the orchestrator
            gcp_project:
                type: string
        interfaces:
            Standard:
                operations:
                    create: exit 0
                    delete: exit 0
    gcp.service:
        derived_from: cloud.service
        description: The abstract "gcp.service" node type defines a Google Cloud Platform (GCP) service.
        metadata:
            vintner_normative: 'true'
            vintner_abstract: 'true'
        properties:
            _hosting:
                type: string
                default: gcp
            gcp_service:
                type: string
                description: the API of the GCP service
                default: must-be-overridden
    gcp.cloudrun:
        derived_from: gcp.service
        description: The "gcp.cloudrun" node type manages a the GCP CloudRun service.
        metadata:
            vintner_normative: 'true'
        properties:
            gcp_service:
                type: string
                default: run.googleapis.com
    gcp.cloudsql:
        derived_from: gcp.service
        description: The "gcp.cloudsql" node type manages a the GCP CloudSQL service.
        metadata:
            vintner_normative: 'true'
        properties:
            gcp_service:
                type: string
                default: sqladmin.googleapis.com
    gcp.appengine:
        derived_from: gcp.service
        description: The "gcp.appengine" node type manages a the GCP AppEngine service.
        metadata:
            vintner_normative: 'true'
        properties:
            gcp_service:
                type: string
                default: appengine.googleapis.com
        requirements:
            - build:
                  capability: tosca.capabilities.Root
                  relationship: tosca.relationships.DependsOn
            - reporting:
                  capability: tosca.capabilities.Root
                  relationship: tosca.relationships.DependsOn
    gcp.appenginereporting:
        derived_from: gcp.service
        description: The "gcp.appenginereporting" node type manages a the GCP AppEngine Reporting service.
        metadata:
            vintner_normative: 'true'
        properties:
            gcp_service:
                type: string
                default: appenginereporting.googleapis.com
    gcp.cloudbuild:
        derived_from: gcp.service
        description: The "gcp.cloudbuild" node type manages a the GCP CloudBuild service.
        metadata:
            vintner_normative: 'true'
        properties:
            gcp_service:
                type: string
                default: cloudbuild.googleapis.com
    gcp.kubernetesengine:
        derived_from: gcp.service
        description: The "gcp.kubernetesengine" node type manages a the GCP Kubernetes Engine service.
        metadata:
            vintner_normative: 'true'
        properties:
            gcp_service:
                type: string
                default: container.googleapis.com
    gcp.cloudstorage:
        derived_from: gcp.service
        description: The "gcp.cloudstorage" node type manages a the GCP CloudStorage service.
        metadata:
            vintner_normative: 'true'
        properties:
            gcp_service:
                type: string
                default: storage.googleapis.com
        attributes:
            storage_dialect:
                type: string
                default: gcp
    gcp.memorystore:
        derived_from: gcp.service
        description: The "gcp.memorystore" node type manages a the GCP Memorystore service.
        metadata:
            vintner_normative: 'true'
        properties:
            gcp_service:
                type: string
                default: redis.googleapis.com
    docker.engine:
        derived_from: container.runtime
        description: The "docker.engine" node type manages the Docker Engine, which is a software runtime that runs on a machine. It is capable of hosting Docker containers. It is configured to listen on the unix socket as well as on tcp://0.0.0.0:2375.
        metadata:
            vintner_normative: 'true'
        properties:
            application_name:
                type: string
                default: docker
            _hosting:
                type: string
                default: docker
        attributes:
            management_address:
                type: string
                description: the management address of the host
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
        capabilities:
            host:
                type: tosca.capabilities.Compute
            endpoint:
                type: unfurl.capabilities.Endpoint.Ansible
                properties:
                    connection: ssh
                    host:
                        eval: .parent::management_address
    kubernetes.cluster:
        derived_from: cloud.service
        description: The abstract "kubernetes.cluster" node type describes a Kubernetes cluster. It is typically hosted on a cloud provider.
        metadata:
            vintner_normative: 'true'
            vintner_abstract: 'true'
        properties:
            _hosting:
                type: string
                default: kubernetes
            k8s_host:
                type: string
                description: the host of the Kubernetes API
            k8s_ca_cert_file:
                type: string
                description: the CA certificate file of the Kubernetes API
            k8s_client_cert_file:
                type: string
                description: the client certificate file to connect to the Kubernetes API
            k8s_client_key_file:
                type: string
                description: the client key file to connect to the Kubernetes API
        capabilities:
            host:
                type: tosca.capabilities.Compute
        interfaces:
            Standard:
                operations:
                    create: exit 0
                    delete: exit 0
    openstack.provider:
        derived_from: cloud.provider
        description: The abstract "openstack.provider" node type defines an OpenStack project.
        metadata:
            vintner_normative: 'true'
            vintner_abstract: 'true'
        properties:
            _hosting:
                type: string
                default: openstack
            os_region_name:
                type: string
                description: the region of the OpenStack project
            os_auth_type:
                type: string
                description: the authentication type of the OpenStack project
            os_auth_url:
                type: string
                description: the authentication URL of the OpenStack project
            os_identity_api_version:
                type: string
                description: the identity API version of the OpenStack project
            os_interface:
                type: string
                description: the interface of the OpenStack project
            os_application_credential_id:
                type: string
                description: the application credential ID to authenticate at the OpenStack project
            os_application_credential_secret:
                type: string
                description: the application credential secret to authenticate at the OpenStack project
        interfaces:
            Standard:
                operations:
                    create: exit 0
                    delete: exit 0
    mysql.dbms:
        derived_from: relational.dbms
        description: The "mysql.dbms" node type manages a MySQL DBMS, which is capable of hosting MySQL databases.
        metadata:
            vintner_normative: 'true'
        properties:
            dbms_name:
                type: string
                description: the name of the DBMS
            application_name:
                type: string
                description: the name of the DBMS
                default:
                    eval: .::dbms_name
            dbms_password:
                type: string
                description: the root password of the DBMS
            dbms_ssl_mode:
                type: string
                default: None
                description: the SSL mode of the DBMS
        attributes:
            application_address:
                type: string
                description: the application address of the DBMS
            application_port:
                type: string
                description: the application port of the DBMS
            management_address:
                type: string
                description: the management address of the DBMS
            management_port:
                type: string
                description: the management port of the DBMS
        capabilities:
            host:
                type: tosca.capabilities.Compute
        requirements:
            - host:
                  capability: tosca.capabilities.Compute
                  relationship: tosca.relationships.HostedOn
    mysql.database:
        derived_from: relational.database
        description: The "mysql.database" node type manages a MySQL database, which is hosted on a MySQL and which can be accessed by other components.
        metadata:
            vintner_normative: 'true'
        properties:
            database_name:
                type: string
                description: the name of the database
            database_user:
                type: string
                description: the user of the database
            database_password:
                type: string
                description: the password for the database user
        attributes:
            application_address:
                type: string
                description: the application address of the DBMS
                default:
                    eval: .::.requirements::[.name=host]::.target::application_address
            application_port:
                type: string
                description: the application port of the DBMS
                default:
                    eval: .::.requirements::[.name=host]::.target::application_port
        capabilities:
            database:
                type: tosca.capabilities.Endpoint.Database
        requirements:
            - host:
                  capability: tosca.capabilities.Compute
                  relationship: tosca.relationships.HostedOn
    minio.server:
        derived_from: service.application
        description: The "minio.server" node type manages a MinIO server.
        metadata:
            vintner_normative: 'true'
        properties:
            access_key:
                type: string
                metadata:
                    vintner_name: MINIO_ROOT_USER
                description: the access key of the MinIO server
            secret_key:
                type: string
                metadata:
                    vintner_name: MINIO_ROOT_PASSWORD
                description: the secret key of the MinIO server
        attributes:
            storage_dialect:
                type: string
                default: minio
    redis.server:
        derived_from: cache
        description: The "redis.server" node type manages a Redis server.
        metadata:
            vintner_normative: 'true'
        properties:
            application_protocol:
                type: string
                default: redis
            application_name:
                default:
                    eval: .::cache_name
            application_port:
                default:
                    eval: .::cache_port

    # [OPENTOSCA_VINTNER_GENERATION_MARK]

    ################################################################
    #
    # WARNING: Do not edit! This following content is autogenerated!
    #
    ################################################################

    nodejs.runtime~software.application#apt.package::ansible@*->local.machine:
        derived_from: nodejs.runtime
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: run setup script
                                      ansible.builtin.shell: curl -fsSL {{ ".artifacts::apt_package::script" | eval }} | sudo -E bash -
                                      args:
                                          executable: /bin/bash
                                      when: '".artifacts::apt_package::script" | eval != ""'
                                    - name: add apt key
                                      ansible.builtin.apt_key:
                                          url: '{{ ".artifacts::apt_package::key" | eval }}'
                                          keyring: /usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg
                                          state: present
                                      when: '".artifacts::apt_package::key" | eval != ""'
                                    - name: add apt repository
                                      ansible.builtin.apt_repository:
                                          repo: deb [signed-by=/usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg] {{ ".artifacts::apt_package::source" | eval }}
                                          filename: '{{ ".artifacts::apt_package::repository" | eval }}'
                                          state: present
                                      when: '".artifacts::apt_package::source" | eval != ""'
                                    - name: update apt cache
                                      ansible.builtin.apt:
                                          update_cache: 'yes'
                                    - name: install dependencies
                                      ansible.builtin.apt:
                                          name: '{{ ".artifacts::apt_package::dependencies" | eval | split(",") | map("trim") }}'
                                          state: present
                                      when: '".artifacts::apt_package::dependencies" | eval != ""'
                                    - name: install package
                                      ansible.builtin.apt:
                                          name: '{{ ".artifacts::apt_package::file" | eval }}'
                                          state: present
                                      environment: '{{ ".artifacts::apt_package::env" | eval | split | map("split", "=") | community.general.dict }}'
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
                                    - name: uninstall package
                                      ansible.builtin.apt:
                                          name: '{{ ".artifacts::apt_package::file" | eval }}'
                                          state: absent
    nodejs.runtime~software.application#apt.package::terraform@*->local.machine:
        derived_from: nodejs.runtime
        metadata:
            vintner_generated: 'true'
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            local_file:
                                tmp_create:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Run setup script 
                                        if [[ "{{ ".artifacts::apt_package::script" | eval }}" != "" ]]; then 
                                            curl -fsSL {{ ".artifacts::apt_package::script" | eval }} | sudo -E bash -
                                        fi

                                        # Add apt key
                                        if [[ "{{ ".artifacts::apt_package::key" | eval }}" != "" ]]; then 
                                            curl -1sLf {{ ".artifacts::apt_package::key" | eval }} | gpg --dearmor --yes -o /usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg
                                        fi

                                        # Add apt repository
                                        if [[ "{{ ".artifacts::apt_package::source" | eval }}" != "" ]]; then 
                                            echo "deb [signed-by=/usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg] {{ ".artifacts::apt_package::source" | eval }}" | tee {{ ".artifacts::apt_package::repository" | eval }}
                                        fi

                                        # Update apt cache
                                        apt-get update -y

                                        # Install dependencies
                                        if [[ "{{ ".artifacts::apt_package::dependencies" | eval }}" != "" ]]; then 
                                            apt-get install {{ ".artifacts::apt_package::dependencies" | eval | split(",") | map("trim") }} -y
                                        fi

                                        # Install package
                                        {{ ".artifacts::apt_package::env" | eval }} apt-get install {{ ".artifacts::apt_package::file" | eval }} -y

                                        # Create application directory
                                        mkdir -p {{ SELF.application_directory }}

                                        # Create application environment
                                        cat <<EOF > {{ SELF.application_directory }}/.env
                                        APPLICATION_NAME="{{ SELF.application_name }}"
                                        EOF>>

                                        # Create vintner directory
                                        mkdir -p {{ SELF.application_directory }}/.vintner

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/create.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/create.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/create.sh
                                    filename: /tmp/create-nodejs.runtime.sh
                                tmp_configure:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/configure.sh
                                    filename: /tmp/configure-nodejs.runtime.sh
                                tmp_start:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/start.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/start.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/start.sh
                                    filename: /tmp/start-nodejs.runtime.sh
                                tmp_stop:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/stop.sh
                                    filename: /tmp/stop-nodejs.runtime.sh
                                tmp_delete:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/delete.sh

                                        # Delete application directory
                                        rm -rf "{{ SELF.application_directory }}"

                                        # Uninstall package
                                        apt-get uninstall {{ ".artifacts::apt_package::file" | eval }} -y
                                    filename: /tmp/delete-nodejs.runtime.sh
                            terraform_data:
                                local:
                                    - provisioner:
                                          depends_on:
                                              - local_file.tmp_artifact
                                              - local_file.tmp_create
                                              - local_file.tmp_configure
                                              - local_file.tmp_start
                                              - local_file.tmp_stop
                                              - local_file.tmp_delete
                                          local-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-nodejs.runtime.sh
                                                    - sudo bash /tmp/configure-nodejs.runtime.sh
                                                    - sudo bash /tmp/start-nodejs.runtime.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-nodejs.runtime.sh
                                                    - sudo bash /tmp/delete-nodejs.runtime.sh
                                                when: destroy
    nodejs.runtime~software.application#apt.package::ansible@*->remote.machine:
        derived_from: nodejs.runtime
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: run setup script
                                      ansible.builtin.shell: curl -fsSL {{ ".artifacts::apt_package::script" | eval }} | sudo -E bash -
                                      args:
                                          executable: /bin/bash
                                      when: '".artifacts::apt_package::script" | eval != ""'
                                    - name: add apt key
                                      ansible.builtin.apt_key:
                                          url: '{{ ".artifacts::apt_package::key" | eval }}'
                                          keyring: /usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg
                                          state: present
                                      when: '".artifacts::apt_package::key" | eval != ""'
                                    - name: add apt repository
                                      ansible.builtin.apt_repository:
                                          repo: deb [signed-by=/usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg] {{ ".artifacts::apt_package::source" | eval }}
                                          filename: '{{ ".artifacts::apt_package::repository" | eval }}'
                                          state: present
                                      when: '".artifacts::apt_package::source" | eval != ""'
                                    - name: update apt cache
                                      ansible.builtin.apt:
                                          update_cache: 'yes'
                                    - name: install dependencies
                                      ansible.builtin.apt:
                                          name: '{{ ".artifacts::apt_package::dependencies" | eval | split(",") | map("trim") }}'
                                          state: present
                                      when: '".artifacts::apt_package::dependencies" | eval != ""'
                                    - name: install package
                                      ansible.builtin.apt:
                                          name: '{{ ".artifacts::apt_package::file" | eval }}'
                                          state: present
                                      environment: '{{ ".artifacts::apt_package::env" | eval | split | map("split", "=") | community.general.dict }}'
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
                                    - name: uninstall package
                                      ansible.builtin.apt:
                                          name: '{{ ".artifacts::apt_package::file" | eval }}'
                                          state: absent
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
    nodejs.runtime~software.application#apt.package::terraform@*->remote.machine:
        derived_from: nodejs.runtime
        metadata:
            vintner_generated: 'true'
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            os_ssh_host:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            terraform_data:
                                vm:
                                    - connection:
                                          - host: '{{ SELF.os_ssh_host }}'
                                            private_key: ${file("{{ SELF.os_ssh_key_file }}")}
                                            type: ssh
                                            user: '{{ SELF.os_ssh_user }}'
                                      provisioner:
                                          file:
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Run setup script 
                                                    if [[ "{{ ".artifacts::apt_package::script" | eval }}" != "" ]]; then 
                                                        curl -fsSL {{ ".artifacts::apt_package::script" | eval }} | sudo -E bash -
                                                    fi

                                                    # Add apt key
                                                    if [[ "{{ ".artifacts::apt_package::key" | eval }}" != "" ]]; then 
                                                        curl -1sLf {{ ".artifacts::apt_package::key" | eval }} | gpg --dearmor --yes -o /usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg
                                                    fi

                                                    # Add apt repository
                                                    if [[ "{{ ".artifacts::apt_package::source" | eval }}" != "" ]]; then 
                                                        echo "deb [signed-by=/usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg] {{ ".artifacts::apt_package::source" | eval }}" | tee {{ ".artifacts::apt_package::repository" | eval }}
                                                    fi

                                                    # Update apt cache
                                                    apt-get update -y

                                                    # Install dependencies
                                                    if [[ "{{ ".artifacts::apt_package::dependencies" | eval }}" != "" ]]; then 
                                                        apt-get install {{ ".artifacts::apt_package::dependencies" | eval | split(",") | map("trim") }} -y
                                                    fi

                                                    # Install package
                                                    {{ ".artifacts::apt_package::env" | eval }} apt-get install {{ ".artifacts::apt_package::file" | eval }} -y

                                                    # Create application directory
                                                    mkdir -p {{ SELF.application_directory }}

                                                    # Create application environment
                                                    cat <<EOF > {{ SELF.application_directory }}/.env
                                                    APPLICATION_NAME="{{ SELF.application_name }}"
                                                    EOF>>

                                                    # Create vintner directory
                                                    mkdir -p {{ SELF.application_directory }}/.vintner

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/create.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/create.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/create.sh
                                                destination: /tmp/create-nodejs.runtime.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/configure.sh
                                                destination: /tmp/configure-nodejs.runtime.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/start.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/start.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/start.sh
                                                destination: /tmp/start-nodejs.runtime.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/stop.sh
                                                destination: /tmp/stop-nodejs.runtime.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/delete.sh

                                                    # Delete application directory
                                                    rm -rf "{{ SELF.application_directory }}"

                                                    # Uninstall package
                                                    apt-get uninstall {{ ".artifacts::apt_package::file" | eval }} -y
                                                destination: /tmp/delete-nodejs.runtime.sh
                                          remote-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-nodejs.runtime.sh
                                                    - sudo bash /tmp/configure-nodejs.runtime.sh
                                                    - sudo bash /tmp/start-nodejs.runtime.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-nodejs.runtime.sh
                                                    - sudo bash /tmp/delete-nodejs.runtime.sh
                                                when: destroy
    nodejs.runtime~software.application#tar.archive::ansible@*->local.machine:
        derived_from: nodejs.runtime
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: install operational dependencies
                                      ansible.builtin.apt:
                                          name: unzip
                                          update_cache: 'yes'
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: extract deployment artifact in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          extra_opts: '{{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}'
                                      when: not (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")
                                    - name: extract deployment artifact from URL in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          remote_src: 'yes'
                                          extra_opts: '{{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}'
                                      when: (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")
                                    - name: create vintner directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}/.vintner'
                                          state: directory
                                    - name: create .env file
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.env'
                                          content: APPLICATION_NAME="{{ SELF.application_name }}"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "start" missing
                                      when: SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "stop" missing
                                      when: SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
    nodejs.runtime~software.application#tar.archive::terraform@*->local.machine:
        derived_from: nodejs.runtime
        metadata:
            vintner_generated: 'true'
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            local_file:
                                tmp_artifact:
                                    source: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                    filename: /tmp/artifact-nodejs.runtime
                                    count: '{{ (not (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")) | ternary(1, 0) }}'
                                tmp_create:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Create application directory
                                        mkdir -p {{ SELF.application_directory }}

                                        # Create application environment
                                        cat <<EOF > {{ SELF.application_directory }}/.env
                                        APPLICATION_NAME="{{ SELF.application_name }}"
                                        EOF>>

                                        # Download deployment artifact if required
                                        if [[ "{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}" == http* ]]; then 
                                            wget -O /tmp/artifact-nodejs.runtime {{ ".artifacts::*::[.type=tar.archive]::file" | eval }} 
                                        fi

                                        # Extract deployment artifact
                                        tar -xzf /tmp/artifact-nodejs.runtime -C {{ SELF.application_directory }} {{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}

                                        # Create vintner directory
                                        mkdir -p {{ SELF.application_directory }}/.vintner

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/create.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/create.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/create.sh
                                    filename: /tmp/create-nodejs.runtime.sh
                                tmp_configure:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/configure.sh
                                    filename: /tmp/configure-nodejs.runtime.sh
                                tmp_start:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Assert operation
                                        if [[ "{{ SELF._management_start | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                            echo 'Management operation "start" missing'
                                            exit 1 
                                        fi

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/start.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/start.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/start.sh
                                    filename: /tmp/start-nodejs.runtime.sh
                                tmp_stop:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Assert operation
                                        if [[ "{{ SELF._management_stop | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                            echo 'Management operation "stop" missing'
                                            exit 1 
                                        fi

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/stop.sh
                                    filename: /tmp/stop-nodejs.runtime.sh
                                tmp_delete:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/delete.sh

                                        # Delete application directory
                                        rm -rf "{{ SELF.application_directory }}"
                                    filename: /tmp/delete-nodejs.runtime.sh
                            terraform_data:
                                local:
                                    - depends_on:
                                          - local_file.tmp_artifact
                                          - local_file.tmp_create
                                          - local_file.tmp_configure
                                          - local_file.tmp_start
                                          - local_file.tmp_stop
                                          - local_file.tmp_delete
                                      provisioner:
                                          local-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-nodejs.runtime.sh
                                                    - sudo bash /tmp/configure-nodejs.runtime.sh
                                                    - sudo bash /tmp/start-nodejs.runtime.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-nodejs.runtime.sh
                                                    - sudo bash /tmp/delete-nodejs.runtime.sh
                                                when: destroy
    nodejs.runtime~software.application#tar.archive::ansible@*->remote.machine:
        derived_from: nodejs.runtime
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: extract deployment artifact in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          extra_opts: '{{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}'
                                      when: not (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")
                                    - name: extract deployment artifact from URL in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          remote_src: 'yes'
                                          extra_opts: '{{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}'
                                      when: (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")
                                    - name: create vintner directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}/.vintner'
                                          state: directory
                                    - name: create .env file
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.env'
                                          content: APPLICATION_NAME="{{ SELF.application_name }}"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "start" missing
                                      when: SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "stop" missing
                                      when: SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
    nodejs.runtime~software.application#tar.archive::terraform@*->remote.machine:
        derived_from: nodejs.runtime
        metadata:
            vintner_generated: 'true'
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            os_ssh_host:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            terraform_data:
                                vm:
                                    - connection:
                                          - host: '{{ SELF.os_ssh_host }}'
                                            private_key: ${file("{{ SELF.os_ssh_key_file }}")}
                                            type: ssh
                                            user: '{{ SELF.os_ssh_user }}'
                                      provisioner:
                                          file:
                                              - source: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                                destination: /tmp/artifact-nodejs.runtime
                                                count: '{{ (not (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")) | ternary(1, 0) }}'
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Create application directory
                                                    mkdir -p {{ SELF.application_directory }}

                                                    # Create application environment
                                                    cat <<EOF > {{ SELF.application_directory }}/.env
                                                    APPLICATION_NAME="{{ SELF.application_name }}"
                                                    EOF>>

                                                    # Download deployment artifact if required
                                                    if [[ "{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}" == http* ]]; then 
                                                        wget -O /tmp/artifact-nodejs.runtime {{ ".artifacts::*::[.type=tar.archive]::file" | eval }} 
                                                    fi

                                                    # Extract deployment artifact
                                                    tar -xzf /tmp/artifact-nodejs.runtime -C {{ SELF.application_directory }} {{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}

                                                    # Create vintner directory
                                                    mkdir -p {{ SELF.application_directory }}/.vintner

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/create.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/create.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/create.sh
                                                destination: /tmp/create-nodejs.runtime.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/configure.sh
                                                destination: /tmp/configure-nodejs.runtime.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Assert operation
                                                    if [[ "{{ SELF._management_start | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                                        echo 'Management operation "start" missing'
                                                        exit 1 
                                                    fi

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/start.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/start.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/start.sh
                                                destination: /tmp/start-nodejs.runtime.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Assert operation
                                                    if [[ "{{ SELF._management_stop | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                                        echo 'Management operation "stop" missing'
                                                        exit 1 
                                                    fi

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/stop.sh
                                                destination: /tmp/stop-nodejs.runtime.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/delete.sh

                                                    # Delete application directory
                                                    rm -rf "{{ SELF.application_directory }}"
                                                destination: /tmp/delete-nodejs.runtime.sh
                                          remote-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-nodejs.runtime.sh
                                                    - sudo bash /tmp/configure-nodejs.runtime.sh
                                                    - sudo bash /tmp/start-nodejs.runtime.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-nodejs.runtime.sh
                                                    - sudo bash /tmp/delete-nodejs.runtime.sh
                                                when: destroy
    nodejs.runtime~software.application#zip.archive::ansible@*->local.machine:
        derived_from: nodejs.runtime
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: install operational dependencies
                                      ansible.builtin.apt:
                                          name: unzip
                                          update_cache: 'yes'
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: extract deployment artifact in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          extra_opts: '{{ ".artifacts::*::[.type=zip.archive]::extra_opts" | eval | map_value }}'
                                      when: not (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")
                                    - name: extract deployment artifact from URL in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          remote_src: 'yes'
                                          extra_opts: '{{ ".artifacts::*::[.type=zip.archive]::extra_opts" | eval | map_value }}'
                                      when: (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")
                                    - name: create vintner directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}/.vintner'
                                          state: directory
                                    - name: create .env file
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.env'
                                          content: APPLICATION_NAME="{{ SELF.application_name }}"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "start" missing
                                      when: SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "stop" missing
                                      when: SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
    nodejs.runtime~software.application#zip.archive::terraform@*->local.machine:
        derived_from: nodejs.runtime
        metadata:
            vintner_generated: 'true'
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            local_file:
                                tmp_artifact:
                                    source: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                    filename: /tmp/artifact-nodejs.runtime
                                    count: '{{ (not (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")) | ternary(1, 0) }}'
                                tmp_create:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Create application directory
                                        mkdir -p {{ SELF.application_directory }}

                                        # Create application environment
                                        cat <<EOF > {{ SELF.application_directory }}/.env
                                        APPLICATION_NAME="{{ SELF.application_name }}"
                                        EOF>>

                                        # Download deployment artifact if required
                                        if [[ "{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}" == http* ]]; then 
                                            wget -O /tmp/artifact-nodejs.runtime {{ ".artifacts::*::[.type=zip.archive]::file" | eval }} 
                                        fi

                                        # Extract deployment artifact
                                        unzip /tmp/artifact-nodejs.runtime -d {{ SELF.application_directory }} {{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}

                                        # Create vintner directory
                                        mkdir -p {{ SELF.application_directory }}/.vintner

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/create.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/create.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/create.sh
                                    filename: /tmp/create-nodejs.runtime.sh
                                tmp_configure:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/configure.sh
                                    filename: /tmp/configure-nodejs.runtime.sh
                                tmp_start:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Assert operation
                                        if [[ "{{ SELF._management_start | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                            echo 'Management operation "start" missing'
                                            exit 1 
                                        fi

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/start.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/start.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/start.sh
                                    filename: /tmp/start-nodejs.runtime.sh
                                tmp_stop:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Assert operation
                                        if [[ "{{ SELF._management_stop | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                            echo 'Management operation "stop" missing'
                                            exit 1 
                                        fi

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/stop.sh
                                    filename: /tmp/stop-nodejs.runtime.sh
                                tmp_delete:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/delete.sh

                                        # Delete application directory
                                        rm -rf "{{ SELF.application_directory }}"
                                    filename: /tmp/delete-nodejs.runtime.sh
                            terraform_data:
                                local:
                                    - depends_on:
                                          - local_file.tmp_artifact
                                          - local_file.tmp_create
                                          - local_file.tmp_configure
                                          - local_file.tmp_start
                                          - local_file.tmp_stop
                                          - local_file.tmp_delete
                                      provisioner:
                                          local-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-nodejs.runtime.sh
                                                    - sudo bash /tmp/configure-nodejs.runtime.sh
                                                    - sudo bash /tmp/start-nodejs.runtime.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-nodejs.runtime.sh
                                                    - sudo bash /tmp/delete-nodejs.runtime.sh
                                                when: destroy
    nodejs.runtime~software.application#zip.archive::ansible@*->remote.machine:
        derived_from: nodejs.runtime
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: install operational dependencies
                                      ansible.builtin.apt:
                                          name: unzip
                                          update_cache: 'yes'
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: extract deployment artifact in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          extra_opts: '{{ ".artifacts::*::[.type=zip.archive]::extra_opts" | eval | map_value }}'
                                      when: not (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")
                                    - name: extract deployment artifact from URL in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          remote_src: 'yes'
                                          extra_opts: '{{ ".artifacts::*::[.type=zip.archive]::extra_opts" | eval | map_value }}'
                                      when: (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")
                                    - name: create vintner directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}/.vintner'
                                          state: directory
                                    - name: create .env file
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.env'
                                          content: APPLICATION_NAME="{{ SELF.application_name }}"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "start" missing
                                      when: SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "stop" missing
                                      when: SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
    nodejs.runtime~software.application#zip.archive::terraform@*->remote.machine:
        derived_from: nodejs.runtime
        metadata:
            vintner_generated: 'true'
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            os_ssh_host:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            terraform_data:
                                vm:
                                    - connection:
                                          - host: '{{ SELF.os_ssh_host }}'
                                            private_key: ${file("{{ SELF.os_ssh_key_file }}")}
                                            type: ssh
                                            user: '{{ SELF.os_ssh_user }}'
                                      provisioner:
                                          file:
                                              - source: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                                destination: /tmp/artifact-nodejs.runtime
                                                count: '{{ (not (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")) | ternary(1, 0) }}'
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Create application directory
                                                    mkdir -p {{ SELF.application_directory }}

                                                    # Create application environment
                                                    cat <<EOF > {{ SELF.application_directory }}/.env
                                                    APPLICATION_NAME="{{ SELF.application_name }}"
                                                    EOF>>

                                                    # Download deployment artifact if required
                                                    if [[ "{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}" == http* ]]; then 
                                                        wget -O /tmp/artifact-nodejs.runtime {{ ".artifacts::*::[.type=zip.archive]::file" | eval }} 
                                                    fi

                                                    # Extract deployment artifact
                                                    unzip /tmp/artifact-nodejs.runtime -d {{ SELF.application_directory }} {{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}

                                                    # Create vintner directory
                                                    mkdir -p {{ SELF.application_directory }}/.vintner

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/create.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/create.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/create.sh
                                                destination: /tmp/create-nodejs.runtime.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/configure.sh
                                                destination: /tmp/configure-nodejs.runtime.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Assert operation
                                                    if [[ "{{ SELF._management_start | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                                        echo 'Management operation "start" missing'
                                                        exit 1 
                                                    fi

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/start.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/start.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/start.sh
                                                destination: /tmp/start-nodejs.runtime.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Assert operation
                                                    if [[ "{{ SELF._management_stop | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                                        echo 'Management operation "stop" missing'
                                                        exit 1 
                                                    fi

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/stop.sh
                                                destination: /tmp/stop-nodejs.runtime.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/delete.sh

                                                    # Delete application directory
                                                    rm -rf "{{ SELF.application_directory }}"
                                                destination: /tmp/delete-nodejs.runtime.sh
                                          remote-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-nodejs.runtime.sh
                                                    - sudo bash /tmp/configure-nodejs.runtime.sh
                                                    - sudo bash /tmp/start-nodejs.runtime.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-nodejs.runtime.sh
                                                    - sudo bash /tmp/delete-nodejs.runtime.sh
                                                when: destroy
    python.runtime~software.application#apt.package::ansible@*->local.machine:
        derived_from: python.runtime
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: run setup script
                                      ansible.builtin.shell: curl -fsSL {{ ".artifacts::apt_package::script" | eval }} | sudo -E bash -
                                      args:
                                          executable: /bin/bash
                                      when: '".artifacts::apt_package::script" | eval != ""'
                                    - name: add apt key
                                      ansible.builtin.apt_key:
                                          url: '{{ ".artifacts::apt_package::key" | eval }}'
                                          keyring: /usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg
                                          state: present
                                      when: '".artifacts::apt_package::key" | eval != ""'
                                    - name: add apt repository
                                      ansible.builtin.apt_repository:
                                          repo: deb [signed-by=/usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg] {{ ".artifacts::apt_package::source" | eval }}
                                          filename: '{{ ".artifacts::apt_package::repository" | eval }}'
                                          state: present
                                      when: '".artifacts::apt_package::source" | eval != ""'
                                    - name: update apt cache
                                      ansible.builtin.apt:
                                          update_cache: 'yes'
                                    - name: install dependencies
                                      ansible.builtin.apt:
                                          name: '{{ ".artifacts::apt_package::dependencies" | eval | split(",") | map("trim") }}'
                                          state: present
                                      when: '".artifacts::apt_package::dependencies" | eval != ""'
                                    - name: install package
                                      ansible.builtin.apt:
                                          name: '{{ ".artifacts::apt_package::file" | eval }}'
                                          state: present
                                      environment: '{{ ".artifacts::apt_package::env" | eval | split | map("split", "=") | community.general.dict }}'
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
                                    - name: uninstall package
                                      ansible.builtin.apt:
                                          name: '{{ ".artifacts::apt_package::file" | eval }}'
                                          state: absent
    python.runtime~software.application#apt.package::terraform@*->local.machine:
        derived_from: python.runtime
        metadata:
            vintner_generated: 'true'
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            local_file:
                                tmp_create:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Run setup script 
                                        if [[ "{{ ".artifacts::apt_package::script" | eval }}" != "" ]]; then 
                                            curl -fsSL {{ ".artifacts::apt_package::script" | eval }} | sudo -E bash -
                                        fi

                                        # Add apt key
                                        if [[ "{{ ".artifacts::apt_package::key" | eval }}" != "" ]]; then 
                                            curl -1sLf {{ ".artifacts::apt_package::key" | eval }} | gpg --dearmor --yes -o /usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg
                                        fi

                                        # Add apt repository
                                        if [[ "{{ ".artifacts::apt_package::source" | eval }}" != "" ]]; then 
                                            echo "deb [signed-by=/usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg] {{ ".artifacts::apt_package::source" | eval }}" | tee {{ ".artifacts::apt_package::repository" | eval }}
                                        fi

                                        # Update apt cache
                                        apt-get update -y

                                        # Install dependencies
                                        if [[ "{{ ".artifacts::apt_package::dependencies" | eval }}" != "" ]]; then 
                                            apt-get install {{ ".artifacts::apt_package::dependencies" | eval | split(",") | map("trim") }} -y
                                        fi

                                        # Install package
                                        {{ ".artifacts::apt_package::env" | eval }} apt-get install {{ ".artifacts::apt_package::file" | eval }} -y

                                        # Create application directory
                                        mkdir -p {{ SELF.application_directory }}

                                        # Create application environment
                                        cat <<EOF > {{ SELF.application_directory }}/.env

                                        EOF>>

                                        # Create vintner directory
                                        mkdir -p {{ SELF.application_directory }}/.vintner

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/create.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/create.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/create.sh
                                    filename: /tmp/create-python.runtime.sh
                                tmp_configure:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/configure.sh
                                    filename: /tmp/configure-python.runtime.sh
                                tmp_start:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/start.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/start.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/start.sh
                                    filename: /tmp/start-python.runtime.sh
                                tmp_stop:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/stop.sh
                                    filename: /tmp/stop-python.runtime.sh
                                tmp_delete:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/delete.sh

                                        # Delete application directory
                                        rm -rf "{{ SELF.application_directory }}"

                                        # Uninstall package
                                        apt-get uninstall {{ ".artifacts::apt_package::file" | eval }} -y
                                    filename: /tmp/delete-python.runtime.sh
                            terraform_data:
                                local:
                                    - provisioner:
                                          depends_on:
                                              - local_file.tmp_artifact
                                              - local_file.tmp_create
                                              - local_file.tmp_configure
                                              - local_file.tmp_start
                                              - local_file.tmp_stop
                                              - local_file.tmp_delete
                                          local-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-python.runtime.sh
                                                    - sudo bash /tmp/configure-python.runtime.sh
                                                    - sudo bash /tmp/start-python.runtime.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-python.runtime.sh
                                                    - sudo bash /tmp/delete-python.runtime.sh
                                                when: destroy
    python.runtime~software.application#apt.package::ansible@*->remote.machine:
        derived_from: python.runtime
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: run setup script
                                      ansible.builtin.shell: curl -fsSL {{ ".artifacts::apt_package::script" | eval }} | sudo -E bash -
                                      args:
                                          executable: /bin/bash
                                      when: '".artifacts::apt_package::script" | eval != ""'
                                    - name: add apt key
                                      ansible.builtin.apt_key:
                                          url: '{{ ".artifacts::apt_package::key" | eval }}'
                                          keyring: /usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg
                                          state: present
                                      when: '".artifacts::apt_package::key" | eval != ""'
                                    - name: add apt repository
                                      ansible.builtin.apt_repository:
                                          repo: deb [signed-by=/usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg] {{ ".artifacts::apt_package::source" | eval }}
                                          filename: '{{ ".artifacts::apt_package::repository" | eval }}'
                                          state: present
                                      when: '".artifacts::apt_package::source" | eval != ""'
                                    - name: update apt cache
                                      ansible.builtin.apt:
                                          update_cache: 'yes'
                                    - name: install dependencies
                                      ansible.builtin.apt:
                                          name: '{{ ".artifacts::apt_package::dependencies" | eval | split(",") | map("trim") }}'
                                          state: present
                                      when: '".artifacts::apt_package::dependencies" | eval != ""'
                                    - name: install package
                                      ansible.builtin.apt:
                                          name: '{{ ".artifacts::apt_package::file" | eval }}'
                                          state: present
                                      environment: '{{ ".artifacts::apt_package::env" | eval | split | map("split", "=") | community.general.dict }}'
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
                                    - name: uninstall package
                                      ansible.builtin.apt:
                                          name: '{{ ".artifacts::apt_package::file" | eval }}'
                                          state: absent
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
    python.runtime~software.application#apt.package::terraform@*->remote.machine:
        derived_from: python.runtime
        metadata:
            vintner_generated: 'true'
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            os_ssh_host:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            terraform_data:
                                vm:
                                    - connection:
                                          - host: '{{ SELF.os_ssh_host }}'
                                            private_key: ${file("{{ SELF.os_ssh_key_file }}")}
                                            type: ssh
                                            user: '{{ SELF.os_ssh_user }}'
                                      provisioner:
                                          file:
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Run setup script 
                                                    if [[ "{{ ".artifacts::apt_package::script" | eval }}" != "" ]]; then 
                                                        curl -fsSL {{ ".artifacts::apt_package::script" | eval }} | sudo -E bash -
                                                    fi

                                                    # Add apt key
                                                    if [[ "{{ ".artifacts::apt_package::key" | eval }}" != "" ]]; then 
                                                        curl -1sLf {{ ".artifacts::apt_package::key" | eval }} | gpg --dearmor --yes -o /usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg
                                                    fi

                                                    # Add apt repository
                                                    if [[ "{{ ".artifacts::apt_package::source" | eval }}" != "" ]]; then 
                                                        echo "deb [signed-by=/usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg] {{ ".artifacts::apt_package::source" | eval }}" | tee {{ ".artifacts::apt_package::repository" | eval }}
                                                    fi

                                                    # Update apt cache
                                                    apt-get update -y

                                                    # Install dependencies
                                                    if [[ "{{ ".artifacts::apt_package::dependencies" | eval }}" != "" ]]; then 
                                                        apt-get install {{ ".artifacts::apt_package::dependencies" | eval | split(",") | map("trim") }} -y
                                                    fi

                                                    # Install package
                                                    {{ ".artifacts::apt_package::env" | eval }} apt-get install {{ ".artifacts::apt_package::file" | eval }} -y

                                                    # Create application directory
                                                    mkdir -p {{ SELF.application_directory }}

                                                    # Create application environment
                                                    cat <<EOF > {{ SELF.application_directory }}/.env

                                                    EOF>>

                                                    # Create vintner directory
                                                    mkdir -p {{ SELF.application_directory }}/.vintner

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/create.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/create.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/create.sh
                                                destination: /tmp/create-python.runtime.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/configure.sh
                                                destination: /tmp/configure-python.runtime.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/start.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/start.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/start.sh
                                                destination: /tmp/start-python.runtime.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/stop.sh
                                                destination: /tmp/stop-python.runtime.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/delete.sh

                                                    # Delete application directory
                                                    rm -rf "{{ SELF.application_directory }}"

                                                    # Uninstall package
                                                    apt-get uninstall {{ ".artifacts::apt_package::file" | eval }} -y
                                                destination: /tmp/delete-python.runtime.sh
                                          remote-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-python.runtime.sh
                                                    - sudo bash /tmp/configure-python.runtime.sh
                                                    - sudo bash /tmp/start-python.runtime.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-python.runtime.sh
                                                    - sudo bash /tmp/delete-python.runtime.sh
                                                when: destroy
    python.runtime~software.application#tar.archive::ansible@*->local.machine:
        derived_from: python.runtime
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: install operational dependencies
                                      ansible.builtin.apt:
                                          name: unzip
                                          update_cache: 'yes'
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: extract deployment artifact in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          extra_opts: '{{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}'
                                      when: not (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")
                                    - name: extract deployment artifact from URL in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          remote_src: 'yes'
                                          extra_opts: '{{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}'
                                      when: (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")
                                    - name: create vintner directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}/.vintner'
                                          state: directory
                                    - name: create .env file
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.env'
                                          content: ''
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "start" missing
                                      when: SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "stop" missing
                                      when: SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
    python.runtime~software.application#tar.archive::terraform@*->local.machine:
        derived_from: python.runtime
        metadata:
            vintner_generated: 'true'
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            local_file:
                                tmp_artifact:
                                    source: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                    filename: /tmp/artifact-python.runtime
                                    count: '{{ (not (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")) | ternary(1, 0) }}'
                                tmp_create:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Create application directory
                                        mkdir -p {{ SELF.application_directory }}

                                        # Create application environment
                                        cat <<EOF > {{ SELF.application_directory }}/.env

                                        EOF>>

                                        # Download deployment artifact if required
                                        if [[ "{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}" == http* ]]; then 
                                            wget -O /tmp/artifact-python.runtime {{ ".artifacts::*::[.type=tar.archive]::file" | eval }} 
                                        fi

                                        # Extract deployment artifact
                                        tar -xzf /tmp/artifact-python.runtime -C {{ SELF.application_directory }} {{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}

                                        # Create vintner directory
                                        mkdir -p {{ SELF.application_directory }}/.vintner

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/create.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/create.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/create.sh
                                    filename: /tmp/create-python.runtime.sh
                                tmp_configure:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/configure.sh
                                    filename: /tmp/configure-python.runtime.sh
                                tmp_start:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Assert operation
                                        if [[ "{{ SELF._management_start | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                            echo 'Management operation "start" missing'
                                            exit 1 
                                        fi

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/start.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/start.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/start.sh
                                    filename: /tmp/start-python.runtime.sh
                                tmp_stop:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Assert operation
                                        if [[ "{{ SELF._management_stop | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                            echo 'Management operation "stop" missing'
                                            exit 1 
                                        fi

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/stop.sh
                                    filename: /tmp/stop-python.runtime.sh
                                tmp_delete:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/delete.sh

                                        # Delete application directory
                                        rm -rf "{{ SELF.application_directory }}"
                                    filename: /tmp/delete-python.runtime.sh
                            terraform_data:
                                local:
                                    - depends_on:
                                          - local_file.tmp_artifact
                                          - local_file.tmp_create
                                          - local_file.tmp_configure
                                          - local_file.tmp_start
                                          - local_file.tmp_stop
                                          - local_file.tmp_delete
                                      provisioner:
                                          local-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-python.runtime.sh
                                                    - sudo bash /tmp/configure-python.runtime.sh
                                                    - sudo bash /tmp/start-python.runtime.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-python.runtime.sh
                                                    - sudo bash /tmp/delete-python.runtime.sh
                                                when: destroy
    python.runtime~software.application#tar.archive::ansible@*->remote.machine:
        derived_from: python.runtime
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: extract deployment artifact in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          extra_opts: '{{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}'
                                      when: not (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")
                                    - name: extract deployment artifact from URL in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          remote_src: 'yes'
                                          extra_opts: '{{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}'
                                      when: (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")
                                    - name: create vintner directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}/.vintner'
                                          state: directory
                                    - name: create .env file
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.env'
                                          content: ''
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "start" missing
                                      when: SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "stop" missing
                                      when: SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
    python.runtime~software.application#tar.archive::terraform@*->remote.machine:
        derived_from: python.runtime
        metadata:
            vintner_generated: 'true'
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            os_ssh_host:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            terraform_data:
                                vm:
                                    - connection:
                                          - host: '{{ SELF.os_ssh_host }}'
                                            private_key: ${file("{{ SELF.os_ssh_key_file }}")}
                                            type: ssh
                                            user: '{{ SELF.os_ssh_user }}'
                                      provisioner:
                                          file:
                                              - source: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                                destination: /tmp/artifact-python.runtime
                                                count: '{{ (not (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")) | ternary(1, 0) }}'
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Create application directory
                                                    mkdir -p {{ SELF.application_directory }}

                                                    # Create application environment
                                                    cat <<EOF > {{ SELF.application_directory }}/.env

                                                    EOF>>

                                                    # Download deployment artifact if required
                                                    if [[ "{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}" == http* ]]; then 
                                                        wget -O /tmp/artifact-python.runtime {{ ".artifacts::*::[.type=tar.archive]::file" | eval }} 
                                                    fi

                                                    # Extract deployment artifact
                                                    tar -xzf /tmp/artifact-python.runtime -C {{ SELF.application_directory }} {{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}

                                                    # Create vintner directory
                                                    mkdir -p {{ SELF.application_directory }}/.vintner

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/create.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/create.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/create.sh
                                                destination: /tmp/create-python.runtime.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/configure.sh
                                                destination: /tmp/configure-python.runtime.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Assert operation
                                                    if [[ "{{ SELF._management_start | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                                        echo 'Management operation "start" missing'
                                                        exit 1 
                                                    fi

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/start.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/start.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/start.sh
                                                destination: /tmp/start-python.runtime.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Assert operation
                                                    if [[ "{{ SELF._management_stop | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                                        echo 'Management operation "stop" missing'
                                                        exit 1 
                                                    fi

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/stop.sh
                                                destination: /tmp/stop-python.runtime.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/delete.sh

                                                    # Delete application directory
                                                    rm -rf "{{ SELF.application_directory }}"
                                                destination: /tmp/delete-python.runtime.sh
                                          remote-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-python.runtime.sh
                                                    - sudo bash /tmp/configure-python.runtime.sh
                                                    - sudo bash /tmp/start-python.runtime.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-python.runtime.sh
                                                    - sudo bash /tmp/delete-python.runtime.sh
                                                when: destroy
    python.runtime~software.application#zip.archive::ansible@*->local.machine:
        derived_from: python.runtime
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: install operational dependencies
                                      ansible.builtin.apt:
                                          name: unzip
                                          update_cache: 'yes'
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: extract deployment artifact in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          extra_opts: '{{ ".artifacts::*::[.type=zip.archive]::extra_opts" | eval | map_value }}'
                                      when: not (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")
                                    - name: extract deployment artifact from URL in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          remote_src: 'yes'
                                          extra_opts: '{{ ".artifacts::*::[.type=zip.archive]::extra_opts" | eval | map_value }}'
                                      when: (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")
                                    - name: create vintner directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}/.vintner'
                                          state: directory
                                    - name: create .env file
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.env'
                                          content: ''
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "start" missing
                                      when: SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "stop" missing
                                      when: SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
    python.runtime~software.application#zip.archive::terraform@*->local.machine:
        derived_from: python.runtime
        metadata:
            vintner_generated: 'true'
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            local_file:
                                tmp_artifact:
                                    source: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                    filename: /tmp/artifact-python.runtime
                                    count: '{{ (not (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")) | ternary(1, 0) }}'
                                tmp_create:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Create application directory
                                        mkdir -p {{ SELF.application_directory }}

                                        # Create application environment
                                        cat <<EOF > {{ SELF.application_directory }}/.env

                                        EOF>>

                                        # Download deployment artifact if required
                                        if [[ "{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}" == http* ]]; then 
                                            wget -O /tmp/artifact-python.runtime {{ ".artifacts::*::[.type=zip.archive]::file" | eval }} 
                                        fi

                                        # Extract deployment artifact
                                        unzip /tmp/artifact-python.runtime -d {{ SELF.application_directory }} {{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}

                                        # Create vintner directory
                                        mkdir -p {{ SELF.application_directory }}/.vintner

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/create.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/create.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/create.sh
                                    filename: /tmp/create-python.runtime.sh
                                tmp_configure:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/configure.sh
                                    filename: /tmp/configure-python.runtime.sh
                                tmp_start:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Assert operation
                                        if [[ "{{ SELF._management_start | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                            echo 'Management operation "start" missing'
                                            exit 1 
                                        fi

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/start.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/start.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/start.sh
                                    filename: /tmp/start-python.runtime.sh
                                tmp_stop:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Assert operation
                                        if [[ "{{ SELF._management_stop | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                            echo 'Management operation "stop" missing'
                                            exit 1 
                                        fi

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/stop.sh
                                    filename: /tmp/stop-python.runtime.sh
                                tmp_delete:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/delete.sh

                                        # Delete application directory
                                        rm -rf "{{ SELF.application_directory }}"
                                    filename: /tmp/delete-python.runtime.sh
                            terraform_data:
                                local:
                                    - depends_on:
                                          - local_file.tmp_artifact
                                          - local_file.tmp_create
                                          - local_file.tmp_configure
                                          - local_file.tmp_start
                                          - local_file.tmp_stop
                                          - local_file.tmp_delete
                                      provisioner:
                                          local-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-python.runtime.sh
                                                    - sudo bash /tmp/configure-python.runtime.sh
                                                    - sudo bash /tmp/start-python.runtime.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-python.runtime.sh
                                                    - sudo bash /tmp/delete-python.runtime.sh
                                                when: destroy
    python.runtime~software.application#zip.archive::ansible@*->remote.machine:
        derived_from: python.runtime
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: install operational dependencies
                                      ansible.builtin.apt:
                                          name: unzip
                                          update_cache: 'yes'
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: extract deployment artifact in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          extra_opts: '{{ ".artifacts::*::[.type=zip.archive]::extra_opts" | eval | map_value }}'
                                      when: not (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")
                                    - name: extract deployment artifact from URL in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          remote_src: 'yes'
                                          extra_opts: '{{ ".artifacts::*::[.type=zip.archive]::extra_opts" | eval | map_value }}'
                                      when: (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")
                                    - name: create vintner directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}/.vintner'
                                          state: directory
                                    - name: create .env file
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.env'
                                          content: ''
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "start" missing
                                      when: SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "stop" missing
                                      when: SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
    python.runtime~software.application#zip.archive::terraform@*->remote.machine:
        derived_from: python.runtime
        metadata:
            vintner_generated: 'true'
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            os_ssh_host:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            terraform_data:
                                vm:
                                    - connection:
                                          - host: '{{ SELF.os_ssh_host }}'
                                            private_key: ${file("{{ SELF.os_ssh_key_file }}")}
                                            type: ssh
                                            user: '{{ SELF.os_ssh_user }}'
                                      provisioner:
                                          file:
                                              - source: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                                destination: /tmp/artifact-python.runtime
                                                count: '{{ (not (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")) | ternary(1, 0) }}'
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Create application directory
                                                    mkdir -p {{ SELF.application_directory }}

                                                    # Create application environment
                                                    cat <<EOF > {{ SELF.application_directory }}/.env

                                                    EOF>>

                                                    # Download deployment artifact if required
                                                    if [[ "{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}" == http* ]]; then 
                                                        wget -O /tmp/artifact-python.runtime {{ ".artifacts::*::[.type=zip.archive]::file" | eval }} 
                                                    fi

                                                    # Extract deployment artifact
                                                    unzip /tmp/artifact-python.runtime -d {{ SELF.application_directory }} {{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}

                                                    # Create vintner directory
                                                    mkdir -p {{ SELF.application_directory }}/.vintner

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/create.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/create.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/create.sh
                                                destination: /tmp/create-python.runtime.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/configure.sh
                                                destination: /tmp/configure-python.runtime.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Assert operation
                                                    if [[ "{{ SELF._management_start | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                                        echo 'Management operation "start" missing'
                                                        exit 1 
                                                    fi

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/start.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/start.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/start.sh
                                                destination: /tmp/start-python.runtime.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Assert operation
                                                    if [[ "{{ SELF._management_stop | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                                        echo 'Management operation "stop" missing'
                                                        exit 1 
                                                    fi

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/stop.sh
                                                destination: /tmp/stop-python.runtime.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/delete.sh

                                                    # Delete application directory
                                                    rm -rf "{{ SELF.application_directory }}"
                                                destination: /tmp/delete-python.runtime.sh
                                          remote-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-python.runtime.sh
                                                    - sudo bash /tmp/configure-python.runtime.sh
                                                    - sudo bash /tmp/start-python.runtime.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-python.runtime.sh
                                                    - sudo bash /tmp/delete-python.runtime.sh
                                                when: destroy
    java.runtime~software.application#apt.package::ansible@*->local.machine:
        derived_from: java.runtime
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: run setup script
                                      ansible.builtin.shell: curl -fsSL {{ ".artifacts::apt_package::script" | eval }} | sudo -E bash -
                                      args:
                                          executable: /bin/bash
                                      when: '".artifacts::apt_package::script" | eval != ""'
                                    - name: add apt key
                                      ansible.builtin.apt_key:
                                          url: '{{ ".artifacts::apt_package::key" | eval }}'
                                          keyring: /usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg
                                          state: present
                                      when: '".artifacts::apt_package::key" | eval != ""'
                                    - name: add apt repository
                                      ansible.builtin.apt_repository:
                                          repo: deb [signed-by=/usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg] {{ ".artifacts::apt_package::source" | eval }}
                                          filename: '{{ ".artifacts::apt_package::repository" | eval }}'
                                          state: present
                                      when: '".artifacts::apt_package::source" | eval != ""'
                                    - name: update apt cache
                                      ansible.builtin.apt:
                                          update_cache: 'yes'
                                    - name: install dependencies
                                      ansible.builtin.apt:
                                          name: '{{ ".artifacts::apt_package::dependencies" | eval | split(",") | map("trim") }}'
                                          state: present
                                      when: '".artifacts::apt_package::dependencies" | eval != ""'
                                    - name: install package
                                      ansible.builtin.apt:
                                          name: '{{ ".artifacts::apt_package::file" | eval }}'
                                          state: present
                                      environment: '{{ ".artifacts::apt_package::env" | eval | split | map("split", "=") | community.general.dict }}'
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
                                    - name: uninstall package
                                      ansible.builtin.apt:
                                          name: '{{ ".artifacts::apt_package::file" | eval }}'
                                          state: absent
    java.runtime~software.application#apt.package::terraform@*->local.machine:
        derived_from: java.runtime
        metadata:
            vintner_generated: 'true'
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            local_file:
                                tmp_create:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Run setup script 
                                        if [[ "{{ ".artifacts::apt_package::script" | eval }}" != "" ]]; then 
                                            curl -fsSL {{ ".artifacts::apt_package::script" | eval }} | sudo -E bash -
                                        fi

                                        # Add apt key
                                        if [[ "{{ ".artifacts::apt_package::key" | eval }}" != "" ]]; then 
                                            curl -1sLf {{ ".artifacts::apt_package::key" | eval }} | gpg --dearmor --yes -o /usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg
                                        fi

                                        # Add apt repository
                                        if [[ "{{ ".artifacts::apt_package::source" | eval }}" != "" ]]; then 
                                            echo "deb [signed-by=/usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg] {{ ".artifacts::apt_package::source" | eval }}" | tee {{ ".artifacts::apt_package::repository" | eval }}
                                        fi

                                        # Update apt cache
                                        apt-get update -y

                                        # Install dependencies
                                        if [[ "{{ ".artifacts::apt_package::dependencies" | eval }}" != "" ]]; then 
                                            apt-get install {{ ".artifacts::apt_package::dependencies" | eval | split(",") | map("trim") }} -y
                                        fi

                                        # Install package
                                        {{ ".artifacts::apt_package::env" | eval }} apt-get install {{ ".artifacts::apt_package::file" | eval }} -y

                                        # Create application directory
                                        mkdir -p {{ SELF.application_directory }}

                                        # Create application environment
                                        cat <<EOF > {{ SELF.application_directory }}/.env
                                        APPLICATION_NAME="{{ SELF.application_name }}"
                                        EOF>>

                                        # Create vintner directory
                                        mkdir -p {{ SELF.application_directory }}/.vintner

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/create.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/create.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/create.sh
                                    filename: /tmp/create-java.runtime.sh
                                tmp_configure:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/configure.sh
                                    filename: /tmp/configure-java.runtime.sh
                                tmp_start:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/start.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/start.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/start.sh
                                    filename: /tmp/start-java.runtime.sh
                                tmp_stop:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/stop.sh
                                    filename: /tmp/stop-java.runtime.sh
                                tmp_delete:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/delete.sh

                                        # Delete application directory
                                        rm -rf "{{ SELF.application_directory }}"

                                        # Uninstall package
                                        apt-get uninstall {{ ".artifacts::apt_package::file" | eval }} -y
                                    filename: /tmp/delete-java.runtime.sh
                            terraform_data:
                                local:
                                    - provisioner:
                                          depends_on:
                                              - local_file.tmp_artifact
                                              - local_file.tmp_create
                                              - local_file.tmp_configure
                                              - local_file.tmp_start
                                              - local_file.tmp_stop
                                              - local_file.tmp_delete
                                          local-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-java.runtime.sh
                                                    - sudo bash /tmp/configure-java.runtime.sh
                                                    - sudo bash /tmp/start-java.runtime.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-java.runtime.sh
                                                    - sudo bash /tmp/delete-java.runtime.sh
                                                when: destroy
    java.runtime~software.application#apt.package::ansible@*->remote.machine:
        derived_from: java.runtime
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: run setup script
                                      ansible.builtin.shell: curl -fsSL {{ ".artifacts::apt_package::script" | eval }} | sudo -E bash -
                                      args:
                                          executable: /bin/bash
                                      when: '".artifacts::apt_package::script" | eval != ""'
                                    - name: add apt key
                                      ansible.builtin.apt_key:
                                          url: '{{ ".artifacts::apt_package::key" | eval }}'
                                          keyring: /usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg
                                          state: present
                                      when: '".artifacts::apt_package::key" | eval != ""'
                                    - name: add apt repository
                                      ansible.builtin.apt_repository:
                                          repo: deb [signed-by=/usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg] {{ ".artifacts::apt_package::source" | eval }}
                                          filename: '{{ ".artifacts::apt_package::repository" | eval }}'
                                          state: present
                                      when: '".artifacts::apt_package::source" | eval != ""'
                                    - name: update apt cache
                                      ansible.builtin.apt:
                                          update_cache: 'yes'
                                    - name: install dependencies
                                      ansible.builtin.apt:
                                          name: '{{ ".artifacts::apt_package::dependencies" | eval | split(",") | map("trim") }}'
                                          state: present
                                      when: '".artifacts::apt_package::dependencies" | eval != ""'
                                    - name: install package
                                      ansible.builtin.apt:
                                          name: '{{ ".artifacts::apt_package::file" | eval }}'
                                          state: present
                                      environment: '{{ ".artifacts::apt_package::env" | eval | split | map("split", "=") | community.general.dict }}'
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
                                    - name: uninstall package
                                      ansible.builtin.apt:
                                          name: '{{ ".artifacts::apt_package::file" | eval }}'
                                          state: absent
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
    java.runtime~software.application#apt.package::terraform@*->remote.machine:
        derived_from: java.runtime
        metadata:
            vintner_generated: 'true'
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            os_ssh_host:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            terraform_data:
                                vm:
                                    - connection:
                                          - host: '{{ SELF.os_ssh_host }}'
                                            private_key: ${file("{{ SELF.os_ssh_key_file }}")}
                                            type: ssh
                                            user: '{{ SELF.os_ssh_user }}'
                                      provisioner:
                                          file:
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Run setup script 
                                                    if [[ "{{ ".artifacts::apt_package::script" | eval }}" != "" ]]; then 
                                                        curl -fsSL {{ ".artifacts::apt_package::script" | eval }} | sudo -E bash -
                                                    fi

                                                    # Add apt key
                                                    if [[ "{{ ".artifacts::apt_package::key" | eval }}" != "" ]]; then 
                                                        curl -1sLf {{ ".artifacts::apt_package::key" | eval }} | gpg --dearmor --yes -o /usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg
                                                    fi

                                                    # Add apt repository
                                                    if [[ "{{ ".artifacts::apt_package::source" | eval }}" != "" ]]; then 
                                                        echo "deb [signed-by=/usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg] {{ ".artifacts::apt_package::source" | eval }}" | tee {{ ".artifacts::apt_package::repository" | eval }}
                                                    fi

                                                    # Update apt cache
                                                    apt-get update -y

                                                    # Install dependencies
                                                    if [[ "{{ ".artifacts::apt_package::dependencies" | eval }}" != "" ]]; then 
                                                        apt-get install {{ ".artifacts::apt_package::dependencies" | eval | split(",") | map("trim") }} -y
                                                    fi

                                                    # Install package
                                                    {{ ".artifacts::apt_package::env" | eval }} apt-get install {{ ".artifacts::apt_package::file" | eval }} -y

                                                    # Create application directory
                                                    mkdir -p {{ SELF.application_directory }}

                                                    # Create application environment
                                                    cat <<EOF > {{ SELF.application_directory }}/.env
                                                    APPLICATION_NAME="{{ SELF.application_name }}"
                                                    EOF>>

                                                    # Create vintner directory
                                                    mkdir -p {{ SELF.application_directory }}/.vintner

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/create.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/create.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/create.sh
                                                destination: /tmp/create-java.runtime.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/configure.sh
                                                destination: /tmp/configure-java.runtime.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/start.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/start.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/start.sh
                                                destination: /tmp/start-java.runtime.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/stop.sh
                                                destination: /tmp/stop-java.runtime.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/delete.sh

                                                    # Delete application directory
                                                    rm -rf "{{ SELF.application_directory }}"

                                                    # Uninstall package
                                                    apt-get uninstall {{ ".artifacts::apt_package::file" | eval }} -y
                                                destination: /tmp/delete-java.runtime.sh
                                          remote-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-java.runtime.sh
                                                    - sudo bash /tmp/configure-java.runtime.sh
                                                    - sudo bash /tmp/start-java.runtime.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-java.runtime.sh
                                                    - sudo bash /tmp/delete-java.runtime.sh
                                                when: destroy
    java.runtime~software.application#tar.archive::ansible@*->local.machine:
        derived_from: java.runtime
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: install operational dependencies
                                      ansible.builtin.apt:
                                          name: unzip
                                          update_cache: 'yes'
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: extract deployment artifact in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          extra_opts: '{{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}'
                                      when: not (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")
                                    - name: extract deployment artifact from URL in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          remote_src: 'yes'
                                          extra_opts: '{{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}'
                                      when: (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")
                                    - name: create vintner directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}/.vintner'
                                          state: directory
                                    - name: create .env file
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.env'
                                          content: APPLICATION_NAME="{{ SELF.application_name }}"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "start" missing
                                      when: SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "stop" missing
                                      when: SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
    java.runtime~software.application#tar.archive::terraform@*->local.machine:
        derived_from: java.runtime
        metadata:
            vintner_generated: 'true'
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            local_file:
                                tmp_artifact:
                                    source: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                    filename: /tmp/artifact-java.runtime
                                    count: '{{ (not (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")) | ternary(1, 0) }}'
                                tmp_create:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Create application directory
                                        mkdir -p {{ SELF.application_directory }}

                                        # Create application environment
                                        cat <<EOF > {{ SELF.application_directory }}/.env
                                        APPLICATION_NAME="{{ SELF.application_name }}"
                                        EOF>>

                                        # Download deployment artifact if required
                                        if [[ "{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}" == http* ]]; then 
                                            wget -O /tmp/artifact-java.runtime {{ ".artifacts::*::[.type=tar.archive]::file" | eval }} 
                                        fi

                                        # Extract deployment artifact
                                        tar -xzf /tmp/artifact-java.runtime -C {{ SELF.application_directory }} {{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}

                                        # Create vintner directory
                                        mkdir -p {{ SELF.application_directory }}/.vintner

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/create.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/create.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/create.sh
                                    filename: /tmp/create-java.runtime.sh
                                tmp_configure:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/configure.sh
                                    filename: /tmp/configure-java.runtime.sh
                                tmp_start:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Assert operation
                                        if [[ "{{ SELF._management_start | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                            echo 'Management operation "start" missing'
                                            exit 1 
                                        fi

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/start.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/start.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/start.sh
                                    filename: /tmp/start-java.runtime.sh
                                tmp_stop:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Assert operation
                                        if [[ "{{ SELF._management_stop | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                            echo 'Management operation "stop" missing'
                                            exit 1 
                                        fi

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/stop.sh
                                    filename: /tmp/stop-java.runtime.sh
                                tmp_delete:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/delete.sh

                                        # Delete application directory
                                        rm -rf "{{ SELF.application_directory }}"
                                    filename: /tmp/delete-java.runtime.sh
                            terraform_data:
                                local:
                                    - depends_on:
                                          - local_file.tmp_artifact
                                          - local_file.tmp_create
                                          - local_file.tmp_configure
                                          - local_file.tmp_start
                                          - local_file.tmp_stop
                                          - local_file.tmp_delete
                                      provisioner:
                                          local-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-java.runtime.sh
                                                    - sudo bash /tmp/configure-java.runtime.sh
                                                    - sudo bash /tmp/start-java.runtime.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-java.runtime.sh
                                                    - sudo bash /tmp/delete-java.runtime.sh
                                                when: destroy
    java.runtime~software.application#tar.archive::ansible@*->remote.machine:
        derived_from: java.runtime
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: extract deployment artifact in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          extra_opts: '{{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}'
                                      when: not (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")
                                    - name: extract deployment artifact from URL in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          remote_src: 'yes'
                                          extra_opts: '{{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}'
                                      when: (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")
                                    - name: create vintner directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}/.vintner'
                                          state: directory
                                    - name: create .env file
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.env'
                                          content: APPLICATION_NAME="{{ SELF.application_name }}"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "start" missing
                                      when: SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "stop" missing
                                      when: SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
    java.runtime~software.application#tar.archive::terraform@*->remote.machine:
        derived_from: java.runtime
        metadata:
            vintner_generated: 'true'
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            os_ssh_host:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            terraform_data:
                                vm:
                                    - connection:
                                          - host: '{{ SELF.os_ssh_host }}'
                                            private_key: ${file("{{ SELF.os_ssh_key_file }}")}
                                            type: ssh
                                            user: '{{ SELF.os_ssh_user }}'
                                      provisioner:
                                          file:
                                              - source: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                                destination: /tmp/artifact-java.runtime
                                                count: '{{ (not (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")) | ternary(1, 0) }}'
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Create application directory
                                                    mkdir -p {{ SELF.application_directory }}

                                                    # Create application environment
                                                    cat <<EOF > {{ SELF.application_directory }}/.env
                                                    APPLICATION_NAME="{{ SELF.application_name }}"
                                                    EOF>>

                                                    # Download deployment artifact if required
                                                    if [[ "{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}" == http* ]]; then 
                                                        wget -O /tmp/artifact-java.runtime {{ ".artifacts::*::[.type=tar.archive]::file" | eval }} 
                                                    fi

                                                    # Extract deployment artifact
                                                    tar -xzf /tmp/artifact-java.runtime -C {{ SELF.application_directory }} {{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}

                                                    # Create vintner directory
                                                    mkdir -p {{ SELF.application_directory }}/.vintner

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/create.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/create.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/create.sh
                                                destination: /tmp/create-java.runtime.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/configure.sh
                                                destination: /tmp/configure-java.runtime.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Assert operation
                                                    if [[ "{{ SELF._management_start | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                                        echo 'Management operation "start" missing'
                                                        exit 1 
                                                    fi

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/start.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/start.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/start.sh
                                                destination: /tmp/start-java.runtime.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Assert operation
                                                    if [[ "{{ SELF._management_stop | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                                        echo 'Management operation "stop" missing'
                                                        exit 1 
                                                    fi

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/stop.sh
                                                destination: /tmp/stop-java.runtime.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/delete.sh

                                                    # Delete application directory
                                                    rm -rf "{{ SELF.application_directory }}"
                                                destination: /tmp/delete-java.runtime.sh
                                          remote-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-java.runtime.sh
                                                    - sudo bash /tmp/configure-java.runtime.sh
                                                    - sudo bash /tmp/start-java.runtime.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-java.runtime.sh
                                                    - sudo bash /tmp/delete-java.runtime.sh
                                                when: destroy
    java.runtime~software.application#zip.archive::ansible@*->local.machine:
        derived_from: java.runtime
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: install operational dependencies
                                      ansible.builtin.apt:
                                          name: unzip
                                          update_cache: 'yes'
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: extract deployment artifact in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          extra_opts: '{{ ".artifacts::*::[.type=zip.archive]::extra_opts" | eval | map_value }}'
                                      when: not (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")
                                    - name: extract deployment artifact from URL in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          remote_src: 'yes'
                                          extra_opts: '{{ ".artifacts::*::[.type=zip.archive]::extra_opts" | eval | map_value }}'
                                      when: (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")
                                    - name: create vintner directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}/.vintner'
                                          state: directory
                                    - name: create .env file
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.env'
                                          content: APPLICATION_NAME="{{ SELF.application_name }}"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "start" missing
                                      when: SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "stop" missing
                                      when: SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
    java.runtime~software.application#zip.archive::terraform@*->local.machine:
        derived_from: java.runtime
        metadata:
            vintner_generated: 'true'
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            local_file:
                                tmp_artifact:
                                    source: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                    filename: /tmp/artifact-java.runtime
                                    count: '{{ (not (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")) | ternary(1, 0) }}'
                                tmp_create:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Create application directory
                                        mkdir -p {{ SELF.application_directory }}

                                        # Create application environment
                                        cat <<EOF > {{ SELF.application_directory }}/.env
                                        APPLICATION_NAME="{{ SELF.application_name }}"
                                        EOF>>

                                        # Download deployment artifact if required
                                        if [[ "{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}" == http* ]]; then 
                                            wget -O /tmp/artifact-java.runtime {{ ".artifacts::*::[.type=zip.archive]::file" | eval }} 
                                        fi

                                        # Extract deployment artifact
                                        unzip /tmp/artifact-java.runtime -d {{ SELF.application_directory }} {{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}

                                        # Create vintner directory
                                        mkdir -p {{ SELF.application_directory }}/.vintner

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/create.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/create.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/create.sh
                                    filename: /tmp/create-java.runtime.sh
                                tmp_configure:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/configure.sh
                                    filename: /tmp/configure-java.runtime.sh
                                tmp_start:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Assert operation
                                        if [[ "{{ SELF._management_start | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                            echo 'Management operation "start" missing'
                                            exit 1 
                                        fi

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/start.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/start.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/start.sh
                                    filename: /tmp/start-java.runtime.sh
                                tmp_stop:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Assert operation
                                        if [[ "{{ SELF._management_stop | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                            echo 'Management operation "stop" missing'
                                            exit 1 
                                        fi

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/stop.sh
                                    filename: /tmp/stop-java.runtime.sh
                                tmp_delete:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/delete.sh

                                        # Delete application directory
                                        rm -rf "{{ SELF.application_directory }}"
                                    filename: /tmp/delete-java.runtime.sh
                            terraform_data:
                                local:
                                    - depends_on:
                                          - local_file.tmp_artifact
                                          - local_file.tmp_create
                                          - local_file.tmp_configure
                                          - local_file.tmp_start
                                          - local_file.tmp_stop
                                          - local_file.tmp_delete
                                      provisioner:
                                          local-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-java.runtime.sh
                                                    - sudo bash /tmp/configure-java.runtime.sh
                                                    - sudo bash /tmp/start-java.runtime.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-java.runtime.sh
                                                    - sudo bash /tmp/delete-java.runtime.sh
                                                when: destroy
    java.runtime~software.application#zip.archive::ansible@*->remote.machine:
        derived_from: java.runtime
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: install operational dependencies
                                      ansible.builtin.apt:
                                          name: unzip
                                          update_cache: 'yes'
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: extract deployment artifact in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          extra_opts: '{{ ".artifacts::*::[.type=zip.archive]::extra_opts" | eval | map_value }}'
                                      when: not (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")
                                    - name: extract deployment artifact from URL in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          remote_src: 'yes'
                                          extra_opts: '{{ ".artifacts::*::[.type=zip.archive]::extra_opts" | eval | map_value }}'
                                      when: (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")
                                    - name: create vintner directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}/.vintner'
                                          state: directory
                                    - name: create .env file
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.env'
                                          content: APPLICATION_NAME="{{ SELF.application_name }}"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "start" missing
                                      when: SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "stop" missing
                                      when: SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
    java.runtime~software.application#zip.archive::terraform@*->remote.machine:
        derived_from: java.runtime
        metadata:
            vintner_generated: 'true'
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            os_ssh_host:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            terraform_data:
                                vm:
                                    - connection:
                                          - host: '{{ SELF.os_ssh_host }}'
                                            private_key: ${file("{{ SELF.os_ssh_key_file }}")}
                                            type: ssh
                                            user: '{{ SELF.os_ssh_user }}'
                                      provisioner:
                                          file:
                                              - source: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                                destination: /tmp/artifact-java.runtime
                                                count: '{{ (not (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")) | ternary(1, 0) }}'
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Create application directory
                                                    mkdir -p {{ SELF.application_directory }}

                                                    # Create application environment
                                                    cat <<EOF > {{ SELF.application_directory }}/.env
                                                    APPLICATION_NAME="{{ SELF.application_name }}"
                                                    EOF>>

                                                    # Download deployment artifact if required
                                                    if [[ "{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}" == http* ]]; then 
                                                        wget -O /tmp/artifact-java.runtime {{ ".artifacts::*::[.type=zip.archive]::file" | eval }} 
                                                    fi

                                                    # Extract deployment artifact
                                                    unzip /tmp/artifact-java.runtime -d {{ SELF.application_directory }} {{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}

                                                    # Create vintner directory
                                                    mkdir -p {{ SELF.application_directory }}/.vintner

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/create.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/create.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/create.sh
                                                destination: /tmp/create-java.runtime.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/configure.sh
                                                destination: /tmp/configure-java.runtime.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Assert operation
                                                    if [[ "{{ SELF._management_start | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                                        echo 'Management operation "start" missing'
                                                        exit 1 
                                                    fi

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/start.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/start.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/start.sh
                                                destination: /tmp/start-java.runtime.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Assert operation
                                                    if [[ "{{ SELF._management_stop | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                                        echo 'Management operation "stop" missing'
                                                        exit 1 
                                                    fi

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/stop.sh
                                                destination: /tmp/stop-java.runtime.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/delete.sh

                                                    # Delete application directory
                                                    rm -rf "{{ SELF.application_directory }}"
                                                destination: /tmp/delete-java.runtime.sh
                                          remote-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-java.runtime.sh
                                                    - sudo bash /tmp/configure-java.runtime.sh
                                                    - sudo bash /tmp/start-java.runtime.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-java.runtime.sh
                                                    - sudo bash /tmp/delete-java.runtime.sh
                                                when: destroy
    dotnet.runtime~software.application#apt.package::ansible@*->local.machine:
        derived_from: dotnet.runtime
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: run setup script
                                      ansible.builtin.shell: curl -fsSL {{ ".artifacts::apt_package::script" | eval }} | sudo -E bash -
                                      args:
                                          executable: /bin/bash
                                      when: '".artifacts::apt_package::script" | eval != ""'
                                    - name: add apt key
                                      ansible.builtin.apt_key:
                                          url: '{{ ".artifacts::apt_package::key" | eval }}'
                                          keyring: /usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg
                                          state: present
                                      when: '".artifacts::apt_package::key" | eval != ""'
                                    - name: add apt repository
                                      ansible.builtin.apt_repository:
                                          repo: deb [signed-by=/usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg] {{ ".artifacts::apt_package::source" | eval }}
                                          filename: '{{ ".artifacts::apt_package::repository" | eval }}'
                                          state: present
                                      when: '".artifacts::apt_package::source" | eval != ""'
                                    - name: update apt cache
                                      ansible.builtin.apt:
                                          update_cache: 'yes'
                                    - name: install dependencies
                                      ansible.builtin.apt:
                                          name: '{{ ".artifacts::apt_package::dependencies" | eval | split(",") | map("trim") }}'
                                          state: present
                                      when: '".artifacts::apt_package::dependencies" | eval != ""'
                                    - name: install package
                                      ansible.builtin.apt:
                                          name: '{{ ".artifacts::apt_package::file" | eval }}'
                                          state: present
                                      environment: '{{ ".artifacts::apt_package::env" | eval | split | map("split", "=") | community.general.dict }}'
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
                                    - name: uninstall package
                                      ansible.builtin.apt:
                                          name: '{{ ".artifacts::apt_package::file" | eval }}'
                                          state: absent
    dotnet.runtime~software.application#apt.package::terraform@*->local.machine:
        derived_from: dotnet.runtime
        metadata:
            vintner_generated: 'true'
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            local_file:
                                tmp_create:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Run setup script 
                                        if [[ "{{ ".artifacts::apt_package::script" | eval }}" != "" ]]; then 
                                            curl -fsSL {{ ".artifacts::apt_package::script" | eval }} | sudo -E bash -
                                        fi

                                        # Add apt key
                                        if [[ "{{ ".artifacts::apt_package::key" | eval }}" != "" ]]; then 
                                            curl -1sLf {{ ".artifacts::apt_package::key" | eval }} | gpg --dearmor --yes -o /usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg
                                        fi

                                        # Add apt repository
                                        if [[ "{{ ".artifacts::apt_package::source" | eval }}" != "" ]]; then 
                                            echo "deb [signed-by=/usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg] {{ ".artifacts::apt_package::source" | eval }}" | tee {{ ".artifacts::apt_package::repository" | eval }}
                                        fi

                                        # Update apt cache
                                        apt-get update -y

                                        # Install dependencies
                                        if [[ "{{ ".artifacts::apt_package::dependencies" | eval }}" != "" ]]; then 
                                            apt-get install {{ ".artifacts::apt_package::dependencies" | eval | split(",") | map("trim") }} -y
                                        fi

                                        # Install package
                                        {{ ".artifacts::apt_package::env" | eval }} apt-get install {{ ".artifacts::apt_package::file" | eval }} -y

                                        # Create application directory
                                        mkdir -p {{ SELF.application_directory }}

                                        # Create application environment
                                        cat <<EOF > {{ SELF.application_directory }}/.env
                                        APPLICATION_NAME="{{ SELF.application_name }}"
                                        EOF>>

                                        # Create vintner directory
                                        mkdir -p {{ SELF.application_directory }}/.vintner

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/create.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/create.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/create.sh
                                    filename: /tmp/create-dotnet.runtime.sh
                                tmp_configure:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/configure.sh
                                    filename: /tmp/configure-dotnet.runtime.sh
                                tmp_start:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/start.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/start.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/start.sh
                                    filename: /tmp/start-dotnet.runtime.sh
                                tmp_stop:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/stop.sh
                                    filename: /tmp/stop-dotnet.runtime.sh
                                tmp_delete:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/delete.sh

                                        # Delete application directory
                                        rm -rf "{{ SELF.application_directory }}"

                                        # Uninstall package
                                        apt-get uninstall {{ ".artifacts::apt_package::file" | eval }} -y
                                    filename: /tmp/delete-dotnet.runtime.sh
                            terraform_data:
                                local:
                                    - provisioner:
                                          depends_on:
                                              - local_file.tmp_artifact
                                              - local_file.tmp_create
                                              - local_file.tmp_configure
                                              - local_file.tmp_start
                                              - local_file.tmp_stop
                                              - local_file.tmp_delete
                                          local-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-dotnet.runtime.sh
                                                    - sudo bash /tmp/configure-dotnet.runtime.sh
                                                    - sudo bash /tmp/start-dotnet.runtime.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-dotnet.runtime.sh
                                                    - sudo bash /tmp/delete-dotnet.runtime.sh
                                                when: destroy
    dotnet.runtime~software.application#apt.package::ansible@*->remote.machine:
        derived_from: dotnet.runtime
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: run setup script
                                      ansible.builtin.shell: curl -fsSL {{ ".artifacts::apt_package::script" | eval }} | sudo -E bash -
                                      args:
                                          executable: /bin/bash
                                      when: '".artifacts::apt_package::script" | eval != ""'
                                    - name: add apt key
                                      ansible.builtin.apt_key:
                                          url: '{{ ".artifacts::apt_package::key" | eval }}'
                                          keyring: /usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg
                                          state: present
                                      when: '".artifacts::apt_package::key" | eval != ""'
                                    - name: add apt repository
                                      ansible.builtin.apt_repository:
                                          repo: deb [signed-by=/usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg] {{ ".artifacts::apt_package::source" | eval }}
                                          filename: '{{ ".artifacts::apt_package::repository" | eval }}'
                                          state: present
                                      when: '".artifacts::apt_package::source" | eval != ""'
                                    - name: update apt cache
                                      ansible.builtin.apt:
                                          update_cache: 'yes'
                                    - name: install dependencies
                                      ansible.builtin.apt:
                                          name: '{{ ".artifacts::apt_package::dependencies" | eval | split(",") | map("trim") }}'
                                          state: present
                                      when: '".artifacts::apt_package::dependencies" | eval != ""'
                                    - name: install package
                                      ansible.builtin.apt:
                                          name: '{{ ".artifacts::apt_package::file" | eval }}'
                                          state: present
                                      environment: '{{ ".artifacts::apt_package::env" | eval | split | map("split", "=") | community.general.dict }}'
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
                                    - name: uninstall package
                                      ansible.builtin.apt:
                                          name: '{{ ".artifacts::apt_package::file" | eval }}'
                                          state: absent
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
    dotnet.runtime~software.application#apt.package::terraform@*->remote.machine:
        derived_from: dotnet.runtime
        metadata:
            vintner_generated: 'true'
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            os_ssh_host:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            terraform_data:
                                vm:
                                    - connection:
                                          - host: '{{ SELF.os_ssh_host }}'
                                            private_key: ${file("{{ SELF.os_ssh_key_file }}")}
                                            type: ssh
                                            user: '{{ SELF.os_ssh_user }}'
                                      provisioner:
                                          file:
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Run setup script 
                                                    if [[ "{{ ".artifacts::apt_package::script" | eval }}" != "" ]]; then 
                                                        curl -fsSL {{ ".artifacts::apt_package::script" | eval }} | sudo -E bash -
                                                    fi

                                                    # Add apt key
                                                    if [[ "{{ ".artifacts::apt_package::key" | eval }}" != "" ]]; then 
                                                        curl -1sLf {{ ".artifacts::apt_package::key" | eval }} | gpg --dearmor --yes -o /usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg
                                                    fi

                                                    # Add apt repository
                                                    if [[ "{{ ".artifacts::apt_package::source" | eval }}" != "" ]]; then 
                                                        echo "deb [signed-by=/usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg] {{ ".artifacts::apt_package::source" | eval }}" | tee {{ ".artifacts::apt_package::repository" | eval }}
                                                    fi

                                                    # Update apt cache
                                                    apt-get update -y

                                                    # Install dependencies
                                                    if [[ "{{ ".artifacts::apt_package::dependencies" | eval }}" != "" ]]; then 
                                                        apt-get install {{ ".artifacts::apt_package::dependencies" | eval | split(",") | map("trim") }} -y
                                                    fi

                                                    # Install package
                                                    {{ ".artifacts::apt_package::env" | eval }} apt-get install {{ ".artifacts::apt_package::file" | eval }} -y

                                                    # Create application directory
                                                    mkdir -p {{ SELF.application_directory }}

                                                    # Create application environment
                                                    cat <<EOF > {{ SELF.application_directory }}/.env
                                                    APPLICATION_NAME="{{ SELF.application_name }}"
                                                    EOF>>

                                                    # Create vintner directory
                                                    mkdir -p {{ SELF.application_directory }}/.vintner

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/create.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/create.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/create.sh
                                                destination: /tmp/create-dotnet.runtime.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/configure.sh
                                                destination: /tmp/configure-dotnet.runtime.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/start.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/start.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/start.sh
                                                destination: /tmp/start-dotnet.runtime.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/stop.sh
                                                destination: /tmp/stop-dotnet.runtime.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/delete.sh

                                                    # Delete application directory
                                                    rm -rf "{{ SELF.application_directory }}"

                                                    # Uninstall package
                                                    apt-get uninstall {{ ".artifacts::apt_package::file" | eval }} -y
                                                destination: /tmp/delete-dotnet.runtime.sh
                                          remote-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-dotnet.runtime.sh
                                                    - sudo bash /tmp/configure-dotnet.runtime.sh
                                                    - sudo bash /tmp/start-dotnet.runtime.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-dotnet.runtime.sh
                                                    - sudo bash /tmp/delete-dotnet.runtime.sh
                                                when: destroy
    dotnet.runtime~software.application#tar.archive::ansible@*->local.machine:
        derived_from: dotnet.runtime
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: install operational dependencies
                                      ansible.builtin.apt:
                                          name: unzip
                                          update_cache: 'yes'
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: extract deployment artifact in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          extra_opts: '{{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}'
                                      when: not (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")
                                    - name: extract deployment artifact from URL in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          remote_src: 'yes'
                                          extra_opts: '{{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}'
                                      when: (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")
                                    - name: create vintner directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}/.vintner'
                                          state: directory
                                    - name: create .env file
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.env'
                                          content: APPLICATION_NAME="{{ SELF.application_name }}"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "start" missing
                                      when: SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "stop" missing
                                      when: SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
    dotnet.runtime~software.application#tar.archive::terraform@*->local.machine:
        derived_from: dotnet.runtime
        metadata:
            vintner_generated: 'true'
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            local_file:
                                tmp_artifact:
                                    source: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                    filename: /tmp/artifact-dotnet.runtime
                                    count: '{{ (not (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")) | ternary(1, 0) }}'
                                tmp_create:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Create application directory
                                        mkdir -p {{ SELF.application_directory }}

                                        # Create application environment
                                        cat <<EOF > {{ SELF.application_directory }}/.env
                                        APPLICATION_NAME="{{ SELF.application_name }}"
                                        EOF>>

                                        # Download deployment artifact if required
                                        if [[ "{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}" == http* ]]; then 
                                            wget -O /tmp/artifact-dotnet.runtime {{ ".artifacts::*::[.type=tar.archive]::file" | eval }} 
                                        fi

                                        # Extract deployment artifact
                                        tar -xzf /tmp/artifact-dotnet.runtime -C {{ SELF.application_directory }} {{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}

                                        # Create vintner directory
                                        mkdir -p {{ SELF.application_directory }}/.vintner

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/create.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/create.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/create.sh
                                    filename: /tmp/create-dotnet.runtime.sh
                                tmp_configure:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/configure.sh
                                    filename: /tmp/configure-dotnet.runtime.sh
                                tmp_start:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Assert operation
                                        if [[ "{{ SELF._management_start | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                            echo 'Management operation "start" missing'
                                            exit 1 
                                        fi

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/start.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/start.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/start.sh
                                    filename: /tmp/start-dotnet.runtime.sh
                                tmp_stop:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Assert operation
                                        if [[ "{{ SELF._management_stop | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                            echo 'Management operation "stop" missing'
                                            exit 1 
                                        fi

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/stop.sh
                                    filename: /tmp/stop-dotnet.runtime.sh
                                tmp_delete:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/delete.sh

                                        # Delete application directory
                                        rm -rf "{{ SELF.application_directory }}"
                                    filename: /tmp/delete-dotnet.runtime.sh
                            terraform_data:
                                local:
                                    - depends_on:
                                          - local_file.tmp_artifact
                                          - local_file.tmp_create
                                          - local_file.tmp_configure
                                          - local_file.tmp_start
                                          - local_file.tmp_stop
                                          - local_file.tmp_delete
                                      provisioner:
                                          local-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-dotnet.runtime.sh
                                                    - sudo bash /tmp/configure-dotnet.runtime.sh
                                                    - sudo bash /tmp/start-dotnet.runtime.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-dotnet.runtime.sh
                                                    - sudo bash /tmp/delete-dotnet.runtime.sh
                                                when: destroy
    dotnet.runtime~software.application#tar.archive::ansible@*->remote.machine:
        derived_from: dotnet.runtime
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: extract deployment artifact in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          extra_opts: '{{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}'
                                      when: not (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")
                                    - name: extract deployment artifact from URL in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          remote_src: 'yes'
                                          extra_opts: '{{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}'
                                      when: (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")
                                    - name: create vintner directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}/.vintner'
                                          state: directory
                                    - name: create .env file
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.env'
                                          content: APPLICATION_NAME="{{ SELF.application_name }}"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "start" missing
                                      when: SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "stop" missing
                                      when: SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
    dotnet.runtime~software.application#tar.archive::terraform@*->remote.machine:
        derived_from: dotnet.runtime
        metadata:
            vintner_generated: 'true'
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            os_ssh_host:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            terraform_data:
                                vm:
                                    - connection:
                                          - host: '{{ SELF.os_ssh_host }}'
                                            private_key: ${file("{{ SELF.os_ssh_key_file }}")}
                                            type: ssh
                                            user: '{{ SELF.os_ssh_user }}'
                                      provisioner:
                                          file:
                                              - source: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                                destination: /tmp/artifact-dotnet.runtime
                                                count: '{{ (not (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")) | ternary(1, 0) }}'
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Create application directory
                                                    mkdir -p {{ SELF.application_directory }}

                                                    # Create application environment
                                                    cat <<EOF > {{ SELF.application_directory }}/.env
                                                    APPLICATION_NAME="{{ SELF.application_name }}"
                                                    EOF>>

                                                    # Download deployment artifact if required
                                                    if [[ "{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}" == http* ]]; then 
                                                        wget -O /tmp/artifact-dotnet.runtime {{ ".artifacts::*::[.type=tar.archive]::file" | eval }} 
                                                    fi

                                                    # Extract deployment artifact
                                                    tar -xzf /tmp/artifact-dotnet.runtime -C {{ SELF.application_directory }} {{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}

                                                    # Create vintner directory
                                                    mkdir -p {{ SELF.application_directory }}/.vintner

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/create.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/create.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/create.sh
                                                destination: /tmp/create-dotnet.runtime.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/configure.sh
                                                destination: /tmp/configure-dotnet.runtime.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Assert operation
                                                    if [[ "{{ SELF._management_start | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                                        echo 'Management operation "start" missing'
                                                        exit 1 
                                                    fi

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/start.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/start.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/start.sh
                                                destination: /tmp/start-dotnet.runtime.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Assert operation
                                                    if [[ "{{ SELF._management_stop | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                                        echo 'Management operation "stop" missing'
                                                        exit 1 
                                                    fi

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/stop.sh
                                                destination: /tmp/stop-dotnet.runtime.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/delete.sh

                                                    # Delete application directory
                                                    rm -rf "{{ SELF.application_directory }}"
                                                destination: /tmp/delete-dotnet.runtime.sh
                                          remote-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-dotnet.runtime.sh
                                                    - sudo bash /tmp/configure-dotnet.runtime.sh
                                                    - sudo bash /tmp/start-dotnet.runtime.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-dotnet.runtime.sh
                                                    - sudo bash /tmp/delete-dotnet.runtime.sh
                                                when: destroy
    dotnet.runtime~software.application#zip.archive::ansible@*->local.machine:
        derived_from: dotnet.runtime
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: install operational dependencies
                                      ansible.builtin.apt:
                                          name: unzip
                                          update_cache: 'yes'
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: extract deployment artifact in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          extra_opts: '{{ ".artifacts::*::[.type=zip.archive]::extra_opts" | eval | map_value }}'
                                      when: not (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")
                                    - name: extract deployment artifact from URL in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          remote_src: 'yes'
                                          extra_opts: '{{ ".artifacts::*::[.type=zip.archive]::extra_opts" | eval | map_value }}'
                                      when: (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")
                                    - name: create vintner directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}/.vintner'
                                          state: directory
                                    - name: create .env file
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.env'
                                          content: APPLICATION_NAME="{{ SELF.application_name }}"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "start" missing
                                      when: SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "stop" missing
                                      when: SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
    dotnet.runtime~software.application#zip.archive::terraform@*->local.machine:
        derived_from: dotnet.runtime
        metadata:
            vintner_generated: 'true'
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            local_file:
                                tmp_artifact:
                                    source: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                    filename: /tmp/artifact-dotnet.runtime
                                    count: '{{ (not (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")) | ternary(1, 0) }}'
                                tmp_create:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Create application directory
                                        mkdir -p {{ SELF.application_directory }}

                                        # Create application environment
                                        cat <<EOF > {{ SELF.application_directory }}/.env
                                        APPLICATION_NAME="{{ SELF.application_name }}"
                                        EOF>>

                                        # Download deployment artifact if required
                                        if [[ "{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}" == http* ]]; then 
                                            wget -O /tmp/artifact-dotnet.runtime {{ ".artifacts::*::[.type=zip.archive]::file" | eval }} 
                                        fi

                                        # Extract deployment artifact
                                        unzip /tmp/artifact-dotnet.runtime -d {{ SELF.application_directory }} {{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}

                                        # Create vintner directory
                                        mkdir -p {{ SELF.application_directory }}/.vintner

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/create.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/create.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/create.sh
                                    filename: /tmp/create-dotnet.runtime.sh
                                tmp_configure:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/configure.sh
                                    filename: /tmp/configure-dotnet.runtime.sh
                                tmp_start:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Assert operation
                                        if [[ "{{ SELF._management_start | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                            echo 'Management operation "start" missing'
                                            exit 1 
                                        fi

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/start.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/start.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/start.sh
                                    filename: /tmp/start-dotnet.runtime.sh
                                tmp_stop:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Assert operation
                                        if [[ "{{ SELF._management_stop | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                            echo 'Management operation "stop" missing'
                                            exit 1 
                                        fi

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/stop.sh
                                    filename: /tmp/stop-dotnet.runtime.sh
                                tmp_delete:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/delete.sh

                                        # Delete application directory
                                        rm -rf "{{ SELF.application_directory }}"
                                    filename: /tmp/delete-dotnet.runtime.sh
                            terraform_data:
                                local:
                                    - depends_on:
                                          - local_file.tmp_artifact
                                          - local_file.tmp_create
                                          - local_file.tmp_configure
                                          - local_file.tmp_start
                                          - local_file.tmp_stop
                                          - local_file.tmp_delete
                                      provisioner:
                                          local-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-dotnet.runtime.sh
                                                    - sudo bash /tmp/configure-dotnet.runtime.sh
                                                    - sudo bash /tmp/start-dotnet.runtime.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-dotnet.runtime.sh
                                                    - sudo bash /tmp/delete-dotnet.runtime.sh
                                                when: destroy
    dotnet.runtime~software.application#zip.archive::ansible@*->remote.machine:
        derived_from: dotnet.runtime
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: install operational dependencies
                                      ansible.builtin.apt:
                                          name: unzip
                                          update_cache: 'yes'
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: extract deployment artifact in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          extra_opts: '{{ ".artifacts::*::[.type=zip.archive]::extra_opts" | eval | map_value }}'
                                      when: not (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")
                                    - name: extract deployment artifact from URL in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          remote_src: 'yes'
                                          extra_opts: '{{ ".artifacts::*::[.type=zip.archive]::extra_opts" | eval | map_value }}'
                                      when: (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")
                                    - name: create vintner directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}/.vintner'
                                          state: directory
                                    - name: create .env file
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.env'
                                          content: APPLICATION_NAME="{{ SELF.application_name }}"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "start" missing
                                      when: SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "stop" missing
                                      when: SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
    dotnet.runtime~software.application#zip.archive::terraform@*->remote.machine:
        derived_from: dotnet.runtime
        metadata:
            vintner_generated: 'true'
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            os_ssh_host:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            terraform_data:
                                vm:
                                    - connection:
                                          - host: '{{ SELF.os_ssh_host }}'
                                            private_key: ${file("{{ SELF.os_ssh_key_file }}")}
                                            type: ssh
                                            user: '{{ SELF.os_ssh_user }}'
                                      provisioner:
                                          file:
                                              - source: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                                destination: /tmp/artifact-dotnet.runtime
                                                count: '{{ (not (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")) | ternary(1, 0) }}'
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Create application directory
                                                    mkdir -p {{ SELF.application_directory }}

                                                    # Create application environment
                                                    cat <<EOF > {{ SELF.application_directory }}/.env
                                                    APPLICATION_NAME="{{ SELF.application_name }}"
                                                    EOF>>

                                                    # Download deployment artifact if required
                                                    if [[ "{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}" == http* ]]; then 
                                                        wget -O /tmp/artifact-dotnet.runtime {{ ".artifacts::*::[.type=zip.archive]::file" | eval }} 
                                                    fi

                                                    # Extract deployment artifact
                                                    unzip /tmp/artifact-dotnet.runtime -d {{ SELF.application_directory }} {{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}

                                                    # Create vintner directory
                                                    mkdir -p {{ SELF.application_directory }}/.vintner

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/create.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/create.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/create.sh
                                                destination: /tmp/create-dotnet.runtime.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/configure.sh
                                                destination: /tmp/configure-dotnet.runtime.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Assert operation
                                                    if [[ "{{ SELF._management_start | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                                        echo 'Management operation "start" missing'
                                                        exit 1 
                                                    fi

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/start.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/start.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/start.sh
                                                destination: /tmp/start-dotnet.runtime.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Assert operation
                                                    if [[ "{{ SELF._management_stop | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                                        echo 'Management operation "stop" missing'
                                                        exit 1 
                                                    fi

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/stop.sh
                                                destination: /tmp/stop-dotnet.runtime.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/delete.sh

                                                    # Delete application directory
                                                    rm -rf "{{ SELF.application_directory }}"
                                                destination: /tmp/delete-dotnet.runtime.sh
                                          remote-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-dotnet.runtime.sh
                                                    - sudo bash /tmp/configure-dotnet.runtime.sh
                                                    - sudo bash /tmp/start-dotnet.runtime.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-dotnet.runtime.sh
                                                    - sudo bash /tmp/delete-dotnet.runtime.sh
                                                when: destroy
    gcp.cloudrun~gcp.service::ansible:
        derived_from: gcp.cloudrun
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            gcp_service_account_file:
                type: string
                default:
                    get_input: gcp_service_account_file
            gcp_region:
                type: string
                default:
                    get_input: gcp_region
            gcp_project:
                type: string
                default:
                    get_input: gcp_project
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                            environment:
                                GCP_SERVICE_ACCOUNT_FILE:
                                    eval: .::gcp_service_account_file
                                GCP_AUTH_KIND: serviceaccount
                        inputs:
                            playbook:
                                q:
                                    - name: enable service
                                      google.cloud.gcp_serviceusage_service:
                                          name: '{{ SELF.gcp_service }}'
                                          project: '{{ SELF.gcp_project }}'
                    delete: exit 0
    gcp.cloudrun~gcp.service::terraform:
        derived_from: gcp.cloudrun
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            gcp_service_account_file:
                type: string
                default:
                    get_input: gcp_service_account_file
            gcp_region:
                type: string
                default:
                    get_input: gcp_region
            gcp_project:
                type: string
                default:
                    get_input: gcp_project
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        terraform:
                            - required_providers:
                                  - google:
                                        source: hashicorp/google
                                        version: 4.67.0
                              required_version: '>= 0.14.0'
                        provider:
                            google:
                                - credentials: '{{ SELF.gcp_service_account_file }}'
                                  project: '{{ SELF.gcp_project }}'
                                  region: '{{ SELF.gcp_region }}'
                        resource:
                            google_project_service:
                                gcp_service:
                                    - disable_on_destroy: false
                                      project: '{{ SELF.gcp_project }}'
                                      service: '{{ SELF.gcp_service }}'
    gcp.cloudsql~gcp.service::ansible:
        derived_from: gcp.cloudsql
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            gcp_service_account_file:
                type: string
                default:
                    get_input: gcp_service_account_file
            gcp_region:
                type: string
                default:
                    get_input: gcp_region
            gcp_project:
                type: string
                default:
                    get_input: gcp_project
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                            environment:
                                GCP_SERVICE_ACCOUNT_FILE:
                                    eval: .::gcp_service_account_file
                                GCP_AUTH_KIND: serviceaccount
                        inputs:
                            playbook:
                                q:
                                    - name: enable service
                                      google.cloud.gcp_serviceusage_service:
                                          name: '{{ SELF.gcp_service }}'
                                          project: '{{ SELF.gcp_project }}'
                    delete: exit 0
    gcp.cloudsql~gcp.service::terraform:
        derived_from: gcp.cloudsql
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            gcp_service_account_file:
                type: string
                default:
                    get_input: gcp_service_account_file
            gcp_region:
                type: string
                default:
                    get_input: gcp_region
            gcp_project:
                type: string
                default:
                    get_input: gcp_project
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        terraform:
                            - required_providers:
                                  - google:
                                        source: hashicorp/google
                                        version: 4.67.0
                              required_version: '>= 0.14.0'
                        provider:
                            google:
                                - credentials: '{{ SELF.gcp_service_account_file }}'
                                  project: '{{ SELF.gcp_project }}'
                                  region: '{{ SELF.gcp_region }}'
                        resource:
                            google_project_service:
                                gcp_service:
                                    - disable_on_destroy: false
                                      project: '{{ SELF.gcp_project }}'
                                      service: '{{ SELF.gcp_service }}'
    gcp.appengine~gcp.service::ansible:
        derived_from: gcp.appengine
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            gcp_service_account_file:
                type: string
                default:
                    get_input: gcp_service_account_file
            gcp_region:
                type: string
                default:
                    get_input: gcp_region
            gcp_project:
                type: string
                default:
                    get_input: gcp_project
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                            environment:
                                GCP_SERVICE_ACCOUNT_FILE:
                                    eval: .::gcp_service_account_file
                                GCP_AUTH_KIND: serviceaccount
                        inputs:
                            playbook:
                                q:
                                    - name: enable service
                                      google.cloud.gcp_serviceusage_service:
                                          name: '{{ SELF.gcp_service }}'
                                          project: '{{ SELF.gcp_project }}'
                    delete: exit 0
    gcp.appengine~gcp.service::terraform:
        derived_from: gcp.appengine
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            gcp_service_account_file:
                type: string
                default:
                    get_input: gcp_service_account_file
            gcp_region:
                type: string
                default:
                    get_input: gcp_region
            gcp_project:
                type: string
                default:
                    get_input: gcp_project
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        terraform:
                            - required_providers:
                                  - google:
                                        source: hashicorp/google
                                        version: 4.67.0
                              required_version: '>= 0.14.0'
                        provider:
                            google:
                                - credentials: '{{ SELF.gcp_service_account_file }}'
                                  project: '{{ SELF.gcp_project }}'
                                  region: '{{ SELF.gcp_region }}'
                        resource:
                            google_project_service:
                                gcp_service:
                                    - disable_on_destroy: false
                                      project: '{{ SELF.gcp_project }}'
                                      service: '{{ SELF.gcp_service }}'
    gcp.appenginereporting~gcp.service::ansible:
        derived_from: gcp.appenginereporting
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            gcp_service_account_file:
                type: string
                default:
                    get_input: gcp_service_account_file
            gcp_region:
                type: string
                default:
                    get_input: gcp_region
            gcp_project:
                type: string
                default:
                    get_input: gcp_project
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                            environment:
                                GCP_SERVICE_ACCOUNT_FILE:
                                    eval: .::gcp_service_account_file
                                GCP_AUTH_KIND: serviceaccount
                        inputs:
                            playbook:
                                q:
                                    - name: enable service
                                      google.cloud.gcp_serviceusage_service:
                                          name: '{{ SELF.gcp_service }}'
                                          project: '{{ SELF.gcp_project }}'
                    delete: exit 0
    gcp.appenginereporting~gcp.service::terraform:
        derived_from: gcp.appenginereporting
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            gcp_service_account_file:
                type: string
                default:
                    get_input: gcp_service_account_file
            gcp_region:
                type: string
                default:
                    get_input: gcp_region
            gcp_project:
                type: string
                default:
                    get_input: gcp_project
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        terraform:
                            - required_providers:
                                  - google:
                                        source: hashicorp/google
                                        version: 4.67.0
                              required_version: '>= 0.14.0'
                        provider:
                            google:
                                - credentials: '{{ SELF.gcp_service_account_file }}'
                                  project: '{{ SELF.gcp_project }}'
                                  region: '{{ SELF.gcp_region }}'
                        resource:
                            google_project_service:
                                gcp_service:
                                    - disable_on_destroy: false
                                      project: '{{ SELF.gcp_project }}'
                                      service: '{{ SELF.gcp_service }}'
    gcp.cloudbuild~gcp.service::ansible:
        derived_from: gcp.cloudbuild
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            gcp_service_account_file:
                type: string
                default:
                    get_input: gcp_service_account_file
            gcp_region:
                type: string
                default:
                    get_input: gcp_region
            gcp_project:
                type: string
                default:
                    get_input: gcp_project
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                            environment:
                                GCP_SERVICE_ACCOUNT_FILE:
                                    eval: .::gcp_service_account_file
                                GCP_AUTH_KIND: serviceaccount
                        inputs:
                            playbook:
                                q:
                                    - name: enable service
                                      google.cloud.gcp_serviceusage_service:
                                          name: '{{ SELF.gcp_service }}'
                                          project: '{{ SELF.gcp_project }}'
                    delete: exit 0
    gcp.cloudbuild~gcp.service::terraform:
        derived_from: gcp.cloudbuild
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            gcp_service_account_file:
                type: string
                default:
                    get_input: gcp_service_account_file
            gcp_region:
                type: string
                default:
                    get_input: gcp_region
            gcp_project:
                type: string
                default:
                    get_input: gcp_project
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        terraform:
                            - required_providers:
                                  - google:
                                        source: hashicorp/google
                                        version: 4.67.0
                              required_version: '>= 0.14.0'
                        provider:
                            google:
                                - credentials: '{{ SELF.gcp_service_account_file }}'
                                  project: '{{ SELF.gcp_project }}'
                                  region: '{{ SELF.gcp_region }}'
                        resource:
                            google_project_service:
                                gcp_service:
                                    - disable_on_destroy: false
                                      project: '{{ SELF.gcp_project }}'
                                      service: '{{ SELF.gcp_service }}'
    gcp.kubernetesengine~gcp.service::ansible:
        derived_from: gcp.kubernetesengine
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            gcp_service_account_file:
                type: string
                default:
                    get_input: gcp_service_account_file
            gcp_region:
                type: string
                default:
                    get_input: gcp_region
            gcp_project:
                type: string
                default:
                    get_input: gcp_project
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                            environment:
                                GCP_SERVICE_ACCOUNT_FILE:
                                    eval: .::gcp_service_account_file
                                GCP_AUTH_KIND: serviceaccount
                        inputs:
                            playbook:
                                q:
                                    - name: enable service
                                      google.cloud.gcp_serviceusage_service:
                                          name: '{{ SELF.gcp_service }}'
                                          project: '{{ SELF.gcp_project }}'
                    delete: exit 0
    gcp.kubernetesengine~gcp.service::terraform:
        derived_from: gcp.kubernetesengine
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            gcp_service_account_file:
                type: string
                default:
                    get_input: gcp_service_account_file
            gcp_region:
                type: string
                default:
                    get_input: gcp_region
            gcp_project:
                type: string
                default:
                    get_input: gcp_project
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        terraform:
                            - required_providers:
                                  - google:
                                        source: hashicorp/google
                                        version: 4.67.0
                              required_version: '>= 0.14.0'
                        provider:
                            google:
                                - credentials: '{{ SELF.gcp_service_account_file }}'
                                  project: '{{ SELF.gcp_project }}'
                                  region: '{{ SELF.gcp_region }}'
                        resource:
                            google_project_service:
                                gcp_service:
                                    - disable_on_destroy: false
                                      project: '{{ SELF.gcp_project }}'
                                      service: '{{ SELF.gcp_service }}'
    gcp.cloudstorage~gcp.service::ansible:
        derived_from: gcp.cloudstorage
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            gcp_service_account_file:
                type: string
                default:
                    get_input: gcp_service_account_file
            gcp_region:
                type: string
                default:
                    get_input: gcp_region
            gcp_project:
                type: string
                default:
                    get_input: gcp_project
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                            environment:
                                GCP_SERVICE_ACCOUNT_FILE:
                                    eval: .::gcp_service_account_file
                                GCP_AUTH_KIND: serviceaccount
                        inputs:
                            playbook:
                                q:
                                    - name: enable service
                                      google.cloud.gcp_serviceusage_service:
                                          name: '{{ SELF.gcp_service }}'
                                          project: '{{ SELF.gcp_project }}'
                    delete: exit 0
    gcp.cloudstorage~gcp.service::terraform:
        derived_from: gcp.cloudstorage
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            gcp_service_account_file:
                type: string
                default:
                    get_input: gcp_service_account_file
            gcp_region:
                type: string
                default:
                    get_input: gcp_region
            gcp_project:
                type: string
                default:
                    get_input: gcp_project
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        terraform:
                            - required_providers:
                                  - google:
                                        source: hashicorp/google
                                        version: 4.67.0
                              required_version: '>= 0.14.0'
                        provider:
                            google:
                                - credentials: '{{ SELF.gcp_service_account_file }}'
                                  project: '{{ SELF.gcp_project }}'
                                  region: '{{ SELF.gcp_region }}'
                        resource:
                            google_project_service:
                                gcp_service:
                                    - disable_on_destroy: false
                                      project: '{{ SELF.gcp_project }}'
                                      service: '{{ SELF.gcp_service }}'
    gcp.memorystore~gcp.service::ansible:
        derived_from: gcp.memorystore
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            gcp_service_account_file:
                type: string
                default:
                    get_input: gcp_service_account_file
            gcp_region:
                type: string
                default:
                    get_input: gcp_region
            gcp_project:
                type: string
                default:
                    get_input: gcp_project
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                            environment:
                                GCP_SERVICE_ACCOUNT_FILE:
                                    eval: .::gcp_service_account_file
                                GCP_AUTH_KIND: serviceaccount
                        inputs:
                            playbook:
                                q:
                                    - name: enable service
                                      google.cloud.gcp_serviceusage_service:
                                          name: '{{ SELF.gcp_service }}'
                                          project: '{{ SELF.gcp_project }}'
                    delete: exit 0
    gcp.memorystore~gcp.service::terraform:
        derived_from: gcp.memorystore
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            gcp_service_account_file:
                type: string
                default:
                    get_input: gcp_service_account_file
            gcp_region:
                type: string
                default:
                    get_input: gcp_region
            gcp_project:
                type: string
                default:
                    get_input: gcp_project
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        terraform:
                            - required_providers:
                                  - google:
                                        source: hashicorp/google
                                        version: 4.67.0
                              required_version: '>= 0.14.0'
                        provider:
                            google:
                                - credentials: '{{ SELF.gcp_service_account_file }}'
                                  project: '{{ SELF.gcp_project }}'
                                  region: '{{ SELF.gcp_region }}'
                        resource:
                            google_project_service:
                                gcp_service:
                                    - disable_on_destroy: false
                                      project: '{{ SELF.gcp_project }}'
                                      service: '{{ SELF.gcp_service }}'
    docker.engine~docker.engine::ansible@local.machine:
        derived_from: docker.engine
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        attributes:
            application_address:
                type: string
                default: 127.0.0.1
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: install docker
                                      ansible.builtin.shell: curl -sSL https://get.docker.com | sh
                                      args:
                                          executable: /usr/bin/bash
                                    - name: update service
                                      ansible.builtin.copy:
                                          dest: /lib/systemd/system/docker.service
                                          content: |
                                              [Unit]
                                              Description=Docker Application Container Engine
                                              Documentation=https://docs.docker.com
                                              After=network-online.target docker.socket firewalld.service containerd.service time-set.target
                                              Wants=network-online.target containerd.service
                                              Requires=docker.socket

                                              [Service]
                                              Type=notify
                                              ExecStart=/usr/bin/dockerd -H fd:// -H tcp://0.0.0.0:2375 --containerd=/run/containerd/containerd.sock
                                              ExecReload=/bin/kill -s HUP $MAINPID
                                              TimeoutStartSec=0
                                              RestartSec=2
                                              Restart=always
                                              StartLimitBurst=3
                                              StartLimitInterval=60s
                                              LimitNPROC=infinity
                                              LimitCORE=infinity
                                              TasksMax=infinity
                                              Delegate=yes
                                              KillMode=process
                                              OOMScoreAdjust=-500

                                              [Install]
                                              WantedBy=multi-user.target
                                    - name: restart service
                                      ansible.builtin.systemd:
                                          name: docker.service
                                          state: restarted
                                          enabled: 'yes'
                                          daemon_reload: 'yes'
                                    - name: add docker group
                                      ansible.builtin.group:
                                          name: docker
                                    - name: add user to docker group
                                      ansible.builtin.user:
                                          name: '{{ SELF.os_ssh_user }}'
                                          groups: docker
                                          append: 'yes'
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: delete docker packages
                                      ansible.builtin.apt:
                                          name:
                                              - docker-ce
                                              - docker-ce-cli
                                              - containerd.io
                                              - docker-buildx-plugin
                                              - docker-compose-plugin
                                              - docker-ce-rootless-extras
                                          state: absent
                                          purge: 'true'
                                          autoremove: 'true'
                                    - name: delete docker directories
                                      ansible.builtin.file:
                                          name: '{{ item }}'
                                          state: absent
                                      loop:
                                          - /var/lib/docker
                                          - /var/lib/containerd
    docker.engine~docker.engine::terraform@local.machine:
        derived_from: docker.engine
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        attributes:
            application_address:
                type: string
                default: 127.0.0.1
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        terraform:
                            - required_providers:
                                  - mysql:
                                        source: hashicorp/local
                                        version: 2.5.1
                              required_version: '>= 0.14.0'
                        resource:
                            local_file:
                                tmp_service:
                                    content: |
                                        [Unit]
                                        Description=Docker Application Container Engine
                                        Documentation=https://docs.docker.com
                                        After=network-online.target docker.socket firewalld.service containerd.service time-set.target
                                        Wants=network-online.target containerd.service
                                        Requires=docker.socket

                                        [Service]
                                        Type=notify
                                        ExecStart=/usr/bin/dockerd -H fd:// -H tcp://0.0.0.0:2375 --containerd=/run/containerd/containerd.sock
                                        ExecReload=/bin/kill -s HUP $MAINPID
                                        TimeoutStartSec=0
                                        RestartSec=2
                                        Restart=always
                                        StartLimitBurst=3
                                        StartLimitInterval=60s
                                        LimitNPROC=infinity
                                        LimitCORE=infinity
                                        TasksMax=infinity
                                        Delegate=yes
                                        KillMode=process
                                        OOMScoreAdjust=-500

                                        [Install]
                                        WantedBy=multi-user.target
                                    filename: /tmp/docker.service
                            terraform_data:
                                local:
                                    - depends_on: local_file.tmp_service
                                      provisioner:
                                          local-exec:
                                              - inline:
                                                    - curl -sSL https://get.docker.com | sudo sh
                                                    - sudo groupadd -f docker
                                                    - sudo usermod -aG docker {{ SELF.os_ssh_user }}
                                                    - sleep 10s
                                                    - cat /tmp/docker.service | sudo tee /lib/systemd/system/docker.service
                                                    - sudo systemctl daemon-reload
                                                    - sudo systemctl restart docker.service
                                              - inline:
                                                    - sudo apt-get purge docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin docker-ce-rootless-extras -y
                                                    - sudo rm -rf /var/lib/docker
                                                    - sudo rm -rf /var/lib/containerd
                                                when: destroy
    docker.engine~docker.engine::ansible@remote.machine:
        derived_from: docker.engine
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: install docker
                                      ansible.builtin.shell: curl -sSL https://get.docker.com | sh
                                      args:
                                          executable: /usr/bin/bash
                                    - name: update service
                                      ansible.builtin.copy:
                                          dest: /lib/systemd/system/docker.service
                                          content: |
                                              [Unit]
                                              Description=Docker Application Container Engine
                                              Documentation=https://docs.docker.com
                                              After=network-online.target docker.socket firewalld.service containerd.service time-set.target
                                              Wants=network-online.target containerd.service
                                              Requires=docker.socket

                                              [Service]
                                              Type=notify
                                              ExecStart=/usr/bin/dockerd -H fd:// -H tcp://0.0.0.0:2375 --containerd=/run/containerd/containerd.sock
                                              ExecReload=/bin/kill -s HUP $MAINPID
                                              TimeoutStartSec=0
                                              RestartSec=2
                                              Restart=always
                                              StartLimitBurst=3
                                              StartLimitInterval=60s
                                              LimitNPROC=infinity
                                              LimitCORE=infinity
                                              TasksMax=infinity
                                              Delegate=yes
                                              KillMode=process
                                              OOMScoreAdjust=-500

                                              [Install]
                                              WantedBy=multi-user.target
                                    - name: restart service
                                      ansible.builtin.systemd:
                                          name: docker.service
                                          state: restarted
                                          enabled: 'yes'
                                          daemon_reload: 'yes'
                                    - name: add docker group
                                      ansible.builtin.group:
                                          name: docker
                                    - name: add user to docker group
                                      ansible.builtin.user:
                                          name: '{{ SELF.os_ssh_user }}'
                                          groups: docker
                                          append: 'yes'
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: delete docker packages
                                      ansible.builtin.apt:
                                          name:
                                              - docker-ce
                                              - docker-ce-cli
                                              - containerd.io
                                              - docker-buildx-plugin
                                              - docker-compose-plugin
                                              - docker-ce-rootless-extras
                                          state: absent
                                          purge: 'true'
                                          autoremove: 'true'
                                    - name: delete docker directories
                                      ansible.builtin.file:
                                          name: '{{ item }}'
                                          state: absent
                                      loop:
                                          - /var/lib/docker
                                          - /var/lib/containerd
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
    docker.engine~docker.engine::terraform@remote.machine:
        derived_from: docker.engine
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            os_ssh_host:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
        attributes:
            application_address:
                type: string
                default: 127.0.0.1
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        terraform:
                            - required_version: '>= 0.14.0'
                        resource:
                            terraform_data:
                                docker:
                                    - connection:
                                          - host: '{{ SELF.os_ssh_host }}'
                                            private_key: ${file("{{ SELF.os_ssh_key_file }}")}
                                            type: ssh
                                            user: '{{ SELF.os_ssh_user }}'
                                      provisioner:
                                          file:
                                              - content: |
                                                    [Unit]
                                                    Description=Docker Application Container Engine
                                                    Documentation=https://docs.docker.com
                                                    After=network-online.target docker.socket firewalld.service containerd.service time-set.target
                                                    Wants=network-online.target containerd.service
                                                    Requires=docker.socket

                                                    [Service]
                                                    Type=notify
                                                    ExecStart=/usr/bin/dockerd -H fd:// -H tcp://0.0.0.0:2375 --containerd=/run/containerd/containerd.sock
                                                    ExecReload=/bin/kill -s HUP $MAINPID
                                                    TimeoutStartSec=0
                                                    RestartSec=2
                                                    Restart=always
                                                    StartLimitBurst=3
                                                    StartLimitInterval=60s
                                                    LimitNPROC=infinity
                                                    LimitCORE=infinity
                                                    TasksMax=infinity
                                                    Delegate=yes
                                                    KillMode=process
                                                    OOMScoreAdjust=-500

                                                    [Install]
                                                    WantedBy=multi-user.target
                                                destination: /tmp/docker.service
                                          remote-exec:
                                              - inline:
                                                    - curl -sSL https://get.docker.com | sudo sh
                                                    - sudo groupadd -f docker
                                                    - sudo usermod -aG docker {{ SELF.os_ssh_user }}
                                                    - sleep 10s
                                                    - cat /tmp/docker.service | sudo tee /lib/systemd/system/docker.service
                                                    - sudo systemctl daemon-reload
                                                    - sudo systemctl restart docker.service
                                              - inline:
                                                    - sudo apt-get purge docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin docker-ce-rootless-extras -y
                                                    - sudo rm -rf /var/lib/docker
                                                    - sudo rm -rf /var/lib/containerd
                                                when: destroy
    docker.engine~software.application#apt.package::ansible@*->local.machine:
        derived_from: docker.engine
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: run setup script
                                      ansible.builtin.shell: curl -fsSL {{ ".artifacts::apt_package::script" | eval }} | sudo -E bash -
                                      args:
                                          executable: /bin/bash
                                      when: '".artifacts::apt_package::script" | eval != ""'
                                    - name: add apt key
                                      ansible.builtin.apt_key:
                                          url: '{{ ".artifacts::apt_package::key" | eval }}'
                                          keyring: /usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg
                                          state: present
                                      when: '".artifacts::apt_package::key" | eval != ""'
                                    - name: add apt repository
                                      ansible.builtin.apt_repository:
                                          repo: deb [signed-by=/usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg] {{ ".artifacts::apt_package::source" | eval }}
                                          filename: '{{ ".artifacts::apt_package::repository" | eval }}'
                                          state: present
                                      when: '".artifacts::apt_package::source" | eval != ""'
                                    - name: update apt cache
                                      ansible.builtin.apt:
                                          update_cache: 'yes'
                                    - name: install dependencies
                                      ansible.builtin.apt:
                                          name: '{{ ".artifacts::apt_package::dependencies" | eval | split(",") | map("trim") }}'
                                          state: present
                                      when: '".artifacts::apt_package::dependencies" | eval != ""'
                                    - name: install package
                                      ansible.builtin.apt:
                                          name: '{{ ".artifacts::apt_package::file" | eval }}'
                                          state: present
                                      environment: '{{ ".artifacts::apt_package::env" | eval | split | map("split", "=") | community.general.dict }}'
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
                                    - name: uninstall package
                                      ansible.builtin.apt:
                                          name: '{{ ".artifacts::apt_package::file" | eval }}'
                                          state: absent
    docker.engine~software.application#apt.package::terraform@*->local.machine:
        derived_from: docker.engine
        metadata:
            vintner_generated: 'true'
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            local_file:
                                tmp_create:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Run setup script 
                                        if [[ "{{ ".artifacts::apt_package::script" | eval }}" != "" ]]; then 
                                            curl -fsSL {{ ".artifacts::apt_package::script" | eval }} | sudo -E bash -
                                        fi

                                        # Add apt key
                                        if [[ "{{ ".artifacts::apt_package::key" | eval }}" != "" ]]; then 
                                            curl -1sLf {{ ".artifacts::apt_package::key" | eval }} | gpg --dearmor --yes -o /usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg
                                        fi

                                        # Add apt repository
                                        if [[ "{{ ".artifacts::apt_package::source" | eval }}" != "" ]]; then 
                                            echo "deb [signed-by=/usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg] {{ ".artifacts::apt_package::source" | eval }}" | tee {{ ".artifacts::apt_package::repository" | eval }}
                                        fi

                                        # Update apt cache
                                        apt-get update -y

                                        # Install dependencies
                                        if [[ "{{ ".artifacts::apt_package::dependencies" | eval }}" != "" ]]; then 
                                            apt-get install {{ ".artifacts::apt_package::dependencies" | eval | split(",") | map("trim") }} -y
                                        fi

                                        # Install package
                                        {{ ".artifacts::apt_package::env" | eval }} apt-get install {{ ".artifacts::apt_package::file" | eval }} -y

                                        # Create application directory
                                        mkdir -p {{ SELF.application_directory }}

                                        # Create application environment
                                        cat <<EOF > {{ SELF.application_directory }}/.env
                                        APPLICATION_NAME="{{ SELF.application_name }}"
                                        _HOSTING="{{ SELF._hosting }}"
                                        EOF>>

                                        # Create vintner directory
                                        mkdir -p {{ SELF.application_directory }}/.vintner

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/create.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/create.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/create.sh
                                    filename: /tmp/create-docker.engine.sh
                                tmp_configure:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/configure.sh
                                    filename: /tmp/configure-docker.engine.sh
                                tmp_start:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/start.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/start.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/start.sh
                                    filename: /tmp/start-docker.engine.sh
                                tmp_stop:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/stop.sh
                                    filename: /tmp/stop-docker.engine.sh
                                tmp_delete:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/delete.sh

                                        # Delete application directory
                                        rm -rf "{{ SELF.application_directory }}"

                                        # Uninstall package
                                        apt-get uninstall {{ ".artifacts::apt_package::file" | eval }} -y
                                    filename: /tmp/delete-docker.engine.sh
                            terraform_data:
                                local:
                                    - provisioner:
                                          depends_on:
                                              - local_file.tmp_artifact
                                              - local_file.tmp_create
                                              - local_file.tmp_configure
                                              - local_file.tmp_start
                                              - local_file.tmp_stop
                                              - local_file.tmp_delete
                                          local-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-docker.engine.sh
                                                    - sudo bash /tmp/configure-docker.engine.sh
                                                    - sudo bash /tmp/start-docker.engine.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-docker.engine.sh
                                                    - sudo bash /tmp/delete-docker.engine.sh
                                                when: destroy
    docker.engine~software.application#apt.package::ansible@*->remote.machine:
        derived_from: docker.engine
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: run setup script
                                      ansible.builtin.shell: curl -fsSL {{ ".artifacts::apt_package::script" | eval }} | sudo -E bash -
                                      args:
                                          executable: /bin/bash
                                      when: '".artifacts::apt_package::script" | eval != ""'
                                    - name: add apt key
                                      ansible.builtin.apt_key:
                                          url: '{{ ".artifacts::apt_package::key" | eval }}'
                                          keyring: /usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg
                                          state: present
                                      when: '".artifacts::apt_package::key" | eval != ""'
                                    - name: add apt repository
                                      ansible.builtin.apt_repository:
                                          repo: deb [signed-by=/usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg] {{ ".artifacts::apt_package::source" | eval }}
                                          filename: '{{ ".artifacts::apt_package::repository" | eval }}'
                                          state: present
                                      when: '".artifacts::apt_package::source" | eval != ""'
                                    - name: update apt cache
                                      ansible.builtin.apt:
                                          update_cache: 'yes'
                                    - name: install dependencies
                                      ansible.builtin.apt:
                                          name: '{{ ".artifacts::apt_package::dependencies" | eval | split(",") | map("trim") }}'
                                          state: present
                                      when: '".artifacts::apt_package::dependencies" | eval != ""'
                                    - name: install package
                                      ansible.builtin.apt:
                                          name: '{{ ".artifacts::apt_package::file" | eval }}'
                                          state: present
                                      environment: '{{ ".artifacts::apt_package::env" | eval | split | map("split", "=") | community.general.dict }}'
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
                                    - name: uninstall package
                                      ansible.builtin.apt:
                                          name: '{{ ".artifacts::apt_package::file" | eval }}'
                                          state: absent
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
    docker.engine~software.application#apt.package::terraform@*->remote.machine:
        derived_from: docker.engine
        metadata:
            vintner_generated: 'true'
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            os_ssh_host:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            terraform_data:
                                vm:
                                    - connection:
                                          - host: '{{ SELF.os_ssh_host }}'
                                            private_key: ${file("{{ SELF.os_ssh_key_file }}")}
                                            type: ssh
                                            user: '{{ SELF.os_ssh_user }}'
                                      provisioner:
                                          file:
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Run setup script 
                                                    if [[ "{{ ".artifacts::apt_package::script" | eval }}" != "" ]]; then 
                                                        curl -fsSL {{ ".artifacts::apt_package::script" | eval }} | sudo -E bash -
                                                    fi

                                                    # Add apt key
                                                    if [[ "{{ ".artifacts::apt_package::key" | eval }}" != "" ]]; then 
                                                        curl -1sLf {{ ".artifacts::apt_package::key" | eval }} | gpg --dearmor --yes -o /usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg
                                                    fi

                                                    # Add apt repository
                                                    if [[ "{{ ".artifacts::apt_package::source" | eval }}" != "" ]]; then 
                                                        echo "deb [signed-by=/usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg] {{ ".artifacts::apt_package::source" | eval }}" | tee {{ ".artifacts::apt_package::repository" | eval }}
                                                    fi

                                                    # Update apt cache
                                                    apt-get update -y

                                                    # Install dependencies
                                                    if [[ "{{ ".artifacts::apt_package::dependencies" | eval }}" != "" ]]; then 
                                                        apt-get install {{ ".artifacts::apt_package::dependencies" | eval | split(",") | map("trim") }} -y
                                                    fi

                                                    # Install package
                                                    {{ ".artifacts::apt_package::env" | eval }} apt-get install {{ ".artifacts::apt_package::file" | eval }} -y

                                                    # Create application directory
                                                    mkdir -p {{ SELF.application_directory }}

                                                    # Create application environment
                                                    cat <<EOF > {{ SELF.application_directory }}/.env
                                                    APPLICATION_NAME="{{ SELF.application_name }}"
                                                    _HOSTING="{{ SELF._hosting }}"
                                                    EOF>>

                                                    # Create vintner directory
                                                    mkdir -p {{ SELF.application_directory }}/.vintner

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/create.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/create.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/create.sh
                                                destination: /tmp/create-docker.engine.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/configure.sh
                                                destination: /tmp/configure-docker.engine.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/start.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/start.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/start.sh
                                                destination: /tmp/start-docker.engine.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/stop.sh
                                                destination: /tmp/stop-docker.engine.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/delete.sh

                                                    # Delete application directory
                                                    rm -rf "{{ SELF.application_directory }}"

                                                    # Uninstall package
                                                    apt-get uninstall {{ ".artifacts::apt_package::file" | eval }} -y
                                                destination: /tmp/delete-docker.engine.sh
                                          remote-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-docker.engine.sh
                                                    - sudo bash /tmp/configure-docker.engine.sh
                                                    - sudo bash /tmp/start-docker.engine.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-docker.engine.sh
                                                    - sudo bash /tmp/delete-docker.engine.sh
                                                when: destroy
    docker.engine~software.application#tar.archive::ansible@*->local.machine:
        derived_from: docker.engine
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: install operational dependencies
                                      ansible.builtin.apt:
                                          name: unzip
                                          update_cache: 'yes'
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: extract deployment artifact in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          extra_opts: '{{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}'
                                      when: not (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")
                                    - name: extract deployment artifact from URL in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          remote_src: 'yes'
                                          extra_opts: '{{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}'
                                      when: (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")
                                    - name: create vintner directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}/.vintner'
                                          state: directory
                                    - name: create .env file
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.env'
                                          content: |-
                                              APPLICATION_NAME="{{ SELF.application_name }}"
                                              _HOSTING="{{ SELF._hosting }}"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "start" missing
                                      when: SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "stop" missing
                                      when: SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
    docker.engine~software.application#tar.archive::terraform@*->local.machine:
        derived_from: docker.engine
        metadata:
            vintner_generated: 'true'
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            local_file:
                                tmp_artifact:
                                    source: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                    filename: /tmp/artifact-docker.engine
                                    count: '{{ (not (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")) | ternary(1, 0) }}'
                                tmp_create:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Create application directory
                                        mkdir -p {{ SELF.application_directory }}

                                        # Create application environment
                                        cat <<EOF > {{ SELF.application_directory }}/.env
                                        APPLICATION_NAME="{{ SELF.application_name }}"
                                        _HOSTING="{{ SELF._hosting }}"
                                        EOF>>

                                        # Download deployment artifact if required
                                        if [[ "{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}" == http* ]]; then 
                                            wget -O /tmp/artifact-docker.engine {{ ".artifacts::*::[.type=tar.archive]::file" | eval }} 
                                        fi

                                        # Extract deployment artifact
                                        tar -xzf /tmp/artifact-docker.engine -C {{ SELF.application_directory }} {{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}

                                        # Create vintner directory
                                        mkdir -p {{ SELF.application_directory }}/.vintner

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/create.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/create.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/create.sh
                                    filename: /tmp/create-docker.engine.sh
                                tmp_configure:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/configure.sh
                                    filename: /tmp/configure-docker.engine.sh
                                tmp_start:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Assert operation
                                        if [[ "{{ SELF._management_start | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                            echo 'Management operation "start" missing'
                                            exit 1 
                                        fi

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/start.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/start.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/start.sh
                                    filename: /tmp/start-docker.engine.sh
                                tmp_stop:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Assert operation
                                        if [[ "{{ SELF._management_stop | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                            echo 'Management operation "stop" missing'
                                            exit 1 
                                        fi

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/stop.sh
                                    filename: /tmp/stop-docker.engine.sh
                                tmp_delete:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/delete.sh

                                        # Delete application directory
                                        rm -rf "{{ SELF.application_directory }}"
                                    filename: /tmp/delete-docker.engine.sh
                            terraform_data:
                                local:
                                    - depends_on:
                                          - local_file.tmp_artifact
                                          - local_file.tmp_create
                                          - local_file.tmp_configure
                                          - local_file.tmp_start
                                          - local_file.tmp_stop
                                          - local_file.tmp_delete
                                      provisioner:
                                          local-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-docker.engine.sh
                                                    - sudo bash /tmp/configure-docker.engine.sh
                                                    - sudo bash /tmp/start-docker.engine.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-docker.engine.sh
                                                    - sudo bash /tmp/delete-docker.engine.sh
                                                when: destroy
    docker.engine~software.application#tar.archive::ansible@*->remote.machine:
        derived_from: docker.engine
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: extract deployment artifact in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          extra_opts: '{{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}'
                                      when: not (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")
                                    - name: extract deployment artifact from URL in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          remote_src: 'yes'
                                          extra_opts: '{{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}'
                                      when: (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")
                                    - name: create vintner directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}/.vintner'
                                          state: directory
                                    - name: create .env file
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.env'
                                          content: |-
                                              APPLICATION_NAME="{{ SELF.application_name }}"
                                              _HOSTING="{{ SELF._hosting }}"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "start" missing
                                      when: SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "stop" missing
                                      when: SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
    docker.engine~software.application#tar.archive::terraform@*->remote.machine:
        derived_from: docker.engine
        metadata:
            vintner_generated: 'true'
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            os_ssh_host:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            terraform_data:
                                vm:
                                    - connection:
                                          - host: '{{ SELF.os_ssh_host }}'
                                            private_key: ${file("{{ SELF.os_ssh_key_file }}")}
                                            type: ssh
                                            user: '{{ SELF.os_ssh_user }}'
                                      provisioner:
                                          file:
                                              - source: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                                destination: /tmp/artifact-docker.engine
                                                count: '{{ (not (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")) | ternary(1, 0) }}'
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Create application directory
                                                    mkdir -p {{ SELF.application_directory }}

                                                    # Create application environment
                                                    cat <<EOF > {{ SELF.application_directory }}/.env
                                                    APPLICATION_NAME="{{ SELF.application_name }}"
                                                    _HOSTING="{{ SELF._hosting }}"
                                                    EOF>>

                                                    # Download deployment artifact if required
                                                    if [[ "{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}" == http* ]]; then 
                                                        wget -O /tmp/artifact-docker.engine {{ ".artifacts::*::[.type=tar.archive]::file" | eval }} 
                                                    fi

                                                    # Extract deployment artifact
                                                    tar -xzf /tmp/artifact-docker.engine -C {{ SELF.application_directory }} {{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}

                                                    # Create vintner directory
                                                    mkdir -p {{ SELF.application_directory }}/.vintner

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/create.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/create.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/create.sh
                                                destination: /tmp/create-docker.engine.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/configure.sh
                                                destination: /tmp/configure-docker.engine.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Assert operation
                                                    if [[ "{{ SELF._management_start | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                                        echo 'Management operation "start" missing'
                                                        exit 1 
                                                    fi

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/start.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/start.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/start.sh
                                                destination: /tmp/start-docker.engine.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Assert operation
                                                    if [[ "{{ SELF._management_stop | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                                        echo 'Management operation "stop" missing'
                                                        exit 1 
                                                    fi

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/stop.sh
                                                destination: /tmp/stop-docker.engine.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/delete.sh

                                                    # Delete application directory
                                                    rm -rf "{{ SELF.application_directory }}"
                                                destination: /tmp/delete-docker.engine.sh
                                          remote-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-docker.engine.sh
                                                    - sudo bash /tmp/configure-docker.engine.sh
                                                    - sudo bash /tmp/start-docker.engine.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-docker.engine.sh
                                                    - sudo bash /tmp/delete-docker.engine.sh
                                                when: destroy
    docker.engine~software.application#zip.archive::ansible@*->local.machine:
        derived_from: docker.engine
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: install operational dependencies
                                      ansible.builtin.apt:
                                          name: unzip
                                          update_cache: 'yes'
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: extract deployment artifact in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          extra_opts: '{{ ".artifacts::*::[.type=zip.archive]::extra_opts" | eval | map_value }}'
                                      when: not (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")
                                    - name: extract deployment artifact from URL in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          remote_src: 'yes'
                                          extra_opts: '{{ ".artifacts::*::[.type=zip.archive]::extra_opts" | eval | map_value }}'
                                      when: (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")
                                    - name: create vintner directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}/.vintner'
                                          state: directory
                                    - name: create .env file
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.env'
                                          content: |-
                                              APPLICATION_NAME="{{ SELF.application_name }}"
                                              _HOSTING="{{ SELF._hosting }}"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "start" missing
                                      when: SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "stop" missing
                                      when: SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
    docker.engine~software.application#zip.archive::terraform@*->local.machine:
        derived_from: docker.engine
        metadata:
            vintner_generated: 'true'
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            local_file:
                                tmp_artifact:
                                    source: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                    filename: /tmp/artifact-docker.engine
                                    count: '{{ (not (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")) | ternary(1, 0) }}'
                                tmp_create:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Create application directory
                                        mkdir -p {{ SELF.application_directory }}

                                        # Create application environment
                                        cat <<EOF > {{ SELF.application_directory }}/.env
                                        APPLICATION_NAME="{{ SELF.application_name }}"
                                        _HOSTING="{{ SELF._hosting }}"
                                        EOF>>

                                        # Download deployment artifact if required
                                        if [[ "{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}" == http* ]]; then 
                                            wget -O /tmp/artifact-docker.engine {{ ".artifacts::*::[.type=zip.archive]::file" | eval }} 
                                        fi

                                        # Extract deployment artifact
                                        unzip /tmp/artifact-docker.engine -d {{ SELF.application_directory }} {{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}

                                        # Create vintner directory
                                        mkdir -p {{ SELF.application_directory }}/.vintner

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/create.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/create.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/create.sh
                                    filename: /tmp/create-docker.engine.sh
                                tmp_configure:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/configure.sh
                                    filename: /tmp/configure-docker.engine.sh
                                tmp_start:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Assert operation
                                        if [[ "{{ SELF._management_start | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                            echo 'Management operation "start" missing'
                                            exit 1 
                                        fi

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/start.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/start.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/start.sh
                                    filename: /tmp/start-docker.engine.sh
                                tmp_stop:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Assert operation
                                        if [[ "{{ SELF._management_stop | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                            echo 'Management operation "stop" missing'
                                            exit 1 
                                        fi

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/stop.sh
                                    filename: /tmp/stop-docker.engine.sh
                                tmp_delete:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/delete.sh

                                        # Delete application directory
                                        rm -rf "{{ SELF.application_directory }}"
                                    filename: /tmp/delete-docker.engine.sh
                            terraform_data:
                                local:
                                    - depends_on:
                                          - local_file.tmp_artifact
                                          - local_file.tmp_create
                                          - local_file.tmp_configure
                                          - local_file.tmp_start
                                          - local_file.tmp_stop
                                          - local_file.tmp_delete
                                      provisioner:
                                          local-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-docker.engine.sh
                                                    - sudo bash /tmp/configure-docker.engine.sh
                                                    - sudo bash /tmp/start-docker.engine.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-docker.engine.sh
                                                    - sudo bash /tmp/delete-docker.engine.sh
                                                when: destroy
    docker.engine~software.application#zip.archive::ansible@*->remote.machine:
        derived_from: docker.engine
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: install operational dependencies
                                      ansible.builtin.apt:
                                          name: unzip
                                          update_cache: 'yes'
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: extract deployment artifact in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          extra_opts: '{{ ".artifacts::*::[.type=zip.archive]::extra_opts" | eval | map_value }}'
                                      when: not (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")
                                    - name: extract deployment artifact from URL in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          remote_src: 'yes'
                                          extra_opts: '{{ ".artifacts::*::[.type=zip.archive]::extra_opts" | eval | map_value }}'
                                      when: (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")
                                    - name: create vintner directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}/.vintner'
                                          state: directory
                                    - name: create .env file
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.env'
                                          content: |-
                                              APPLICATION_NAME="{{ SELF.application_name }}"
                                              _HOSTING="{{ SELF._hosting }}"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "start" missing
                                      when: SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "stop" missing
                                      when: SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
    docker.engine~software.application#zip.archive::terraform@*->remote.machine:
        derived_from: docker.engine
        metadata:
            vintner_generated: 'true'
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            os_ssh_host:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            terraform_data:
                                vm:
                                    - connection:
                                          - host: '{{ SELF.os_ssh_host }}'
                                            private_key: ${file("{{ SELF.os_ssh_key_file }}")}
                                            type: ssh
                                            user: '{{ SELF.os_ssh_user }}'
                                      provisioner:
                                          file:
                                              - source: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                                destination: /tmp/artifact-docker.engine
                                                count: '{{ (not (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")) | ternary(1, 0) }}'
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Create application directory
                                                    mkdir -p {{ SELF.application_directory }}

                                                    # Create application environment
                                                    cat <<EOF > {{ SELF.application_directory }}/.env
                                                    APPLICATION_NAME="{{ SELF.application_name }}"
                                                    _HOSTING="{{ SELF._hosting }}"
                                                    EOF>>

                                                    # Download deployment artifact if required
                                                    if [[ "{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}" == http* ]]; then 
                                                        wget -O /tmp/artifact-docker.engine {{ ".artifacts::*::[.type=zip.archive]::file" | eval }} 
                                                    fi

                                                    # Extract deployment artifact
                                                    unzip /tmp/artifact-docker.engine -d {{ SELF.application_directory }} {{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}

                                                    # Create vintner directory
                                                    mkdir -p {{ SELF.application_directory }}/.vintner

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/create.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/create.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/create.sh
                                                destination: /tmp/create-docker.engine.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/configure.sh
                                                destination: /tmp/configure-docker.engine.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Assert operation
                                                    if [[ "{{ SELF._management_start | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                                        echo 'Management operation "start" missing'
                                                        exit 1 
                                                    fi

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/start.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/start.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/start.sh
                                                destination: /tmp/start-docker.engine.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Assert operation
                                                    if [[ "{{ SELF._management_stop | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                                        echo 'Management operation "stop" missing'
                                                        exit 1 
                                                    fi

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/stop.sh
                                                destination: /tmp/stop-docker.engine.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/delete.sh

                                                    # Delete application directory
                                                    rm -rf "{{ SELF.application_directory }}"
                                                destination: /tmp/delete-docker.engine.sh
                                          remote-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-docker.engine.sh
                                                    - sudo bash /tmp/configure-docker.engine.sh
                                                    - sudo bash /tmp/start-docker.engine.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-docker.engine.sh
                                                    - sudo bash /tmp/delete-docker.engine.sh
                                                when: destroy
    mysql.dbms~mysql.dbms#dbms.image::ansible@docker.engine->local.machine:
        derived_from: mysql.dbms
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        attributes:
            application_address:
                type: string
                default: 127.0.0.1
            application_port:
                type: string
                default: 3306
            management_address:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
            management_port:
                type: integer
                default: 3306
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: start container
                                      community.docker.docker_container:
                                          name: '{{ SELF.dbms_name }}'
                                          image: mysql:{{ ".artifacts::dbms_image::file" | eval }}
                                          network_mode: host
                                          env:
                                              MYSQL_ROOT_PASSWORD: '{{ SELF.dbms_password | string }}'
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: delete container
                                      community.docker.docker_container:
                                          name: '{{ SELF.dbms_name }}'
                                          state: absent
    mysql.dbms~mysql.dbms#dbms.image::compose@docker.engine->local.machine:
        derived_from: mysql.dbms
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        attributes:
            application_address:
                type: string
                default: 127.0.0.1
            application_port:
                type: integer
                default: 3306
            management_address:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
            management_port:
                type: integer
                default: 3306
        capabilities:
            endpoint:
                type: unfurl.capabilities.Endpoint.Ansible
                properties:
                    connection: ssh
                    host:
                        eval: .parent::management_address
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: touch compose
                                      register: compose
                                      ansible.builtin.tempfile:
                                          suffix: '{{ SELF.dbms_name }}.compose.yaml'
                                    - name: create compose
                                      ansible.builtin.copy:
                                          dest: '{{ compose.path }}'
                                          content: '{{ manifest | to_yaml }}'
                                      vars:
                                          manifest:
                                              name: '{{ SELF.dbms_name }}'
                                              services:
                                                  application:
                                                      container_name: '{{ SELF.dbms_name }}'
                                                      image: mysql:{{ ".artifacts::dbms_image::file" | eval }}
                                                      network_mode: host
                                                      environment:
                                                          MYSQL_ROOT_PASSWORD: '{{ SELF.dbms_password }}'
                                    - name: apply compose
                                      ansible.builtin.shell: docker compose -f {{ compose.path }} up -d
                                      args:
                                          executable: /usr/bin/bash
                                      environment: {}
                                    - name: let it cook
                                      ansible.builtin.pause:
                                          seconds: 10
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: touch compose
                                      register: compose
                                      ansible.builtin.tempfile:
                                          suffix: '{{ SELF.dbms_name }}.compose.yaml'
                                    - name: create compose
                                      ansible.builtin.copy:
                                          dest: '{{ compose.path }}'
                                          content: '{{ manifest | to_yaml }}'
                                      vars:
                                          manifest:
                                              name: '{{ SELF.dbms_name }}'
                                              services:
                                                  application:
                                                      container_name: '{{ SELF.dbms_name }}'
                                                      image: mysql:{{ ".artifacts::dbms_image::file" | eval }}
                                                      network_mode: host
                                                      environment:
                                                          MYSQL_ROOT_PASSWORD: '{{ SELF.dbms_password }}'
                                    - name: unapply compose
                                      ansible.builtin.shell: docker compose -f {{ compose.path }} down
                                      args:
                                          executable: /usr/bin/bash
                                      environment: {}
    mysql.dbms~mysql.dbms#dbms.image::terraform@docker.engine->local.machine:
        derived_from: mysql.dbms
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        attributes:
            application_address:
                type: string
                default: 127.0.0.1
            application_port:
                type: integer
                default: 3306
            management_address:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
            management_port:
                type: integer
                default: 3306
        capabilities:
            endpoint:
                type: unfurl.capabilities.Endpoint.Ansible
                properties:
                    connection: ssh
                    host:
                        eval: .parent::management_address
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        terraform:
                            - required_providers:
                                  - docker:
                                        source: kreuzwerker/docker
                                        version: 3.0.2
                        provider:
                            docker:
                                - host: unix:///var/run/docker.sock
                        resource:
                            docker_container:
                                application:
                                    - name: '{{ SELF.dbms_name }}'
                                      image: ${docker_image.image.image_id}
                                      network_mode: host
                                      env:
                                          - MYSQL_ROOT_PASSWORD={{ SELF.dbms_password }}
                            docker_image:
                                image:
                                    - name: mysql:{{ ".artifacts::dbms_image::file" | eval }}
    mysql.dbms~mysql.dbms#dbms.image::ansible@docker.engine->remote.machine:
        derived_from: mysql.dbms
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
        attributes:
            application_address:
                type: string
                default: 127.0.0.1
            application_port:
                type: string
                default: 3306
            management_address:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
            management_port:
                type: integer
                default: 3306
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: start container
                                      community.docker.docker_container:
                                          name: '{{ SELF.dbms_name }}'
                                          image: mysql:{{ ".artifacts::dbms_image::file" | eval }}
                                          network_mode: host
                                          env:
                                              MYSQL_ROOT_PASSWORD: '{{ SELF.dbms_password | string }}'
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: stop container
                                      community.docker.docker_container:
                                          name: '{{ SELF.application_name }}'
                                          state: absent
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
    mysql.dbms~mysql.dbms#dbms.image::compose@docker.engine->remote.machine:
        derived_from: mysql.dbms
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            os_ssh_host:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
        attributes:
            application_address:
                type: string
                default: 127.0.0.1
            application_port:
                type: integer
                default: 3306
            management_address:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
            management_port:
                type: integer
                default: 3306
        capabilities:
            endpoint:
                type: unfurl.capabilities.Endpoint.Ansible
                properties:
                    connection: ssh
                    host:
                        eval: .parent::management_address
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: touch compose
                                      register: compose
                                      ansible.builtin.tempfile:
                                          suffix: '{{ SELF.dbms_name }}.compose.yaml'
                                    - name: create compose
                                      ansible.builtin.copy:
                                          dest: '{{ compose.path }}'
                                          content: '{{ manifest | to_yaml }}'
                                      vars:
                                          manifest:
                                              name: '{{ SELF.dbms_name }}'
                                              services:
                                                  application:
                                                      container_name: '{{ SELF.dbms_name }}'
                                                      image: mysql:{{ ".artifacts::dbms_image::file" | eval }}
                                                      network_mode: host
                                                      environment:
                                                          MYSQL_ROOT_PASSWORD: '{{ SELF.dbms_password }}'
                                    - name: add ssh credentials
                                      community.general.ssh_config:
                                          user: "{{ lookup('env', 'USER') }}"
                                          host: '{{ SELF.os_ssh_host }}'
                                          remote_user: '{{ SELF.os_ssh_user }}'
                                          identity_file: '{{ SELF.os_ssh_key_file }}'
                                          strict_host_key_checking: 'no'
                                          user_known_hosts_file: /dev/null
                                    - name: apply compose
                                      ansible.builtin.shell: docker compose -f {{ compose.path }} up -d
                                      args:
                                          executable: /usr/bin/bash
                                      environment:
                                          DOCKER_HOST: ssh://{{ SELF.os_ssh_host }}
                                    - name: let it cook
                                      ansible.builtin.pause:
                                          seconds: 10
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: touch compose
                                      register: compose
                                      ansible.builtin.tempfile:
                                          suffix: '{{ SELF.dbms_name }}.compose.yaml'
                                    - name: create compose
                                      ansible.builtin.copy:
                                          dest: '{{ compose.path }}'
                                          content: '{{ manifest | to_yaml }}'
                                      vars:
                                          manifest:
                                              name: '{{ SELF.dbms_name }}'
                                              services:
                                                  application:
                                                      container_name: '{{ SELF.dbms_name }}'
                                                      image: mysql:{{ ".artifacts::dbms_image::file" | eval }}
                                                      network_mode: host
                                                      environment:
                                                          MYSQL_ROOT_PASSWORD: '{{ SELF.dbms_password }}'
                                    - name: unapply compose
                                      ansible.builtin.shell: docker compose -f {{ compose.path }} down
                                      args:
                                          executable: /usr/bin/bash
                                      environment:
                                          DOCKER_HOST: ssh://{{ SELF.os_ssh_host }}
                                    - name: remove ssh credentials
                                      community.general.ssh_config:
                                          user: "{{ lookup('env', 'USER') }}"
                                          host: '{{ SELF.os_ssh_host }}'
                                          state: absent
    mysql.dbms~mysql.dbms#dbms.image::terraform@docker.engine->remote.machine:
        derived_from: mysql.dbms
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            os_ssh_host:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
        attributes:
            application_address:
                type: string
                default: 127.0.0.1
            application_port:
                type: integer
                default: 3306
            management_address:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
            management_port:
                type: integer
                default: 3306
        capabilities:
            endpoint:
                type: unfurl.capabilities.Endpoint.Ansible
                properties:
                    connection: ssh
                    host:
                        eval: .parent::management_address
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        terraform:
                            - required_providers:
                                  - docker:
                                        source: kreuzwerker/docker
                                        version: 3.0.2
                              required_version: '>= 0.14.0'
                        provider:
                            docker:
                                - host: ssh://{{ SELF.os_ssh_user }}@{{ SELF.os_ssh_host }}:22
                                  ssh_opts:
                                      - '-i'
                                      - '{{ SELF.os_ssh_key_file }}'
                                      - '-o'
                                      - IdentitiesOnly=yes
                                      - '-o'
                                      - BatchMode=yes
                                      - '-o'
                                      - UserKnownHostsFile=/dev/null
                                      - '-o'
                                      - StrictHostKeyChecking=no
                        resource:
                            docker_container:
                                application:
                                    - name: '{{ SELF.dbms_name }}'
                                      image: ${docker_image.image.image_id}
                                      network_mode: host
                                      env:
                                          - MYSQL_ROOT_PASSWORD={{ SELF.dbms_password }}
                            docker_image:
                                image:
                                    - name: mysql:{{ ".artifacts::dbms_image::file" | eval }}
    mysql.dbms~mysql.dbms#dbms.image::ansible@gcp.cloudsql:
        derived_from: mysql.dbms
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            gcp_service_account_file:
                type: string
                default:
                    get_input: gcp_service_account_file
            gcp_region:
                type: string
                default:
                    get_input: gcp_region
            gcp_project:
                type: string
                default:
                    get_input: gcp_project
            dbms_ssl_mode:
                type: string
                default: Preferred
        attributes:
            application_port:
                type: string
                default: 3306
            management_address:
                type: string
                default:
                    eval: .::application_address
            management_port:
                type: integer
                default:
                    eval: .::application_port
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                            environment:
                                GCP_SERVICE_ACCOUNT_FILE:
                                    eval: .::gcp_service_account_file
                                GCP_AUTH_KIND: serviceaccount
                        inputs:
                            playbook:
                                q:
                                    - name: create a instance
                                      register: instance_info
                                      google.cloud.gcp_sql_instance:
                                          name: '{{  SELF.dbms_name }}'
                                          database_version: MYSQL_{{ ".artifacts::dbms_image::file" | eval | replace(".", "_") }}
                                          settings:
                                              tier: db-f1-micro
                                              availability_type: REGIONAL
                                              backup_configuration:
                                                  binary_log_enabled: true
                                                  enabled: true
                                              ip_configuration:
                                                  authorized_networks:
                                                      - value: 0.0.0.0/0
                                          region: '{{ SELF.gcp_region }}'
                                          project: '{{ SELF.gcp_project }}'
                                    - name: set root password
                                      google.cloud.gcp_sql_user:
                                          name: root
                                          host: '%'
                                          password: '{{ SELF.dbms_password }}'
                                          instance: '{{ instance_info }}'
                                          project: '{{ SELF.gcp_project }}'
                                    - name: aet attributes
                                      set_fact:
                                          application_address: '{{ instance_info.ipAddresses[0].ipAddress | trim }}'
                            resultTemplate: |
                                name: SELF
                                attributes:
                                    application_address: '{{ outputs.application_address }}'
                        outputs:
                            application_address:
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: Activate service account
                                      ansible.builtin.shell: gcloud auth activate-service-account --key-file {{ SELF.gcp_service_account_file }} --project {{ SELF.gcp_project }}
                                      args:
                                          executable: /bin/bash
                                    - name: Delete Instance
                                      ansible.builtin.shell: gcloud sql instances delete {{ SELF.dbms_name }} --quiet
                                      args:
                                          executable: /bin/bash
    mysql.dbms~mysql.dbms#dbms.image::terraform@gcp.cloudsql:
        derived_from: mysql.dbms
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            gcp_service_account_file:
                type: string
                default:
                    get_input: gcp_service_account_file
            gcp_region:
                type: string
                default:
                    get_input: gcp_region
            gcp_project:
                type: string
                default:
                    get_input: gcp_project
            dbms_ssl_mode:
                type: string
                default: Preferred
        attributes:
            application_port:
                type: string
                default: 3306
            management_address:
                type: string
                default:
                    eval: .::application_address
            management_port:
                type: integer
                default:
                    eval: .::application_port
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                outputs:
                    application_address: application_address
                inputs:
                    main:
                        terraform:
                            - required_providers:
                                  - google:
                                        source: hashicorp/google
                                        version: 4.67.0
                        provider:
                            google:
                                - credentials: '{{ SELF.gcp_service_account_file }}'
                                  project: '{{ SELF.gcp_project }}'
                                  region: '{{ SELF.gcp_region }}'
                        output:
                            application_address:
                                - value: ${google_sql_database_instance.dbms.public_ip_address}
                        resource:
                            google_sql_database_instance:
                                dbms:
                                    - database_version: MYSQL_{{ ".artifacts::dbms_image::file" | eval | replace(".", "_") }}
                                      deletion_protection: false
                                      name: '{{ SELF.dbms_name }}'
                                      root_password: '{{ SELF.dbms_password }}'
                                      settings:
                                          - availability_type: REGIONAL
                                            backup_configuration:
                                                - binary_log_enabled: true
                                                  enabled: true
                                            ip_configuration:
                                                - authorized_networks:
                                                      - name: public
                                                        value: 0.0.0.0/0
                                                  ipv4_enabled: true
                                            tier: db-f1-micro
                            google_sql_user:
                                user:
                                    - host: '%'
                                      instance: ${google_sql_database_instance.dbms.name}
                                      name: root
                                      password: ${google_sql_database_instance.dbms.root_password}
    mysql.dbms~mysql.dbms#dbms.image::ansible@kubernetes.cluster:
        derived_from: mysql.dbms
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            k8s_host:
                type: string
                default:
                    get_input: k8s_host
            k8s_ca_cert_file:
                type: string
                default:
                    get_input: k8s_ca_cert_file
            k8s_client_cert_file:
                type: string
                default:
                    get_input: k8s_client_cert_file
            k8s_client_key_file:
                type: string
                default:
                    get_input: k8s_client_key_file
        attributes:
            application_address:
                type: string
                default:
                    eval: .::dbms_name
            application_port:
                type: integer
                default: 3306
            management_address:
                type: string
                default:
                    eval: .::application_address
            management_port:
                type: integer
                default:
                    eval: .::application_port
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                            environment:
                                K8S_AUTH_HOST:
                                    eval: .::k8s_host
                                K8S_AUTH_SSL_CA_CERT:
                                    eval: .::k8s_ca_cert_file
                                K8S_AUTH_CERT_FILE:
                                    eval: .::k8s_client_cert_file
                                K8S_AUTH_KEY_FILE:
                                    eval: .::k8s_client_key_file
                        inputs:
                            playbook:
                                q:
                                    - name: create deployment
                                      kubernetes.core.k8s:
                                          wait: true
                                          definition:
                                              apiVersion: apps/v1
                                              kind: Deployment
                                              metadata:
                                                  name: '{{ SELF.dbms_name }}'
                                                  namespace: default
                                              spec:
                                                  selector:
                                                      matchLabels:
                                                          app: '{{ SELF.dbms_name }}'
                                                  template:
                                                      metadata:
                                                          labels:
                                                              app: '{{ SELF.dbms_name }}'
                                                      spec:
                                                          containers:
                                                              - image: mysql:{{ ".artifacts::dbms_image::file" | eval }}
                                                                name: '{{ SELF.dbms_name }}'
                                                                env:
                                                                    - name: MYSQL_ROOT_PASSWORD
                                                                      value: '{{ SELF.dbms_password }}'
                                                                ports:
                                                                    - containerPort: 3306
                                                                      name: mysql
                                    - name: create service
                                      kubernetes.core.k8s:
                                          definition:
                                              apiVersion: v1
                                              kind: Service
                                              metadata:
                                                  name: '{{ SELF.dbms_name }}'
                                                  namespace: default
                                              spec:
                                                  ports:
                                                      - name: mysql
                                                        port: 3306
                                                        targetPort: 3306
                                                  selector:
                                                      app: '{{ SELF.dbms_name }}'
                                                  type: ClusterIP
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                            environment:
                                K8S_AUTH_HOST:
                                    eval: .::k8s_host
                                K8S_AUTH_SSL_CA_CERT:
                                    eval: .::k8s_ca_cert_file
                                K8S_AUTH_CERT_FILE:
                                    eval: .::k8s_client_cert_file
                                K8S_AUTH_KEY_FILE:
                                    eval: .::k8s_client_key_file
                        inputs:
                            playbook:
                                q:
                                    - name: delete service
                                      kubernetes.core.k8s:
                                          state: absent
                                          api_version: v1
                                          kind: Service
                                          name: '{{ SELF.dbms_name }}'
                                          namespace: default
                                    - name: delete deployment
                                      kubernetes.core.k8s:
                                          state: absent
                                          api_version: apps/v1
                                          kind: Deployment
                                          name: '{{ SELF.dbms_name }}'
                                          namespace: default
    mysql.dbms~mysql.dbms#dbms.image::kubernetes@kubernetes.cluster:
        derived_from: mysql.dbms
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            k8s_host:
                type: string
                default:
                    get_input: k8s_host
            k8s_ca_cert_file:
                type: string
                default:
                    get_input: k8s_ca_cert_file
            k8s_client_cert_file:
                type: string
                default:
                    get_input: k8s_client_cert_file
            k8s_client_key_file:
                type: string
                default:
                    get_input: k8s_client_key_file
        attributes:
            application_address:
                type: string
                default:
                    eval: .::dbms_name
            application_port:
                type: integer
                default: 3306
            management_address:
                type: string
                default:
                    eval: .::application_address
            management_port:
                type: integer
                default:
                    eval: .::application_port
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: touch manifest
                                      register: manifest
                                      ansible.builtin.tempfile:
                                          suffix: '{{ SELF.dbms_name }}.dbms.manifest.yaml'
                                    - name: create manifest
                                      ansible.builtin.copy:
                                          dest: '{{ manifest.path }}'
                                          content: |
                                              {{ deployment | to_yaml }}
                                              ---
                                              {{ service | to_yaml }}
                                      vars:
                                          deployment:
                                              apiVersion: apps/v1
                                              kind: Deployment
                                              metadata:
                                                  name: '{{ SELF.dbms_name }}'
                                                  namespace: default
                                              spec:
                                                  selector:
                                                      matchLabels:
                                                          app: '{{ SELF.dbms_name }}'
                                                  template:
                                                      metadata:
                                                          labels:
                                                              app: '{{ SELF.dbms_name }}'
                                                      spec:
                                                          containers:
                                                              - image: mysql:{{ ".artifacts::dbms_image::file" | eval }}
                                                                name: '{{ SELF.dbms_name }}'
                                                                env:
                                                                    - name: MYSQL_ROOT_PASSWORD
                                                                      value: '{{ SELF.dbms_password }}'
                                                                ports:
                                                                    - containerPort: 3306
                                                                      name: mysql
                                          service:
                                              apiVersion: v1
                                              kind: Service
                                              metadata:
                                                  name: '{{ SELF.dbms_name }}'
                                              spec:
                                                  ports:
                                                      - name: mysql
                                                        port: 3306
                                                        targetPort: 3306
                                                  selector:
                                                      app: '{{ SELF.dbms_name }}'
                                                  type: ClusterIP
                                    - name: apply manifest
                                      ansible.builtin.shell: kubectl --server {{ SELF.k8s_host }} --certificate-authority {{ SELF.k8s_ca_cert_file }} --client-certificate {{ SELF.k8s_client_cert_file }} --client-key {{ SELF.k8s_client_key_file }} apply -f {{ manifest.path }}
                                      args:
                                          executable: /usr/bin/bash
                                    - name: wait for deployment
                                      ansible.builtin.shell: kubectl --server {{ SELF.k8s_host }} --certificate-authority {{ SELF.k8s_ca_cert_file }} --client-certificate {{ SELF.k8s_client_cert_file }} --client-key {{ SELF.k8s_client_key_file }} rollout status deployment/{{ SELF.dbms_name }} --timeout 60s
                                      args:
                                          executable: /usr/bin/bash
                                    - name: let it cook
                                      ansible.builtin.pause:
                                          seconds: 10
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: touch manifest
                                      register: manifest
                                      ansible.builtin.tempfile:
                                          suffix: '{{ SELF.dbms_name }}.dbms.manifest.yaml'
                                    - name: create manifest
                                      ansible.builtin.copy:
                                          dest: '{{ manifest.path }}'
                                          content: |
                                              {{ deployment | to_yaml }}
                                              ---
                                              {{ service | to_yaml }}
                                      vars:
                                          deployment:
                                              apiVersion: apps/v1
                                              kind: Deployment
                                              metadata:
                                                  name: '{{ SELF.dbms_name }}'
                                                  namespace: default
                                              spec:
                                                  selector:
                                                      matchLabels:
                                                          app: '{{ SELF.dbms_name }}'
                                                  template:
                                                      metadata:
                                                          labels:
                                                              app: '{{ SELF.dbms_name }}'
                                                      spec:
                                                          containers:
                                                              - image: mysql:{{ ".artifacts::dbms_image::file" | eval }}
                                                                name: '{{ SELF.dbms_name }}'
                                                                env:
                                                                    - name: MYSQL_ROOT_PASSWORD
                                                                      value: '{{ SELF.dbms_password }}'
                                                                ports:
                                                                    - containerPort: 3306
                                                                      name: mysql
                                          service:
                                              apiVersion: v1
                                              kind: Service
                                              metadata:
                                                  name: '{{ SELF.dbms_name }}'
                                              spec:
                                                  ports:
                                                      - name: mysql
                                                        port: 3306
                                                        targetPort: 3306
                                                  selector:
                                                      app: '{{ SELF.dbms_name }}'
                                                  type: ClusterIP
                                    - name: unapply manifest
                                      ansible.builtin.shell: kubectl --server {{ SELF.k8s_host }} --certificate-authority {{ SELF.k8s_ca_cert_file }} --client-certificate {{ SELF.k8s_client_cert_file }} --client-key {{ SELF.k8s_client_key_file }} delete -f {{ manifest.path }}
                                      args:
                                          executable: /usr/bin/bash
    mysql.dbms~mysql.dbms#dbms.image::terraform@kubernetes.cluster:
        derived_from: mysql.dbms
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            k8s_host:
                type: string
                default:
                    get_input: k8s_host
            k8s_ca_cert_file:
                type: string
                default:
                    get_input: k8s_ca_cert_file
            k8s_client_cert_file:
                type: string
                default:
                    get_input: k8s_client_cert_file
            k8s_client_key_file:
                type: string
                default:
                    get_input: k8s_client_key_file
        attributes:
            application_address:
                type: string
                default:
                    eval: .::dbms_name
            application_port:
                type: integer
                default: 3306
            management_address:
                type: string
                default:
                    eval: .::application_address
            management_port:
                type: integer
                default:
                    eval: .::application_port
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        terraform:
                            - required_providers:
                                  - kubernetes:
                                        source: hashicorp/kubernetes
                                        version: 2.31.0
                              required_version: '>= 0.14.0'
                        provider:
                            kubernetes:
                                - client_certificate: ${file("{{ SELF.k8s_client_cert_file }}")}
                                  client_key: ${file("{{ SELF.k8s_client_key_file }}")}
                                  cluster_ca_certificate: ${file("{{ SELF.k8s_ca_cert_file }}")}
                                  host: '{{ SELF.k8s_host }}'
                        resource:
                            kubernetes_deployment_v1:
                                application:
                                    - metadata:
                                          - name: '{{ SELF.dbms_name }}'
                                      spec:
                                          - selector:
                                                - match_labels:
                                                      app: '{{ SELF.dbms_name }}'
                                            template:
                                                - metadata:
                                                      - labels:
                                                            app: '{{ SELF.dbms_name }}'
                                                  spec:
                                                      - container:
                                                            - name: '{{ SELF.dbms_name }}'
                                                              image: mysql:{{ ".artifacts::dbms_image::file" | eval }}
                                                              env:
                                                                  - name: MYSQL_ROOT_PASSWORD
                                                                    value: '{{ SELF.dbms_password }}'
                                                              port:
                                                                  - container_port: 3306
                                                                    name: mysql
                            kubernetes_service_v1:
                                application:
                                    - metadata:
                                          - name: '{{ SELF.dbms_name }}'
                                      spec:
                                          - port:
                                                - name: mysql
                                                  port: 3306
                                                  target_port: 3306
                                            selector:
                                                app: '{{ SELF.dbms_name }}'
                                            type: ClusterIP
    mysql.dbms~mysql.dbms#dbms.image::ansible@local.machine:
        derived_from: mysql.dbms
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            application_port:
                type: string
                default: 3001
            application_address:
                type: string
                default: 127.0.0.1
        attributes:
            management_address:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
            management_port:
                type: integer
                default:
                    eval: .::application_port
        capabilities:
            endpoint:
                type: unfurl.capabilities.Endpoint.Ansible
                properties:
                    connection: ssh
                    host:
                        eval: .parent::management_address
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: installing mysql
                                      ansible.builtin.apt:
                                          name:
                                              - mysql-server
                                              - mysql-client
                                              - python3-mysqldb
                                              - libmysqlclient-dev
                                          state: present
                                          update_cache: 'yes'
                                    - name: start and enable mysql service
                                      ansible.builtin.systemd:
                                          name: mysql
                                          state: started
                                          enabled: 'yes'
                                    - name: enable passwordless login
                                      ansible.builtin.copy:
                                          dest: '{{ item }}'
                                          content: |
                                              [client]
                                              user=root
                                              password={{ SELF.dbms_password }}
                                      loop:
                                          - /root/.my.cnf
                                          - /home/{{ SELF.os_ssh_user }}/.my.cnf
                                    - name: configure port (e.g., since 3306 is blocked by the provider)
                                      ansible.builtin.lineinfile:
                                          path: /etc/mysql/mysql.conf.d/mysqld.cnf
                                          regexp: ^# port
                                          line: port = {{ SELF.application_port }}
                                          backup: 'yes'
                                    - name: enable remote login
                                      ansible.builtin.lineinfile:
                                          path: /etc/mysql/mysql.conf.d/mysqld.cnf
                                          regexp: ^bind-address
                                          line: bind-address = 0.0.0.0
                                          backup: 'yes'
                                    - name: restart mysql
                                      ansible.builtin.systemd:
                                          name: mysql
                                          state: restarted
                                    - name: create all root
                                      community.mysql.mysql_user:
                                          name: root
                                          password: '{{ SELF.dbms_password }}'
                                          priv: '*.*:ALL'
                                          host: '%'
                                          state: present
                                          login_host: localhost
                                          login_password: '{{ SELF.dbms_password }}'
                                          login_port: '{{ SELF.application_port }}'
                                          login_user: root
                                    - name: delete localhost root
                                      community.mysql.mysql_user:
                                          name: root
                                          host: localhost
                                          state: absent
                                          login_host: localhost
                                          login_password: '{{ SELF.dbms_password }}'
                                          login_port: '{{ SELF.application_port }}'
                                          login_user: root
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: uninstalling mysql
                                      ansible.builtin.apt:
                                          name:
                                              - mysql-server
                                              - mysql-client
                                              - python3-mysqldb
                                              - libmysqlclient-dev
                                          state: absent
                                    - name: remove passwordless login
                                      ansible.builtin.file:
                                          name: '{{ item }}'
                                          state: absent
                                      loop:
                                          - /root/.my.cnf
                                          - /home/{{ SELF.os_ssh_user }}/.my.cnf
    mysql.dbms~mysql.dbms#dbms.image::terraform@local.machine:
        derived_from: mysql.dbms
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            application_port:
                type: string
                default: 3001
            application_address:
                type: string
                default: 127.0.0.1
        attributes:
            management_address:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
            management_port:
                type: integer
                default:
                    eval: .::application_port
        capabilities:
            endpoint:
                type: unfurl.capabilities.Endpoint.Ansible
                properties:
                    connection: ssh
                    host:
                        eval: .parent::management_address
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            local_file:
                                tmp_script:
                                    content: |

                                        #!/usr/bin/bash
                                        set -e
                                        export DEBIAN_FRONTEND="noninteractive"

                                        DBMS_PASSWORD=$1
                                        DBMS_PORT=$2

                                        # Set password
                                        debconf-set-selections <<< "mysql-server mysql-server/root_password password ${DBMS_PASSWORD}"
                                        debconf-set-selections <<< "mysql-server mysql-server/root_password_again password ${DBMS_PASSWORD}"

                                        # Install mysql
                                        apt-get update -y
                                        apt-get -y install mysql-server

                                        # Passwordless auth
                                        cat <<EOF > /root/.my.cnf
                                        [client]
                                        user=root
                                        password=${DBMS_PASSWORD}
                                        EOF

                                        # Listen on all interfaces
                                        sed -i "s/127\.0\.0\.1/0\.0\.0\.0/g" /etc/mysql/mysql.conf.d/mysqld.cnf

                                        # Listen on custom port
                                        sed -i "s/# port.*/port = ${DBMS_PORT}/g" /etc/mysql/mysql.conf.d/mysqld.cnf

                                        # Configure any host for root
                                        mysql -u root -e 'USE mysql; UPDATE user SET host = "%" WHERE user = "root"; FLUSH PRIVILEGES;'
                                        mysql -u root -e 'USE mysql; DELETE FROM user WHERE user = "root" and host = "localhost"; FLUSH PRIVILEGES;'

                                        # Enable service
                                        systemctl enable mysql

                                        # Restart service
                                        systemctl restart mysql
                                    filename: /tmp/install-mysql-dbms.sh
                            terraform_data:
                                local:
                                    - depends_on: local_file.tmp_script
                                      provisioner:
                                          local-exec:
                                              - inline:
                                                    - sudo bash /tmp/install-mysql-dbms.sh {{ SELF.dbms_password }} {{ SELF.application_port }}
    mysql.dbms~mysql.dbms#dbms.image::ansible@remote.machine:
        derived_from: mysql.dbms
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            application_port:
                type: string
                default: 3001
            application_address:
                type: string
                default: 127.0.0.1
        attributes:
            management_address:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
            management_port:
                type: integer
                default:
                    eval: .::application_port
        capabilities:
            endpoint:
                type: unfurl.capabilities.Endpoint.Ansible
                properties:
                    connection: ssh
                    host:
                        eval: .parent::management_address
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: installing mysql
                                      ansible.builtin.apt:
                                          name:
                                              - mysql-server
                                              - mysql-client
                                              - python3-mysqldb
                                              - libmysqlclient-dev
                                          state: present
                                          update_cache: 'yes'
                                    - name: start and enable mysql service
                                      ansible.builtin.systemd:
                                          name: mysql
                                          state: started
                                          enabled: 'yes'
                                    - name: enable passwordless login
                                      ansible.builtin.copy:
                                          dest: '{{ item }}'
                                          content: |
                                              [client]
                                              user=root
                                              password={{ SELF.dbms_password }}
                                      loop:
                                          - /root/.my.cnf
                                          - /home/{{ SELF.os_ssh_user }}/.my.cnf
                                    - name: configure port (e.g., since 3306 is blocked by the provider)
                                      ansible.builtin.lineinfile:
                                          path: /etc/mysql/mysql.conf.d/mysqld.cnf
                                          regexp: ^# port
                                          line: port = {{ SELF.application_port }}
                                          backup: 'yes'
                                    - name: enable remote login
                                      ansible.builtin.lineinfile:
                                          path: /etc/mysql/mysql.conf.d/mysqld.cnf
                                          regexp: ^bind-address
                                          line: bind-address = 0.0.0.0
                                          backup: 'yes'
                                    - name: restart mysql
                                      ansible.builtin.systemd:
                                          name: mysql
                                          state: restarted
                                    - name: create all root
                                      community.mysql.mysql_user:
                                          name: root
                                          password: '{{ SELF.dbms_password }}'
                                          priv: '*.*:ALL'
                                          host: '%'
                                          state: present
                                          login_host: localhost
                                          login_password: '{{ SELF.dbms_password }}'
                                          login_port: '{{ SELF.application_port }}'
                                          login_user: root
                                    - name: delete localhost root
                                      community.mysql.mysql_user:
                                          name: root
                                          host: localhost
                                          state: absent
                                          login_host: localhost
                                          login_password: '{{ SELF.dbms_password }}'
                                          login_port: '{{ SELF.application_port }}'
                                          login_user: root
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: uninstalling mysql
                                      ansible.builtin.apt:
                                          name:
                                              - mysql-server
                                              - mysql-client
                                              - python3-mysqldb
                                              - libmysqlclient-dev
                                          state: absent
                                    - name: remove passwordless login
                                      ansible.builtin.file:
                                          name: '{{ item }}'
                                          state: absent
                                      loop:
                                          - /root/.my.cnf
                                          - /home/{{ SELF.os_ssh_user }}/.my.cnf
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
    mysql.dbms~mysql.dbms#dbms.image::terraform@remote.machine:
        derived_from: mysql.dbms
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            os_ssh_host:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
            application_port:
                type: string
                default: 3001
            application_address:
                type: string
                default: 127.0.0.1
        attributes:
            management_address:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
            management_port:
                type: integer
                default:
                    eval: .::application_port
        capabilities:
            endpoint:
                type: unfurl.capabilities.Endpoint.Ansible
                properties:
                    connection: ssh
                    host:
                        eval: .parent::management_address
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            terraform_data:
                                vm:
                                    - connection:
                                          - host: '{{ SELF.os_ssh_host }}'
                                            private_key: ${file("{{ SELF.os_ssh_key_file }}")}
                                            type: ssh
                                            user: '{{ SELF.os_ssh_user }}'
                                      provisioner:
                                          file:
                                              - content: |

                                                    #!/usr/bin/bash
                                                    set -e
                                                    export DEBIAN_FRONTEND="noninteractive"

                                                    DBMS_PASSWORD=$1
                                                    DBMS_PORT=$2

                                                    # Set password
                                                    debconf-set-selections <<< "mysql-server mysql-server/root_password password ${DBMS_PASSWORD}"
                                                    debconf-set-selections <<< "mysql-server mysql-server/root_password_again password ${DBMS_PASSWORD}"

                                                    # Install mysql
                                                    apt-get update -y
                                                    apt-get -y install mysql-server

                                                    # Passwordless auth
                                                    cat <<EOF > /root/.my.cnf
                                                    [client]
                                                    user=root
                                                    password=${DBMS_PASSWORD}
                                                    EOF

                                                    # Listen on all interfaces
                                                    sed -i "s/127\.0\.0\.1/0\.0\.0\.0/g" /etc/mysql/mysql.conf.d/mysqld.cnf

                                                    # Listen on custom port
                                                    sed -i "s/# port.*/port = ${DBMS_PORT}/g" /etc/mysql/mysql.conf.d/mysqld.cnf

                                                    # Configure any host for root
                                                    mysql -u root -e 'USE mysql; UPDATE user SET host = "%" WHERE user = "root"; FLUSH PRIVILEGES;'
                                                    mysql -u root -e 'USE mysql; DELETE FROM user WHERE user = "root" and host = "localhost"; FLUSH PRIVILEGES;'

                                                    # Enable service
                                                    systemctl enable mysql

                                                    # Restart service
                                                    systemctl restart mysql
                                                destination: /tmp/install-mysql-dbms.sh
                                          remote-exec:
                                              - inline:
                                                    - sudo bash /tmp/install-mysql-dbms.sh {{ SELF.dbms_password }} {{ SELF.application_port }}
    mysql.dbms~software.application#apt.package::ansible@*->local.machine:
        derived_from: mysql.dbms
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: run setup script
                                      ansible.builtin.shell: curl -fsSL {{ ".artifacts::apt_package::script" | eval }} | sudo -E bash -
                                      args:
                                          executable: /bin/bash
                                      when: '".artifacts::apt_package::script" | eval != ""'
                                    - name: add apt key
                                      ansible.builtin.apt_key:
                                          url: '{{ ".artifacts::apt_package::key" | eval }}'
                                          keyring: /usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg
                                          state: present
                                      when: '".artifacts::apt_package::key" | eval != ""'
                                    - name: add apt repository
                                      ansible.builtin.apt_repository:
                                          repo: deb [signed-by=/usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg] {{ ".artifacts::apt_package::source" | eval }}
                                          filename: '{{ ".artifacts::apt_package::repository" | eval }}'
                                          state: present
                                      when: '".artifacts::apt_package::source" | eval != ""'
                                    - name: update apt cache
                                      ansible.builtin.apt:
                                          update_cache: 'yes'
                                    - name: install dependencies
                                      ansible.builtin.apt:
                                          name: '{{ ".artifacts::apt_package::dependencies" | eval | split(",") | map("trim") }}'
                                          state: present
                                      when: '".artifacts::apt_package::dependencies" | eval != ""'
                                    - name: install package
                                      ansible.builtin.apt:
                                          name: '{{ ".artifacts::apt_package::file" | eval }}'
                                          state: present
                                      environment: '{{ ".artifacts::apt_package::env" | eval | split | map("split", "=") | community.general.dict }}'
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
                                    - name: uninstall package
                                      ansible.builtin.apt:
                                          name: '{{ ".artifacts::apt_package::file" | eval }}'
                                          state: absent
    mysql.dbms~software.application#apt.package::terraform@*->local.machine:
        derived_from: mysql.dbms
        metadata:
            vintner_generated: 'true'
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            local_file:
                                tmp_create:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Run setup script 
                                        if [[ "{{ ".artifacts::apt_package::script" | eval }}" != "" ]]; then 
                                            curl -fsSL {{ ".artifacts::apt_package::script" | eval }} | sudo -E bash -
                                        fi

                                        # Add apt key
                                        if [[ "{{ ".artifacts::apt_package::key" | eval }}" != "" ]]; then 
                                            curl -1sLf {{ ".artifacts::apt_package::key" | eval }} | gpg --dearmor --yes -o /usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg
                                        fi

                                        # Add apt repository
                                        if [[ "{{ ".artifacts::apt_package::source" | eval }}" != "" ]]; then 
                                            echo "deb [signed-by=/usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg] {{ ".artifacts::apt_package::source" | eval }}" | tee {{ ".artifacts::apt_package::repository" | eval }}
                                        fi

                                        # Update apt cache
                                        apt-get update -y

                                        # Install dependencies
                                        if [[ "{{ ".artifacts::apt_package::dependencies" | eval }}" != "" ]]; then 
                                            apt-get install {{ ".artifacts::apt_package::dependencies" | eval | split(",") | map("trim") }} -y
                                        fi

                                        # Install package
                                        {{ ".artifacts::apt_package::env" | eval }} apt-get install {{ ".artifacts::apt_package::file" | eval }} -y

                                        # Create application directory
                                        mkdir -p {{ SELF.application_directory }}

                                        # Create application environment
                                        cat <<EOF > {{ SELF.application_directory }}/.env
                                        DBMS_NAME="{{ SELF.dbms_name }}"
                                        APPLICATION_NAME="{{ SELF.application_name }}"
                                        DBMS_PASSWORD="{{ SELF.dbms_password }}"
                                        DBMS_SSL_MODE="{{ SELF.dbms_ssl_mode }}"
                                        EOF>>

                                        # Create vintner directory
                                        mkdir -p {{ SELF.application_directory }}/.vintner

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/create.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/create.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/create.sh
                                    filename: /tmp/create-mysql.dbms.sh
                                tmp_configure:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/configure.sh
                                    filename: /tmp/configure-mysql.dbms.sh
                                tmp_start:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/start.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/start.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/start.sh
                                    filename: /tmp/start-mysql.dbms.sh
                                tmp_stop:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/stop.sh
                                    filename: /tmp/stop-mysql.dbms.sh
                                tmp_delete:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/delete.sh

                                        # Delete application directory
                                        rm -rf "{{ SELF.application_directory }}"

                                        # Uninstall package
                                        apt-get uninstall {{ ".artifacts::apt_package::file" | eval }} -y
                                    filename: /tmp/delete-mysql.dbms.sh
                            terraform_data:
                                local:
                                    - provisioner:
                                          depends_on:
                                              - local_file.tmp_artifact
                                              - local_file.tmp_create
                                              - local_file.tmp_configure
                                              - local_file.tmp_start
                                              - local_file.tmp_stop
                                              - local_file.tmp_delete
                                          local-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-mysql.dbms.sh
                                                    - sudo bash /tmp/configure-mysql.dbms.sh
                                                    - sudo bash /tmp/start-mysql.dbms.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-mysql.dbms.sh
                                                    - sudo bash /tmp/delete-mysql.dbms.sh
                                                when: destroy
    mysql.dbms~software.application#apt.package::ansible@*->remote.machine:
        derived_from: mysql.dbms
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: run setup script
                                      ansible.builtin.shell: curl -fsSL {{ ".artifacts::apt_package::script" | eval }} | sudo -E bash -
                                      args:
                                          executable: /bin/bash
                                      when: '".artifacts::apt_package::script" | eval != ""'
                                    - name: add apt key
                                      ansible.builtin.apt_key:
                                          url: '{{ ".artifacts::apt_package::key" | eval }}'
                                          keyring: /usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg
                                          state: present
                                      when: '".artifacts::apt_package::key" | eval != ""'
                                    - name: add apt repository
                                      ansible.builtin.apt_repository:
                                          repo: deb [signed-by=/usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg] {{ ".artifacts::apt_package::source" | eval }}
                                          filename: '{{ ".artifacts::apt_package::repository" | eval }}'
                                          state: present
                                      when: '".artifacts::apt_package::source" | eval != ""'
                                    - name: update apt cache
                                      ansible.builtin.apt:
                                          update_cache: 'yes'
                                    - name: install dependencies
                                      ansible.builtin.apt:
                                          name: '{{ ".artifacts::apt_package::dependencies" | eval | split(",") | map("trim") }}'
                                          state: present
                                      when: '".artifacts::apt_package::dependencies" | eval != ""'
                                    - name: install package
                                      ansible.builtin.apt:
                                          name: '{{ ".artifacts::apt_package::file" | eval }}'
                                          state: present
                                      environment: '{{ ".artifacts::apt_package::env" | eval | split | map("split", "=") | community.general.dict }}'
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
                                    - name: uninstall package
                                      ansible.builtin.apt:
                                          name: '{{ ".artifacts::apt_package::file" | eval }}'
                                          state: absent
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
    mysql.dbms~software.application#apt.package::terraform@*->remote.machine:
        derived_from: mysql.dbms
        metadata:
            vintner_generated: 'true'
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            os_ssh_host:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            terraform_data:
                                vm:
                                    - connection:
                                          - host: '{{ SELF.os_ssh_host }}'
                                            private_key: ${file("{{ SELF.os_ssh_key_file }}")}
                                            type: ssh
                                            user: '{{ SELF.os_ssh_user }}'
                                      provisioner:
                                          file:
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Run setup script 
                                                    if [[ "{{ ".artifacts::apt_package::script" | eval }}" != "" ]]; then 
                                                        curl -fsSL {{ ".artifacts::apt_package::script" | eval }} | sudo -E bash -
                                                    fi

                                                    # Add apt key
                                                    if [[ "{{ ".artifacts::apt_package::key" | eval }}" != "" ]]; then 
                                                        curl -1sLf {{ ".artifacts::apt_package::key" | eval }} | gpg --dearmor --yes -o /usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg
                                                    fi

                                                    # Add apt repository
                                                    if [[ "{{ ".artifacts::apt_package::source" | eval }}" != "" ]]; then 
                                                        echo "deb [signed-by=/usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg] {{ ".artifacts::apt_package::source" | eval }}" | tee {{ ".artifacts::apt_package::repository" | eval }}
                                                    fi

                                                    # Update apt cache
                                                    apt-get update -y

                                                    # Install dependencies
                                                    if [[ "{{ ".artifacts::apt_package::dependencies" | eval }}" != "" ]]; then 
                                                        apt-get install {{ ".artifacts::apt_package::dependencies" | eval | split(",") | map("trim") }} -y
                                                    fi

                                                    # Install package
                                                    {{ ".artifacts::apt_package::env" | eval }} apt-get install {{ ".artifacts::apt_package::file" | eval }} -y

                                                    # Create application directory
                                                    mkdir -p {{ SELF.application_directory }}

                                                    # Create application environment
                                                    cat <<EOF > {{ SELF.application_directory }}/.env
                                                    DBMS_NAME="{{ SELF.dbms_name }}"
                                                    APPLICATION_NAME="{{ SELF.application_name }}"
                                                    DBMS_PASSWORD="{{ SELF.dbms_password }}"
                                                    DBMS_SSL_MODE="{{ SELF.dbms_ssl_mode }}"
                                                    EOF>>

                                                    # Create vintner directory
                                                    mkdir -p {{ SELF.application_directory }}/.vintner

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/create.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/create.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/create.sh
                                                destination: /tmp/create-mysql.dbms.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/configure.sh
                                                destination: /tmp/configure-mysql.dbms.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/start.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/start.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/start.sh
                                                destination: /tmp/start-mysql.dbms.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/stop.sh
                                                destination: /tmp/stop-mysql.dbms.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/delete.sh

                                                    # Delete application directory
                                                    rm -rf "{{ SELF.application_directory }}"

                                                    # Uninstall package
                                                    apt-get uninstall {{ ".artifacts::apt_package::file" | eval }} -y
                                                destination: /tmp/delete-mysql.dbms.sh
                                          remote-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-mysql.dbms.sh
                                                    - sudo bash /tmp/configure-mysql.dbms.sh
                                                    - sudo bash /tmp/start-mysql.dbms.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-mysql.dbms.sh
                                                    - sudo bash /tmp/delete-mysql.dbms.sh
                                                when: destroy
    mysql.dbms~software.application#tar.archive::ansible@*->local.machine:
        derived_from: mysql.dbms
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: install operational dependencies
                                      ansible.builtin.apt:
                                          name: unzip
                                          update_cache: 'yes'
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: extract deployment artifact in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          extra_opts: '{{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}'
                                      when: not (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")
                                    - name: extract deployment artifact from URL in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          remote_src: 'yes'
                                          extra_opts: '{{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}'
                                      when: (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")
                                    - name: create vintner directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}/.vintner'
                                          state: directory
                                    - name: create .env file
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.env'
                                          content: |-
                                              DBMS_NAME="{{ SELF.dbms_name }}"
                                              APPLICATION_NAME="{{ SELF.application_name }}"
                                              DBMS_PASSWORD="{{ SELF.dbms_password }}"
                                              DBMS_SSL_MODE="{{ SELF.dbms_ssl_mode }}"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "start" missing
                                      when: SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "stop" missing
                                      when: SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
    mysql.dbms~software.application#tar.archive::terraform@*->local.machine:
        derived_from: mysql.dbms
        metadata:
            vintner_generated: 'true'
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            local_file:
                                tmp_artifact:
                                    source: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                    filename: /tmp/artifact-mysql.dbms
                                    count: '{{ (not (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")) | ternary(1, 0) }}'
                                tmp_create:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Create application directory
                                        mkdir -p {{ SELF.application_directory }}

                                        # Create application environment
                                        cat <<EOF > {{ SELF.application_directory }}/.env
                                        DBMS_NAME="{{ SELF.dbms_name }}"
                                        APPLICATION_NAME="{{ SELF.application_name }}"
                                        DBMS_PASSWORD="{{ SELF.dbms_password }}"
                                        DBMS_SSL_MODE="{{ SELF.dbms_ssl_mode }}"
                                        EOF>>

                                        # Download deployment artifact if required
                                        if [[ "{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}" == http* ]]; then 
                                            wget -O /tmp/artifact-mysql.dbms {{ ".artifacts::*::[.type=tar.archive]::file" | eval }} 
                                        fi

                                        # Extract deployment artifact
                                        tar -xzf /tmp/artifact-mysql.dbms -C {{ SELF.application_directory }} {{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}

                                        # Create vintner directory
                                        mkdir -p {{ SELF.application_directory }}/.vintner

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/create.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/create.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/create.sh
                                    filename: /tmp/create-mysql.dbms.sh
                                tmp_configure:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/configure.sh
                                    filename: /tmp/configure-mysql.dbms.sh
                                tmp_start:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Assert operation
                                        if [[ "{{ SELF._management_start | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                            echo 'Management operation "start" missing'
                                            exit 1 
                                        fi

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/start.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/start.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/start.sh
                                    filename: /tmp/start-mysql.dbms.sh
                                tmp_stop:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Assert operation
                                        if [[ "{{ SELF._management_stop | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                            echo 'Management operation "stop" missing'
                                            exit 1 
                                        fi

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/stop.sh
                                    filename: /tmp/stop-mysql.dbms.sh
                                tmp_delete:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/delete.sh

                                        # Delete application directory
                                        rm -rf "{{ SELF.application_directory }}"
                                    filename: /tmp/delete-mysql.dbms.sh
                            terraform_data:
                                local:
                                    - depends_on:
                                          - local_file.tmp_artifact
                                          - local_file.tmp_create
                                          - local_file.tmp_configure
                                          - local_file.tmp_start
                                          - local_file.tmp_stop
                                          - local_file.tmp_delete
                                      provisioner:
                                          local-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-mysql.dbms.sh
                                                    - sudo bash /tmp/configure-mysql.dbms.sh
                                                    - sudo bash /tmp/start-mysql.dbms.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-mysql.dbms.sh
                                                    - sudo bash /tmp/delete-mysql.dbms.sh
                                                when: destroy
    mysql.dbms~software.application#tar.archive::ansible@*->remote.machine:
        derived_from: mysql.dbms
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: extract deployment artifact in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          extra_opts: '{{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}'
                                      when: not (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")
                                    - name: extract deployment artifact from URL in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          remote_src: 'yes'
                                          extra_opts: '{{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}'
                                      when: (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")
                                    - name: create vintner directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}/.vintner'
                                          state: directory
                                    - name: create .env file
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.env'
                                          content: |-
                                              DBMS_NAME="{{ SELF.dbms_name }}"
                                              APPLICATION_NAME="{{ SELF.application_name }}"
                                              DBMS_PASSWORD="{{ SELF.dbms_password }}"
                                              DBMS_SSL_MODE="{{ SELF.dbms_ssl_mode }}"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "start" missing
                                      when: SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "stop" missing
                                      when: SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
    mysql.dbms~software.application#tar.archive::terraform@*->remote.machine:
        derived_from: mysql.dbms
        metadata:
            vintner_generated: 'true'
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            os_ssh_host:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            terraform_data:
                                vm:
                                    - connection:
                                          - host: '{{ SELF.os_ssh_host }}'
                                            private_key: ${file("{{ SELF.os_ssh_key_file }}")}
                                            type: ssh
                                            user: '{{ SELF.os_ssh_user }}'
                                      provisioner:
                                          file:
                                              - source: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                                destination: /tmp/artifact-mysql.dbms
                                                count: '{{ (not (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")) | ternary(1, 0) }}'
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Create application directory
                                                    mkdir -p {{ SELF.application_directory }}

                                                    # Create application environment
                                                    cat <<EOF > {{ SELF.application_directory }}/.env
                                                    DBMS_NAME="{{ SELF.dbms_name }}"
                                                    APPLICATION_NAME="{{ SELF.application_name }}"
                                                    DBMS_PASSWORD="{{ SELF.dbms_password }}"
                                                    DBMS_SSL_MODE="{{ SELF.dbms_ssl_mode }}"
                                                    EOF>>

                                                    # Download deployment artifact if required
                                                    if [[ "{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}" == http* ]]; then 
                                                        wget -O /tmp/artifact-mysql.dbms {{ ".artifacts::*::[.type=tar.archive]::file" | eval }} 
                                                    fi

                                                    # Extract deployment artifact
                                                    tar -xzf /tmp/artifact-mysql.dbms -C {{ SELF.application_directory }} {{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}

                                                    # Create vintner directory
                                                    mkdir -p {{ SELF.application_directory }}/.vintner

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/create.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/create.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/create.sh
                                                destination: /tmp/create-mysql.dbms.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/configure.sh
                                                destination: /tmp/configure-mysql.dbms.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Assert operation
                                                    if [[ "{{ SELF._management_start | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                                        echo 'Management operation "start" missing'
                                                        exit 1 
                                                    fi

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/start.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/start.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/start.sh
                                                destination: /tmp/start-mysql.dbms.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Assert operation
                                                    if [[ "{{ SELF._management_stop | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                                        echo 'Management operation "stop" missing'
                                                        exit 1 
                                                    fi

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/stop.sh
                                                destination: /tmp/stop-mysql.dbms.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/delete.sh

                                                    # Delete application directory
                                                    rm -rf "{{ SELF.application_directory }}"
                                                destination: /tmp/delete-mysql.dbms.sh
                                          remote-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-mysql.dbms.sh
                                                    - sudo bash /tmp/configure-mysql.dbms.sh
                                                    - sudo bash /tmp/start-mysql.dbms.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-mysql.dbms.sh
                                                    - sudo bash /tmp/delete-mysql.dbms.sh
                                                when: destroy
    mysql.dbms~software.application#zip.archive::ansible@*->local.machine:
        derived_from: mysql.dbms
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: install operational dependencies
                                      ansible.builtin.apt:
                                          name: unzip
                                          update_cache: 'yes'
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: extract deployment artifact in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          extra_opts: '{{ ".artifacts::*::[.type=zip.archive]::extra_opts" | eval | map_value }}'
                                      when: not (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")
                                    - name: extract deployment artifact from URL in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          remote_src: 'yes'
                                          extra_opts: '{{ ".artifacts::*::[.type=zip.archive]::extra_opts" | eval | map_value }}'
                                      when: (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")
                                    - name: create vintner directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}/.vintner'
                                          state: directory
                                    - name: create .env file
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.env'
                                          content: |-
                                              DBMS_NAME="{{ SELF.dbms_name }}"
                                              APPLICATION_NAME="{{ SELF.application_name }}"
                                              DBMS_PASSWORD="{{ SELF.dbms_password }}"
                                              DBMS_SSL_MODE="{{ SELF.dbms_ssl_mode }}"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "start" missing
                                      when: SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "stop" missing
                                      when: SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
    mysql.dbms~software.application#zip.archive::terraform@*->local.machine:
        derived_from: mysql.dbms
        metadata:
            vintner_generated: 'true'
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            local_file:
                                tmp_artifact:
                                    source: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                    filename: /tmp/artifact-mysql.dbms
                                    count: '{{ (not (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")) | ternary(1, 0) }}'
                                tmp_create:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Create application directory
                                        mkdir -p {{ SELF.application_directory }}

                                        # Create application environment
                                        cat <<EOF > {{ SELF.application_directory }}/.env
                                        DBMS_NAME="{{ SELF.dbms_name }}"
                                        APPLICATION_NAME="{{ SELF.application_name }}"
                                        DBMS_PASSWORD="{{ SELF.dbms_password }}"
                                        DBMS_SSL_MODE="{{ SELF.dbms_ssl_mode }}"
                                        EOF>>

                                        # Download deployment artifact if required
                                        if [[ "{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}" == http* ]]; then 
                                            wget -O /tmp/artifact-mysql.dbms {{ ".artifacts::*::[.type=zip.archive]::file" | eval }} 
                                        fi

                                        # Extract deployment artifact
                                        unzip /tmp/artifact-mysql.dbms -d {{ SELF.application_directory }} {{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}

                                        # Create vintner directory
                                        mkdir -p {{ SELF.application_directory }}/.vintner

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/create.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/create.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/create.sh
                                    filename: /tmp/create-mysql.dbms.sh
                                tmp_configure:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/configure.sh
                                    filename: /tmp/configure-mysql.dbms.sh
                                tmp_start:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Assert operation
                                        if [[ "{{ SELF._management_start | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                            echo 'Management operation "start" missing'
                                            exit 1 
                                        fi

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/start.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/start.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/start.sh
                                    filename: /tmp/start-mysql.dbms.sh
                                tmp_stop:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Assert operation
                                        if [[ "{{ SELF._management_stop | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                            echo 'Management operation "stop" missing'
                                            exit 1 
                                        fi

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/stop.sh
                                    filename: /tmp/stop-mysql.dbms.sh
                                tmp_delete:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/delete.sh

                                        # Delete application directory
                                        rm -rf "{{ SELF.application_directory }}"
                                    filename: /tmp/delete-mysql.dbms.sh
                            terraform_data:
                                local:
                                    - depends_on:
                                          - local_file.tmp_artifact
                                          - local_file.tmp_create
                                          - local_file.tmp_configure
                                          - local_file.tmp_start
                                          - local_file.tmp_stop
                                          - local_file.tmp_delete
                                      provisioner:
                                          local-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-mysql.dbms.sh
                                                    - sudo bash /tmp/configure-mysql.dbms.sh
                                                    - sudo bash /tmp/start-mysql.dbms.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-mysql.dbms.sh
                                                    - sudo bash /tmp/delete-mysql.dbms.sh
                                                when: destroy
    mysql.dbms~software.application#zip.archive::ansible@*->remote.machine:
        derived_from: mysql.dbms
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: install operational dependencies
                                      ansible.builtin.apt:
                                          name: unzip
                                          update_cache: 'yes'
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: extract deployment artifact in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          extra_opts: '{{ ".artifacts::*::[.type=zip.archive]::extra_opts" | eval | map_value }}'
                                      when: not (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")
                                    - name: extract deployment artifact from URL in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          remote_src: 'yes'
                                          extra_opts: '{{ ".artifacts::*::[.type=zip.archive]::extra_opts" | eval | map_value }}'
                                      when: (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")
                                    - name: create vintner directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}/.vintner'
                                          state: directory
                                    - name: create .env file
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.env'
                                          content: |-
                                              DBMS_NAME="{{ SELF.dbms_name }}"
                                              APPLICATION_NAME="{{ SELF.application_name }}"
                                              DBMS_PASSWORD="{{ SELF.dbms_password }}"
                                              DBMS_SSL_MODE="{{ SELF.dbms_ssl_mode }}"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "start" missing
                                      when: SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "stop" missing
                                      when: SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
    mysql.dbms~software.application#zip.archive::terraform@*->remote.machine:
        derived_from: mysql.dbms
        metadata:
            vintner_generated: 'true'
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            os_ssh_host:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            terraform_data:
                                vm:
                                    - connection:
                                          - host: '{{ SELF.os_ssh_host }}'
                                            private_key: ${file("{{ SELF.os_ssh_key_file }}")}
                                            type: ssh
                                            user: '{{ SELF.os_ssh_user }}'
                                      provisioner:
                                          file:
                                              - source: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                                destination: /tmp/artifact-mysql.dbms
                                                count: '{{ (not (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")) | ternary(1, 0) }}'
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Create application directory
                                                    mkdir -p {{ SELF.application_directory }}

                                                    # Create application environment
                                                    cat <<EOF > {{ SELF.application_directory }}/.env
                                                    DBMS_NAME="{{ SELF.dbms_name }}"
                                                    APPLICATION_NAME="{{ SELF.application_name }}"
                                                    DBMS_PASSWORD="{{ SELF.dbms_password }}"
                                                    DBMS_SSL_MODE="{{ SELF.dbms_ssl_mode }}"
                                                    EOF>>

                                                    # Download deployment artifact if required
                                                    if [[ "{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}" == http* ]]; then 
                                                        wget -O /tmp/artifact-mysql.dbms {{ ".artifacts::*::[.type=zip.archive]::file" | eval }} 
                                                    fi

                                                    # Extract deployment artifact
                                                    unzip /tmp/artifact-mysql.dbms -d {{ SELF.application_directory }} {{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}

                                                    # Create vintner directory
                                                    mkdir -p {{ SELF.application_directory }}/.vintner

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/create.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/create.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/create.sh
                                                destination: /tmp/create-mysql.dbms.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/configure.sh
                                                destination: /tmp/configure-mysql.dbms.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Assert operation
                                                    if [[ "{{ SELF._management_start | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                                        echo 'Management operation "start" missing'
                                                        exit 1 
                                                    fi

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/start.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/start.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/start.sh
                                                destination: /tmp/start-mysql.dbms.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Assert operation
                                                    if [[ "{{ SELF._management_stop | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                                        echo 'Management operation "stop" missing'
                                                        exit 1 
                                                    fi

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/stop.sh
                                                destination: /tmp/stop-mysql.dbms.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/delete.sh

                                                    # Delete application directory
                                                    rm -rf "{{ SELF.application_directory }}"
                                                destination: /tmp/delete-mysql.dbms.sh
                                          remote-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-mysql.dbms.sh
                                                    - sudo bash /tmp/configure-mysql.dbms.sh
                                                    - sudo bash /tmp/start-mysql.dbms.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-mysql.dbms.sh
                                                    - sudo bash /tmp/delete-mysql.dbms.sh
                                                when: destroy
    mysql.database~mysql.database::ansible@mysql.dbms->docker.engine->local.machine:
        derived_from: mysql.database
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: get dbms container info
                                      community.docker.docker_container_info:
                                          name: '{{ HOST.dbms_name }}'
                                      register: dbms_container_info
                                    - name: create database
                                      community.mysql.mysql_db:
                                          name: '{{ SELF.database_name }}'
                                          login_host: '{{ HOST.application_address }}'
                                          login_password: '{{ HOST.dbms_password }}'
                                          login_port: '{{ HOST.application_port }}'
                                          login_user: root
                                    - name: create user (with privileges)
                                      community.mysql.mysql_user:
                                          name: '{{ SELF.database_user }}'
                                          password: '{{ SELF.database_password }}'
                                          host: '%'
                                          priv: '*.*:ALL'
                                          login_host: '{{ HOST.application_address }}'
                                          login_password: '{{ HOST.dbms_password }}'
                                          login_port: '{{ HOST.application_port }}'
                                          login_user: root
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: delete user (with privileges)
                                      community.mysql.mysql_user:
                                          state: absent
                                          name: '{{ SELF.database_user }}'
                                          password: '{{ SELF.database_password }}'
                                          host: '%'
                                          priv: '*.*:ALL'
                                          login_host: '{{ HOST.application_address }}'
                                          login_password: '{{ HOST.dbms_password }}'
                                          login_port: '{{ HOST.application_port }}'
                                          login_user: root
                                    - name: delete database
                                      community.mysql.mysql_db:
                                          name: '{{ SELF.database_name }}'
                                          state: absent
                                          login_host: '{{ HOST.application_address }}'
                                          login_password: '{{ HOST.dbms_password }}'
                                          login_port: '{{ HOST.application_port }}'
                                          login_user: root
    mysql.database~mysql.database::compose@mysql.dbms->docker.engine->local.machine:
        derived_from: mysql.database
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: touch compose
                                      register: compose
                                      ansible.builtin.tempfile:
                                          suffix: '{{ SELF.database_name }}-{{ HOST.dbms_name }}.database.compose.yaml'
                                    - name: create compose
                                      ansible.builtin.copy:
                                          dest: '{{ compose.path }}'
                                          content: '{{ manifest | to_yaml }}'
                                      vars:
                                          manifest:
                                              name: '{{ SELF.database_name }}-{{ HOST.dbms_name }}-database-job'
                                              services:
                                                  job:
                                                      container_name: '{{ SELF.database_name }}-{{ HOST.dbms_name }}-database-job'
                                                      image: mysql:{{ ".artifacts::dbms_image::file" | eval }}
                                                      network_mode: host
                                                      command:
                                                          - mysql
                                                          - '--host={{ HOST.management_address }}'
                                                          - '--port={{ HOST.management_port }}'
                                                          - '--user=root'
                                                          - '--password={{ HOST.dbms_password }}'
                                                          - '-e'
                                                          - CREATE DATABASE IF NOT EXISTS {{ SELF.database_name }}; CREATE USER IF NOT EXISTS '{{ SELF.database_user }}'@'%' IDENTIFIED BY '{{ SELF.database_password }}'; GRANT ALL PRIVILEGES ON *.* TO '{{ SELF.database_user }}'@'%';
                                    - name: apply compose
                                      ansible.builtin.shell: docker compose -f {{ compose.path }} up -d
                                      args:
                                          executable: /usr/bin/bash
                                      environment: {}
                                    - name: let it cook
                                      ansible.builtin.pause:
                                          seconds: 10
                                    - name: unapply compose
                                      ansible.builtin.shell: docker compose -f {{ compose.path }} down
                                      args:
                                          executable: /usr/bin/bash
                                      environment: {}
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: touch compose
                                      register: compose
                                      ansible.builtin.tempfile:
                                          suffix: '{{ SELF.database_name }}-{{ HOST.dbms_name }}.database.compose.yaml'
                                    - name: create compose
                                      ansible.builtin.copy:
                                          dest: '{{ compose.path }}'
                                          content: '{{ manifest | to_yaml }}'
                                      vars:
                                          manifest:
                                              name: '{{ SELF.database_name }}-{{ HOST.dbms_name }}-database-job'
                                              services:
                                                  job:
                                                      container_name: '{{ SELF.database_name }}-{{ HOST.dbms_name }}-database-job'
                                                      image: mysql:{{ ".artifacts::dbms_image::file" | eval }}
                                                      network_mode: host
                                                      command:
                                                          - mysql
                                                          - '--host={{ HOST.management_address }}'
                                                          - '--port={{ HOST.management_port }}'
                                                          - '--user=root'
                                                          - '--password={{ HOST.dbms_password }}'
                                                          - '-e'
                                                          - DROP USER IF EXISTS '{{ SELF.database_user }}'@'%'; DROP DATABASE IF EXISTS {{ SELF.database_name }};
                                    - name: apply compose
                                      ansible.builtin.shell: docker compose -f {{ compose.path }} up -d
                                      args:
                                          executable: /usr/bin/bash
                                      environment: {}
                                    - name: let it cook
                                      ansible.builtin.pause:
                                          seconds: 10
                                    - name: unapply compose
                                      ansible.builtin.shell: docker compose -f {{ compose.path }} down
                                      args:
                                          executable: /usr/bin/bash
                                      environment: {}
    mysql.database~mysql.database::terraform@mysql.dbms->docker.engine->local.machine:
        derived_from: mysql.database
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        terraform:
                            - required_providers:
                                  - mysql:
                                        source: petoju/mysql
                                        version: 3.0.48
                        provider:
                            mysql:
                                - endpoint: 127.0.0.1:{{ HOST.management_port }}
                                  password: '{{ HOST.dbms_password }}'
                                  username: root
                        resource:
                            mysql_database:
                                database:
                                    - name: '{{ SELF.database_name }}'
                            mysql_user:
                                user:
                                    - host: '%'
                                      plaintext_password: '{{ SELF.database_password }}'
                                      user: '{{ SELF.database_user }}'
                            mysql_grant:
                                user:
                                    - database: '{{ SELF.database_name }}'
                                      host: '%'
                                      table: '*'
                                      privileges:
                                          - ALL
                                      user: ${mysql_user.user.user}
    mysql.database~mysql.database::ansible@mysql.dbms->docker.engine->remote.machine:
        derived_from: mysql.database
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: install pip
                                      ansible.builtin.apt:
                                          name: python3-pip
                                          state: present
                                    - name: install pymysql
                                      ansible.builtin.pip:
                                          name: pymysql
                                          state: present
                                    - name: get dbms container info
                                      community.docker.docker_container_info:
                                          name: '{{ HOST.dbms_name }}'
                                      register: dbms_container_info
                                    - name: forward port
                                      when: "'host' not in dbms_container_info.container.NetworkSettings.Networks"
                                      community.docker.docker_container:
                                          name: '{{ HOST.dbms_name }}-port-forward'
                                          image: nicolaka/netshoot:v0.13
                                          command: socat TCP6-LISTEN:3306,fork TCP:{{ HOST.dbms_name }}:3306
                                          ports:
                                              - '{{ HOST.application_port }}:3306'
                                    - name: create forwarding network
                                      community.docker.docker_network:
                                          name: '{{ HOST.dbms_name }}-port-forward'
                                          connected:
                                              - '{{ HOST.dbms_name }}-port-forward'
                                              - '{{ HOST.dbms_name }}'
                                      when: "'host' not in dbms_container_info.container.NetworkSettings.Networks"
                                    - name: create database
                                      community.mysql.mysql_db:
                                          name: '{{ SELF.database_name }}'
                                          login_host: '{{ HOST.application_address }}'
                                          login_password: '{{ HOST.dbms_password }}'
                                          login_port: '{{ HOST.application_port }}'
                                          login_user: root
                                    - name: create user (with privileges)
                                      community.mysql.mysql_user:
                                          name: '{{ SELF.database_user }}'
                                          password: '{{ SELF.database_password }}'
                                          host: '%'
                                          priv: '*.*:ALL'
                                          login_host: '{{ HOST.application_address }}'
                                          login_password: '{{ HOST.dbms_password }}'
                                          login_port: '{{ HOST.application_port }}'
                                          login_user: root
                                    - name: unforward port
                                      when: "'host' not in dbms_container_info.container.NetworkSettings.Networks"
                                      community.docker.docker_container:
                                          name: '{{ HOST.dbms_name }}-port-forward'
                                          state: absent
                                    - name: remove forwarding network
                                      community.docker.docker_network:
                                          name: '{{ HOST.dbms_name }}-port-forward'
                                          state: absent
                                      when: "'host' not in dbms_container_info.container.NetworkSettings.Networks"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: delete user (with privileges)
                                      community.mysql.mysql_user:
                                          state: absent
                                          name: '{{ SELF.database_user }}'
                                          password: '{{ SELF.database_password }}'
                                          host: '%'
                                          priv: '*.*:ALL'
                                          login_host: '{{ HOST.application_address }}'
                                          login_password: '{{ HOST.dbms_password }}'
                                          login_port: '{{ HOST.application_port }}'
                                          login_user: root
                                    - name: delete database
                                      community.mysql.mysql_db:
                                          name: '{{ SELF.database_name }}'
                                          state: absent
                                          login_host: '{{ HOST.application_address }}'
                                          login_password: '{{ HOST.dbms_password }}'
                                          login_port: '{{ HOST.application_port }}'
                                          login_user: root
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
    mysql.database~mysql.database::compose@mysql.dbms->docker.engine->remote.machine:
        derived_from: mysql.database
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            os_ssh_host:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: touch compose
                                      register: compose
                                      ansible.builtin.tempfile:
                                          suffix: '{{ SELF.database_name }}-{{ HOST.dbms_name }}.database.compose.yaml'
                                    - name: create compose
                                      ansible.builtin.copy:
                                          dest: '{{ compose.path }}'
                                          content: '{{ manifest | to_yaml }}'
                                      vars:
                                          manifest:
                                              name: '{{ SELF.database_name }}-{{ HOST.dbms_name }}-database-job'
                                              services:
                                                  job:
                                                      container_name: '{{ SELF.database_name }}-{{ HOST.dbms_name }}-database-job'
                                                      image: mysql:{{ ".artifacts::dbms_image::file" | eval }}
                                                      network_mode: host
                                                      command:
                                                          - mysql
                                                          - '--host={{ HOST.management_address }}'
                                                          - '--port={{ HOST.management_port }}'
                                                          - '--user=root'
                                                          - '--password={{ HOST.dbms_password }}'
                                                          - '-e'
                                                          - CREATE DATABASE IF NOT EXISTS {{ SELF.database_name }}; CREATE USER IF NOT EXISTS '{{ SELF.database_user }}'@'%' IDENTIFIED BY '{{ SELF.database_password }}'; GRANT ALL PRIVILEGES ON *.* TO '{{ SELF.database_user }}'@'%';
                                    - name: add ssh credentials
                                      community.general.ssh_config:
                                          user: "{{ lookup('env', 'USER') }}"
                                          host: '{{ SELF.os_ssh_host }}'
                                          remote_user: '{{ SELF.os_ssh_user }}'
                                          identity_file: '{{ SELF.os_ssh_key_file }}'
                                          strict_host_key_checking: 'no'
                                          user_known_hosts_file: /dev/null
                                    - name: apply compose
                                      ansible.builtin.shell: docker compose -f {{ compose.path }} up -d
                                      args:
                                          executable: /usr/bin/bash
                                      environment:
                                          DOCKER_HOST: ssh://{{ SELF.os_ssh_host }}
                                    - name: let it cook
                                      ansible.builtin.pause:
                                          seconds: 10
                                    - name: unapply compose
                                      ansible.builtin.shell: docker compose -f {{ compose.path }} down
                                      args:
                                          executable: /usr/bin/bash
                                      environment:
                                          DOCKER_HOST: ssh://{{ SELF.os_ssh_host }}
                                    - name: remove ssh credentials
                                      community.general.ssh_config:
                                          user: "{{ lookup('env', 'USER') }}"
                                          host: '{{ SELF.os_ssh_host }}'
                                          state: absent
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: touch compose
                                      register: compose
                                      ansible.builtin.tempfile:
                                          suffix: '{{ SELF.database_name }}-{{ HOST.dbms_name }}.database.compose.yaml'
                                    - name: create compose
                                      ansible.builtin.copy:
                                          dest: '{{ compose.path }}'
                                          content: '{{ manifest | to_yaml }}'
                                      vars:
                                          manifest:
                                              name: '{{ SELF.database_name }}-{{ HOST.dbms_name }}-database-job'
                                              services:
                                                  job:
                                                      container_name: '{{ SELF.database_name }}-{{ HOST.dbms_name }}-database-job'
                                                      image: mysql:{{ ".artifacts::dbms_image::file" | eval }}
                                                      network_mode: host
                                                      command:
                                                          - mysql
                                                          - '--host={{ HOST.management_address }}'
                                                          - '--port={{ HOST.management_port }}'
                                                          - '--user=root'
                                                          - '--password={{ HOST.dbms_password }}'
                                                          - '-e'
                                                          - DROP USER IF EXISTS '{{ SELF.database_user }}'@'%'; DROP DATABASE IF EXISTS {{ SELF.database_name }};
                                    - name: add ssh credentials
                                      community.general.ssh_config:
                                          user: "{{ lookup('env', 'USER') }}"
                                          host: '{{ SELF.os_ssh_host }}'
                                          remote_user: '{{ SELF.os_ssh_user }}'
                                          identity_file: '{{ SELF.os_ssh_key_file }}'
                                          strict_host_key_checking: 'no'
                                          user_known_hosts_file: /dev/null
                                    - name: apply compose
                                      ansible.builtin.shell: docker compose -f {{ compose.path }} up -d
                                      args:
                                          executable: /usr/bin/bash
                                      environment:
                                          DOCKER_HOST: ssh://{{ SELF.os_ssh_host }}
                                    - name: let it cook
                                      ansible.builtin.pause:
                                          seconds: 10
                                    - name: unapply compose
                                      ansible.builtin.shell: docker compose -f {{ compose.path }} down
                                      args:
                                          executable: /usr/bin/bash
                                      environment:
                                          DOCKER_HOST: ssh://{{ SELF.os_ssh_host }}
                                    - name: remove ssh credentials
                                      community.general.ssh_config:
                                          user: "{{ lookup('env', 'USER') }}"
                                          host: '{{ SELF.os_ssh_host }}'
                                          state: absent
    mysql.database~mysql.database::terraform@mysql.dbms->docker.engine->remote.machine:
        derived_from: mysql.database
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            os_ssh_host:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        terraform:
                            - required_providers:
                                  - mysql:
                                        source: petoju/mysql
                                        version: 3.0.48
                                    ssh:
                                        source: AndrewChubatiuk/ssh
                                        version: 0.2.3
                        data:
                            ssh_tunnel:
                                mysql:
                                    - remote:
                                          host: '{{ HOST.application_address }}'
                                          port: '{{ HOST.application_port }}'
                        provider:
                            mysql:
                                - endpoint: ${data.ssh_tunnel.mysql.local.address}
                                  password: '{{ HOST.dbms_password }}'
                                  username: root
                            ssh:
                                - auth:
                                      private_key:
                                          content: ${file(pathexpand("{{ SELF.os_ssh_key_file }}"))}
                                  server:
                                      host: '{{ HOST.management_address }}'
                                      port: 22
                                  user: '{{ SELF.os_ssh_user }}'
                        resource:
                            mysql_database:
                                database:
                                    - name: '{{ SELF.database_name }}'
                            mysql_user:
                                user:
                                    - host: '%'
                                      plaintext_password: '{{ SELF.database_password }}'
                                      user: '{{ SELF.database_user }}'
                            mysql_grant:
                                user:
                                    - database: '{{ SELF.database_name }}'
                                      host: '%'
                                      table: '*'
                                      privileges:
                                          - ALL
                                      user: ${mysql_user.user.user}
    mysql.database~mysql.database::ansible@mysql.dbms->gcp.cloudsql:
        derived_from: mysql.database
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            gcp_service_account_file:
                type: string
                default:
                    get_input: gcp_service_account_file
            gcp_region:
                type: string
                default:
                    get_input: gcp_region
            gcp_project:
                type: string
                default:
                    get_input: gcp_project
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                            environment:
                                GCP_SERVICE_ACCOUNT_FILE:
                                    eval: .::gcp_service_account_file
                                GCP_AUTH_KIND: serviceaccount
                        inputs:
                            playbook:
                                q:
                                    - name: create a database
                                      google.cloud.gcp_sql_database:
                                          name: '{{ SELF.database_name }}'
                                          charset: utf8
                                          instance: '{{ HOST.dbms_name }}'
                                          project: '{{ SELF.gcp_project }}'
                                    - name: install GCP CloudSQL Proxy
                                      ansible.builtin.get_url:
                                          url: https://storage.googleapis.com/cloud-sql-connectors/cloud-sql-proxy/v2.13.0/cloud-sql-proxy.linux.amd64
                                          dest: /tmp/gcp-cloudsql-proxy
                                          mode: '0755'
                                    - name: forward port
                                      ansible.builtin.shell: '/tmp/gcp-cloudsql-proxy {{ SELF.gcp_project }}:{{ SELF.gcp_region }}:{{ HOST.dbms_name }} --credentials-file {{ SELF.gcp_service_account_file }} --port 23306 '
                                      args:
                                          executable: /usr/bin/bash
                                      async: 30
                                      poll: 0
                                    - name: wait for port
                                      ansible.builtin.wait_for:
                                          host: 127.0.0.1
                                          port: 23306
                                          delay: 5
                                          timeout: 30
                                    - name: create user (with privileges)
                                      community.mysql.mysql_user:
                                          name: '{{ SELF.database_user }}'
                                          password: '{{ SELF.database_password }}'
                                          host: '%'
                                          priv: '*.*:ALL'
                                          login_host: 127.0.0.1
                                          login_password: '{{ HOST.dbms_password }}'
                                          login_port: 23306
                                          login_user: root
                                    - name: unforward port
                                      ansible.builtin.shell: pkill -f "/tmp/gcp-cloudsql-proxy {{ SELF.gcp_project }}:{{ SELF.gcp_region }}:{{ HOST.dbms_name }}"
                                      args:
                                          executable: /usr/bin/bash
    mysql.database~mysql.database::terraform@mysql.dbms->gcp.cloudsql:
        derived_from: mysql.database
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            gcp_service_account_file:
                type: string
                default:
                    get_input: gcp_service_account_file
            gcp_region:
                type: string
                default:
                    get_input: gcp_region
            gcp_project:
                type: string
                default:
                    get_input: gcp_project
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                            environment:
                                GOOGLE_APPLICATION_CREDENTIALS:
                                    eval: .::gcp_service_account_file
                    delete:
                        implementation:
                            primary: Terraform
                            environment:
                                GOOGLE_APPLICATION_CREDENTIALS:
                                    eval: .::gcp_service_account_file
            defaults:
                inputs:
                    main:
                        terraform:
                            - required_providers:
                                  - google:
                                        source: hashicorp/google
                                        version: 5.39.1
                                    mysql:
                                        source: petoju/mysql
                                        version: 3.0.48
                        provider:
                            google:
                                - credentials: '{{ SELF.gcp_service_account_file }}'
                                  project: '{{ SELF.gcp_project }}'
                                  region: '{{ SELF.gcp_region }}'
                            mysql:
                                - endpoint: cloudsql://{{ SELF.gcp_project }}:{{ SELF.gcp_region }}:{{ HOST.dbms_name }}
                                  password: '{{ HOST.dbms_password }}'
                                  username: root
                        resource:
                            google_sql_database:
                                database:
                                    - name: '{{ SELF.database_name }}'
                                      instance: '{{ HOST.dbms_name }}'
                            google_sql_user:
                                user:
                                    - host: '%'
                                      instance: '{{ HOST.dbms_name }}'
                                      name: '{{ SELF.database_name }}'
                                      password: '{{ SELF.database_password }}'
                            mysql_grant:
                                user:
                                    - database: '{{ SELF.database_name }}'
                                      host: '%'
                                      table: '*'
                                      privileges:
                                          - ALL
                                      user: ${google_sql_user.user.name}
    mysql.database~mysql.database::ansible@mysql.dbms->kubernetes.cluster:
        derived_from: mysql.database
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            k8s_host:
                type: string
                default:
                    get_input: k8s_host
            k8s_ca_cert_file:
                type: string
                default:
                    get_input: k8s_ca_cert_file
            k8s_client_cert_file:
                type: string
                default:
                    get_input: k8s_client_cert_file
            k8s_client_key_file:
                type: string
                default:
                    get_input: k8s_client_key_file
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: deploy database
                                      block:
                                          - name: forward port
                                            ansible.builtin.shell: kubectl --server {{ SELF.k8s_host }} --certificate-authority {{ SELF.k8s_ca_cert_file }} --client-certificate {{ SELF.k8s_client_cert_file }} --client-key {{ SELF.k8s_client_key_file }} port-forward service/{{ HOST.dbms_name }} 23306:3306
                                            args:
                                                executable: /usr/bin/bash
                                            async: 30
                                            poll: 0
                                          - name: wait for port
                                            ansible.builtin.wait_for:
                                                host: 127.0.0.1
                                                port: 23306
                                                delay: 5
                                                timeout: 30
                                          - name: create database
                                            community.mysql.mysql_db:
                                                name: '{{ SELF.database_name }}'
                                                login_host: 127.0.0.1
                                                login_password: '{{ HOST.dbms_password }}'
                                                login_port: '23306'
                                                login_user: root
                                          - name: create user (with privileges)
                                            community.mysql.mysql_user:
                                                name: '{{ SELF.database_user }}'
                                                password: '{{ SELF.database_password }}'
                                                host: '%'
                                                priv: '*.*:ALL'
                                                login_host: 127.0.0.1
                                                login_password: '{{ HOST.dbms_password }}'
                                                login_port: '23306'
                                                login_user: root
                                      always:
                                          - name: unforward port
                                            ansible.builtin.shell: pkill -f "port-forward service/{{ HOST.dbms_name }}"
                                            args:
                                                executable: /usr/bin/bash
    mysql.database~mysql.database::kubernetes@mysql.dbms->kubernetes.cluster:
        derived_from: mysql.database
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            k8s_host:
                type: string
                default:
                    get_input: k8s_host
            k8s_ca_cert_file:
                type: string
                default:
                    get_input: k8s_ca_cert_file
            k8s_client_cert_file:
                type: string
                default:
                    get_input: k8s_client_cert_file
            k8s_client_key_file:
                type: string
                default:
                    get_input: k8s_client_key_file
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: touch manifest
                                      register: manifest
                                      ansible.builtin.tempfile:
                                          suffix: '{{ SELF.database_name }}-{{ HOST.dbms_name }}.database.manifest.yaml'
                                    - name: create manifest
                                      ansible.builtin.copy:
                                          dest: '{{ manifest.path }}'
                                          content: '{{ job | to_yaml }}'
                                      vars:
                                          job:
                                              apiVersion: batch/v1
                                              kind: Job
                                              metadata:
                                                  name: '{{ SELF.database_name }}-{{ HOST.dbms_name }}'
                                              spec:
                                                  template:
                                                      spec:
                                                          restartPolicy: Never
                                                          containers:
                                                              - name: '{{ SELF.database_name }}-{{ HOST.dbms_name }}'
                                                                image: mysql:{{ ".artifacts::dbms_image::file" | eval }}
                                                                command:
                                                                    - mysql
                                                                    - '--host={{ HOST.management_address }}'
                                                                    - '--port={{ HOST.management_port }}'
                                                                    - '--user=root'
                                                                    - '--password={{ HOST.dbms_password }}'
                                                                    - '-e'
                                                                    - CREATE DATABASE IF NOT EXISTS {{ SELF.database_name }}; CREATE USER IF NOT EXISTS '{{ SELF.database_user }}'@'%' IDENTIFIED BY '{{ SELF.database_password }}'; GRANT ALL PRIVILEGES ON *.* TO '{{ SELF.database_user }}'@'%';
                                    - name: apply manifest
                                      ansible.builtin.shell: kubectl --server {{ SELF.k8s_host }} --certificate-authority {{ SELF.k8s_ca_cert_file }} --client-certificate {{ SELF.k8s_client_cert_file }} --client-key {{ SELF.k8s_client_key_file }} apply -f {{ manifest.path }}
                                      args:
                                          executable: /usr/bin/bash
                                    - name: wait for deployment
                                      ansible.builtin.shell: kubectl --server {{ SELF.k8s_host }} --certificate-authority {{ SELF.k8s_ca_cert_file }} --client-certificate {{ SELF.k8s_client_cert_file }} --client-key {{ SELF.k8s_client_key_file }} wait --for=condition=complete --timeout=30s job/{{ SELF.database_name }}-{{ HOST.dbms_name }}
                                      args:
                                          executable: /usr/bin/bash
                                    - name: cleanup
                                      ansible.builtin.shell: kubectl --server {{ SELF.k8s_host }} --certificate-authority {{ SELF.k8s_ca_cert_file }} --client-certificate {{ SELF.k8s_client_cert_file }} --client-key {{ SELF.k8s_client_key_file }} delete -f {{ manifest.path }}
                                      args:
                                          executable: /usr/bin/bash
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: touch manifest
                                      register: manifest
                                      ansible.builtin.tempfile:
                                          suffix: '{{ SELF.database_name }}-{{ HOST.dbms_name }}.database.manifest.yaml'
                                    - name: create manifest
                                      ansible.builtin.copy:
                                          dest: '{{ manifest.path }}'
                                          content: '{{ job | to_yaml }}'
                                      vars:
                                          job:
                                              apiVersion: batch/v1
                                              kind: Job
                                              metadata:
                                                  name: '{{ SELF.database_name }}-{{ HOST.dbms_name }}'
                                              spec:
                                                  template:
                                                      spec:
                                                          restartPolicy: Never
                                                          containers:
                                                              - name: '{{ SELF.database_name }}-{{ HOST.dbms_name }}'
                                                                image: mysql:{{ ".artifacts::dbms_image::file" | eval }}
                                                                command:
                                                                    - mysql
                                                                    - '--host={{ HOST.management_address }}'
                                                                    - '--port={{ HOST.management_port }}'
                                                                    - '--user=root'
                                                                    - '--password={{ HOST.dbms_password }}'
                                                                    - '-e'
                                                                    - DROP USER IF EXISTS '{{ SELF.database_user }}'@'%'; DROP DATABASE IF EXISTS {{ SELF.database_name }};
                                    - name: apply manifest
                                      ansible.builtin.shell: kubectl --server {{ SELF.k8s_host }} --certificate-authority {{ SELF.k8s_ca_cert_file }} --client-certificate {{ SELF.k8s_client_cert_file }} --client-key {{ SELF.k8s_client_key_file }} apply -f {{ manifest.path }}
                                      args:
                                          executable: /usr/bin/bash
                                    - name: wait for deployment
                                      ansible.builtin.shell: kubectl --server {{ SELF.k8s_host }} --certificate-authority {{ SELF.k8s_ca_cert_file }} --client-certificate {{ SELF.k8s_client_cert_file }} --client-key {{ SELF.k8s_client_key_file }} wait --for=condition=complete --timeout=30s job/{{ SELF.database_name }}-{{ HOST.dbms_name }}
                                      args:
                                          executable: /usr/bin/bash
                                    - name: cleanup
                                      ansible.builtin.shell: kubectl --server {{ SELF.k8s_host }} --certificate-authority {{ SELF.k8s_ca_cert_file }} --client-certificate {{ SELF.k8s_client_cert_file }} --client-key {{ SELF.k8s_client_key_file }} delete -f {{ manifest.path }}
                                      args:
                                          executable: /usr/bin/bash
    mysql.database~mysql.database::terraform@mysql.dbms->kubernetes.cluster:
        derived_from: mysql.database
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            k8s_host:
                type: string
                default:
                    get_input: k8s_host
            k8s_ca_cert_file:
                type: string
                default:
                    get_input: k8s_ca_cert_file
            k8s_client_cert_file:
                type: string
                default:
                    get_input: k8s_client_cert_file
            k8s_client_key_file:
                type: string
                default:
                    get_input: k8s_client_key_file
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        terraform:
                            - required_providers:
                                  - mysql:
                                        source: petoju/mysql
                                        version: 3.0.48
                        provider:
                            mysql:
                                - endpoint: ${terraform_data.forward_port.input}
                                  password: '{{ HOST.dbms_password }}'
                                  username: root
                        resource:
                            terraform_data:
                                forward_port:
                                    - input: 127.0.0.1:23306
                                      provisioner:
                                          local-exec:
                                              command: |-
                                                  (nohup kubectl --server {{ SELF.k8s_host }} --certificate-authority {{ SELF.k8s_ca_cert_file }} --client-certificate {{ SELF.k8s_client_cert_file }} --client-key {{ SELF.k8s_client_key_file }} port-forward service/{{ HOST.dbms_name }} 23306:3306 > /dev/null 2>&1 &)
                                                  sleep 5s
                                              interpreter:
                                                  - /bin/bash
                                                  - '-c'
                                unforward_port:
                                    - depends_on:
                                          - mysql_grant.user
                                      provisioner:
                                          local-exec:
                                              command: pkill -f "port-forward service/{{ HOST.dbms_name }}"
                                              interpreter:
                                                  - /bin/bash
                                                  - '-c'
                            mysql_database:
                                database:
                                    - name: '{{ SELF.database_name }}'
                            mysql_user:
                                user:
                                    - host: '%'
                                      plaintext_password: '{{ SELF.database_password }}'
                                      user: '{{ SELF.database_user }}'
                            mysql_grant:
                                user:
                                    - database: '{{ SELF.database_name }}'
                                      host: '%'
                                      table: '*'
                                      privileges:
                                          - ALL
                                      user: ${mysql_user.user.user}
    mysql.database~mysql.database::ansible@mysql.dbms->local.machine:
        derived_from: mysql.database
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: install pip
                                      ansible.builtin.apt:
                                          name: python3-pip
                                          state: present
                                    - name: install pymysql
                                      ansible.builtin.pip:
                                          name: pymysql
                                          state: present
                                    - name: create database
                                      community.mysql.mysql_db:
                                          name: '{{ SELF.database_name }}'
                                          login_host: '{{ HOST.application_address }}'
                                          login_password: '{{ HOST.dbms_password }}'
                                          login_port: '{{ HOST.application_port }}'
                                          login_user: root
                                    - name: create user (with privileges)
                                      community.mysql.mysql_user:
                                          name: '{{ SELF.database_user }}'
                                          password: '{{ SELF.database_password }}'
                                          host: '%'
                                          priv: '*.*:ALL'
                                          login_host: '{{ HOST.application_address }}'
                                          login_password: '{{ HOST.dbms_password }}'
                                          login_port: '{{ HOST.application_port }}'
                                          login_user: root
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: delete user (with privileges)
                                      community.mysql.mysql_user:
                                          state: absent
                                          name: '{{ SELF.database_user }}'
                                          password: '{{ SELF.database_password }}'
                                          host: '%'
                                          priv: '*.*:ALL'
                                          login_host: '{{ HOST.application_address }}'
                                          login_password: '{{ HOST.dbms_password }}'
                                          login_port: '{{ HOST.application_port }}'
                                          login_user: root
                                    - name: delete database
                                      community.mysql.mysql_db:
                                          name: '{{ SELF.database_name }}'
                                          state: absent
                                          login_host: '{{ HOST.application_address }}'
                                          login_password: '{{ HOST.dbms_password }}'
                                          login_port: '{{ HOST.application_port }}'
                                          login_user: root
    mysql.database~mysql.database::terraform@mysql.dbms->local.machine:
        derived_from: mysql.database
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        terraform:
                            - required_providers:
                                  - mysql:
                                        source: petoju/mysql
                                        version: 3.0.48
                        provider:
                            mysql:
                                - endpoint: '{{ HOST.application_address }}:{{ HOST.application_port }}'
                                  password: '{{ HOST.dbms_password }}'
                                  username: root
                        resource:
                            mysql_database:
                                database:
                                    - name: '{{ SELF.database_name }}'
                            mysql_user:
                                user:
                                    - host: '%'
                                      plaintext_password: '{{ SELF.database_password }}'
                                      user: '{{ SELF.database_user }}'
                            mysql_grant:
                                user:
                                    - database: '{{ SELF.database_name }}'
                                      host: '%'
                                      table: '*'
                                      privileges:
                                          - ALL
                                      user: ${mysql_user.user.user}
    mysql.database~mysql.database::ansible@mysql.dbms->remote.machine:
        derived_from: mysql.database
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: install pip
                                      ansible.builtin.apt:
                                          name: python3-pip
                                          state: present
                                    - name: install pymysql
                                      ansible.builtin.pip:
                                          name: pymysql
                                          state: present
                                    - name: create database
                                      community.mysql.mysql_db:
                                          name: '{{ SELF.database_name }}'
                                          login_host: '{{ HOST.application_address }}'
                                          login_password: '{{ HOST.dbms_password }}'
                                          login_port: '{{ HOST.application_port }}'
                                          login_user: root
                                    - name: create user (with privileges)
                                      community.mysql.mysql_user:
                                          name: '{{ SELF.database_user }}'
                                          password: '{{ SELF.database_password }}'
                                          host: '%'
                                          priv: '*.*:ALL'
                                          login_host: '{{ HOST.application_address }}'
                                          login_password: '{{ HOST.dbms_password }}'
                                          login_port: '{{ HOST.application_port }}'
                                          login_user: root
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: delete user (with privileges)
                                      community.mysql.mysql_user:
                                          state: absent
                                          name: '{{ SELF.database_user }}'
                                          password: '{{ SELF.database_password }}'
                                          host: '%'
                                          priv: '*.*:ALL'
                                          login_host: '{{ HOST.application_address }}'
                                          login_password: '{{ HOST.dbms_password }}'
                                          login_port: '{{ HOST.application_port }}'
                                          login_user: root
                                    - name: delete database
                                      community.mysql.mysql_db:
                                          name: '{{ SELF.database_name }}'
                                          state: absent
                                          login_host: '{{ HOST.application_address }}'
                                          login_password: '{{ HOST.dbms_password }}'
                                          login_port: '{{ HOST.application_port }}'
                                          login_user: root
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
    mysql.database~mysql.database::terraform@mysql.dbms->remote.machine:
        derived_from: mysql.database
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            os_ssh_host:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        terraform:
                            - required_providers:
                                  - mysql:
                                        source: petoju/mysql
                                        version: 3.0.48
                                    ssh:
                                        source: AndrewChubatiuk/ssh
                                        version: 0.2.3
                        data:
                            ssh_tunnel:
                                mysql:
                                    - remote:
                                          host: '{{ HOST.application_address }}'
                                          port: '{{ HOST.application_port }}'
                        provider:
                            mysql:
                                - endpoint: ${data.ssh_tunnel.mysql.local.address}
                                  password: '{{ HOST.dbms_password }}'
                                  username: root
                            ssh:
                                - auth:
                                      private_key:
                                          content: ${file(pathexpand("{{ SELF.os_ssh_key_file }}"))}
                                  server:
                                      host: '{{ HOST.management_address }}'
                                      port: 22
                                  user: '{{ SELF.os_ssh_user }}'
                        resource:
                            mysql_database:
                                database:
                                    - name: '{{ SELF.database_name }}'
                            mysql_user:
                                user:
                                    - host: '%'
                                      plaintext_password: '{{ SELF.database_password }}'
                                      user: '{{ SELF.database_user }}'
                            mysql_grant:
                                user:
                                    - database: '{{ SELF.database_name }}'
                                      host: '%'
                                      table: '*'
                                      privileges:
                                          - ALL
                                      user: ${mysql_user.user.user}
    minio.server~service.application#docker.image::ansible@docker.engine->local.machine:
        derived_from: minio.server
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        attributes:
            application_address:
                type: string
                default: 127.0.0.1
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: start container
                                      community.docker.docker_container:
                                          name: '{{ SELF.application_name }}'
                                          image: '{{ ".artifacts::docker_image::file" | eval }}'
                                          network_mode: host
                                          env:
                                              MINIO_ROOT_USER: '"{{ SELF.access_key }}"'
                                              MINIO_ROOT_PASSWORD: '"{{ SELF.secret_key }}"'
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: stop container
                                      community.docker.docker_container:
                                          name: '{{ SELF.application_name }}'
                                          state: absent
    minio.server~service.application#docker.image::compose@docker.engine->local.machine:
        derived_from: minio.server
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        attributes:
            application_address:
                type: string
                default: 127.0.0.1
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: touch compose
                                      register: compose
                                      ansible.builtin.tempfile:
                                          suffix: '{{ SELF.application_name }}.compose.yaml'
                                    - name: create compose
                                      ansible.builtin.copy:
                                          dest: '{{ compose.path }}'
                                          content: '{{ manifest | to_yaml }}'
                                      vars:
                                          manifest:
                                              name: '{{ SELF.application_name }}'
                                              services:
                                                  application:
                                                      container_name: '{{ SELF.application_name }}'
                                                      image: '{{ ".artifacts::docker_image::file" | eval }}'
                                                      network_mode: host
                                                      environment:
                                                          MINIO_ROOT_USER: '"{{ SELF.access_key }}"'
                                                          MINIO_ROOT_PASSWORD: '"{{ SELF.secret_key }}"'
                                    - name: apply compose
                                      ansible.builtin.shell: docker compose -f {{ compose.path }} up -d
                                      args:
                                          executable: /usr/bin/bash
                                      environment: {}
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: touch compose
                                      register: compose
                                      ansible.builtin.tempfile:
                                          suffix: '{{ SELF.application_name }}.compose.yaml'
                                    - name: create compose
                                      ansible.builtin.copy:
                                          dest: '{{ compose.path }}'
                                          content: '{{ manifest | to_yaml }}'
                                      vars:
                                          manifest:
                                              name: '{{ SELF.application_name }}'
                                              services:
                                                  application:
                                                      container_name: '{{ SELF.application_name }}'
                                                      image: '{{ ".artifacts::docker_image::file" | eval }}'
                                                      network_mode: host
                                                      environment:
                                                          MINIO_ROOT_USER: '"{{ SELF.access_key }}"'
                                                          MINIO_ROOT_PASSWORD: '"{{ SELF.secret_key }}"'
                                    - name: unapply compose
                                      ansible.builtin.shell: docker compose -f {{ compose.path }} down
                                      args:
                                          executable: /usr/bin/bash
                                      environment: {}
    minio.server~service.application#docker.image::terraform@docker.engine->local.machine:
        derived_from: minio.server
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        attributes:
            application_address:
                type: string
                default: 127.0.0.1
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        terraform:
                            - required_providers:
                                  - docker:
                                        source: kreuzwerker/docker
                                        version: 3.0.2
                              required_version: '>= 0.14.0'
                        provider:
                            docker:
                                - host: unix:///var/run/docker.sock
                        resource:
                            docker_container:
                                application:
                                    - env:
                                          - MINIO_ROOT_USER={{ SELF.access_key }}
                                          - MINIO_ROOT_PASSWORD={{ SELF.secret_key }}
                                      image: ${docker_image.image.image_id}
                                      name: '{{ SELF.application_name }}'
                                      network_mode: host
                            docker_image:
                                image:
                                    - name: '{{ ".artifacts::docker_image::file" | eval }}'
    minio.server~service.application#docker.image::ansible@docker.engine->remote.machine:
        derived_from: minio.server
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
        attributes:
            application_address:
                type: string
                default: 127.0.0.1
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: start container
                                      community.docker.docker_container:
                                          name: '{{ SELF.application_name }}'
                                          image: '{{ ".artifacts::docker_image::file" | eval }}'
                                          network_mode: host
                                          env:
                                              MINIO_ROOT_USER: '"{{ SELF.access_key }}"'
                                              MINIO_ROOT_PASSWORD: '"{{ SELF.secret_key }}"'
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: stop container
                                      community.docker.docker_container:
                                          name: '{{ SELF.application_name }}'
                                          state: absent
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
    minio.server~service.application#docker.image::compose@docker.engine->remote.machine:
        derived_from: minio.server
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            os_ssh_host:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
        attributes:
            application_address:
                type: string
                default: 127.0.0.1
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: touch compose
                                      register: compose
                                      ansible.builtin.tempfile:
                                          suffix: '{{ SELF.application_name }}.compose.yaml'
                                    - name: create compose
                                      ansible.builtin.copy:
                                          dest: '{{ compose.path }}'
                                          content: '{{ manifest | to_yaml }}'
                                      vars:
                                          manifest:
                                              name: '{{ SELF.application_name }}'
                                              services:
                                                  application:
                                                      container_name: '{{ SELF.application_name }}'
                                                      image: '{{ ".artifacts::docker_image::file" | eval }}'
                                                      network_mode: host
                                                      environment:
                                                          MINIO_ROOT_USER: '"{{ SELF.access_key }}"'
                                                          MINIO_ROOT_PASSWORD: '"{{ SELF.secret_key }}"'
                                    - name: add ssh credentials
                                      community.general.ssh_config:
                                          user: "{{ lookup('env', 'USER') }}"
                                          host: '{{ SELF.os_ssh_host }}'
                                          remote_user: '{{ SELF.os_ssh_user }}'
                                          identity_file: '{{ SELF.os_ssh_key_file }}'
                                          strict_host_key_checking: 'no'
                                          user_known_hosts_file: /dev/null
                                    - name: apply compose
                                      ansible.builtin.shell: docker compose -f {{ compose.path }} up -d
                                      args:
                                          executable: /usr/bin/bash
                                      environment:
                                          DOCKER_HOST: ssh://{{ SELF.os_ssh_host }}
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: touch compose
                                      register: compose
                                      ansible.builtin.tempfile:
                                          suffix: '{{ SELF.application_name }}.compose.yaml'
                                    - name: create compose
                                      ansible.builtin.copy:
                                          dest: '{{ compose.path }}'
                                          content: '{{ manifest | to_yaml }}'
                                      vars:
                                          manifest:
                                              name: '{{ SELF.application_name }}'
                                              services:
                                                  application:
                                                      container_name: '{{ SELF.application_name }}'
                                                      image: '{{ ".artifacts::docker_image::file" | eval }}'
                                                      network_mode: host
                                                      environment:
                                                          MINIO_ROOT_USER: '"{{ SELF.access_key }}"'
                                                          MINIO_ROOT_PASSWORD: '"{{ SELF.secret_key }}"'
                                    - name: unapply compose
                                      ansible.builtin.shell: docker compose -f {{ compose.path }} down
                                      args:
                                          executable: /usr/bin/bash
                                      environment:
                                          DOCKER_HOST: ssh://{{ SELF.os_ssh_host }}
                                    - name: remove ssh credentials
                                      community.general.ssh_config:
                                          user: "{{ lookup('env', 'USER') }}"
                                          host: '{{ SELF.os_ssh_host }}'
                                          state: absent
    minio.server~service.application#docker.image::terraform@docker.engine->remote.machine:
        derived_from: minio.server
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            os_ssh_host:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
        attributes:
            application_address:
                type: string
                default: 127.0.0.1
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        terraform:
                            - required_providers:
                                  - docker:
                                        source: kreuzwerker/docker
                                        version: 3.0.2
                        provider:
                            docker:
                                - host: ssh://{{ SELF.os_ssh_user }}@{{ SELF.os_ssh_host }}:22
                                  ssh_opts:
                                      - '-i'
                                      - '{{ SELF.os_ssh_key_file }}'
                                      - '-o'
                                      - IdentitiesOnly=yes
                                      - '-o'
                                      - BatchMode=yes
                                      - '-o'
                                      - UserKnownHostsFile=/dev/null
                                      - '-o'
                                      - StrictHostKeyChecking=no
                        resource:
                            docker_container:
                                application:
                                    - env:
                                          - MINIO_ROOT_USER={{ SELF.access_key }}
                                          - MINIO_ROOT_PASSWORD={{ SELF.secret_key }}
                                      image: ${docker_image.image.image_id}
                                      name: '{{ SELF.application_name }}'
                                      network_mode: host
                            docker_image:
                                image:
                                    - name: '{{ ".artifacts::docker_image::file" | eval }}'
    minio.server~service.application#docker.image::ansible@gcp.cloudrun:
        derived_from: minio.server
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            gcp_service_account_file:
                type: string
                default:
                    get_input: gcp_service_account_file
            gcp_region:
                type: string
                default:
                    get_input: gcp_region
            gcp_project:
                type: string
                default:
                    get_input: gcp_project
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: activate service account
                                      ansible.builtin.shell: gcloud auth activate-service-account --key-file {{ SELF.gcp_service_account_file }} --project {{ SELF.gcp_project }}
                                      args:
                                          executable: /bin/bash
                                    - name: touch service
                                      register: service
                                      ansible.builtin.tempfile:
                                          suffix: '{{ SELF.application_name }}.service.yaml'
                                    - name: create service
                                      ansible.builtin.copy:
                                          dest: '{{ service.path }}'
                                          content: '{{ manifest | to_yaml }}'
                                      vars:
                                          manifest:
                                              apiVersion: serving.knative.dev/v1
                                              kind: Service
                                              metadata:
                                                  name: '{{ SELF.application_name }}'
                                                  labels:
                                                      cloud.googleapis.com/location: '{{ SELF.gcp_region }}'
                                                  annotations:
                                                      run.googleapis.com/ingress: all
                                              spec:
                                                  template:
                                                      spec:
                                                          containers:
                                                              - image: '{{ ".artifacts::docker_image::file" | eval }}'
                                                                ports:
                                                                    - name: http1
                                                                      containerPort: '{{ SELF.application_port }}'
                                                                env:
                                                                    - name: MINIO_ROOT_USER
                                                                      value: '"{{ SELF.access_key }}"'
                                                                    - name: MINIO_ROOT_PASSWORD
                                                                      value: '"{{ SELF.secret_key }}"'
                                    - name: apply service
                                      ansible.builtin.shell: gcloud run services replace {{ service.path }} --quiet
                                      args:
                                          executable: /bin/bash
                                    - name: touch policy
                                      register: policy
                                      ansible.builtin.tempfile:
                                          suffix: '{{ SELF.application_name }}.policy.yaml'
                                    - name: fill policy
                                      ansible.builtin.copy:
                                          dest: '{{ policy.path }}'
                                          content: '{{ manifest | to_yaml }}'
                                      vars:
                                          manifest:
                                              bindings:
                                                  - members:
                                                        - allUsers
                                                    role: roles/run.invoker
                                    - name: apply policy
                                      ansible.builtin.shell: gcloud run services set-iam-policy {{ SELF.application_name }} {{ policy.path }} --region {{ SELF.gcp_region }} --quiet
                                      args:
                                          executable: /bin/bash
                                    - name: describe service
                                      register: service_description
                                      ansible.builtin.shell: gcloud run services describe {{ SELF.application_name }} --region {{ SELF.gcp_region }} --quiet --format=json
                                      args:
                                          executable: /bin/bash
                                    - name: set attributes
                                      set_fact:
                                          application_address: '{{ (service_description.stdout | from_json ).status.url[8:] | trim }}'
                                          application_endpoint: '{{ SELF.application_protocol if SELF.application_protocol.endswith("s") else SELF.application_protocol + "s" }}://{{ (service_description.stdout | from_json ).status.url[8:] | trim }}:443'
                            resultTemplate: |
                                name: SELF
                                attributes:
                                    application_address: '{{ outputs.application_address | trim }}'
                                    application_endpoint: '{{ outputs.application_endpoint | trim }}'
                        outputs:
                            application_address:
                            application_endpoint:
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: activate service account
                                      ansible.builtin.shell: gcloud auth activate-service-account --key-file {{ SELF.gcp_service_account_file }} --project {{ SELF.gcp_project }}
                                      args:
                                          executable: /bin/bash
                                    - name: delete app
                                      ansible.builtin.shell: gcloud run services delete {{ SELF.application_name }} --region {{ SELF.gcp_region }} --quiet
                                      args:
                                          executable: /bin/bash
    minio.server~service.application#docker.image::terraform@gcp.cloudrun:
        derived_from: minio.server
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            gcp_service_account_file:
                type: string
                default:
                    get_input: gcp_service_account_file
            gcp_region:
                type: string
                default:
                    get_input: gcp_region
            gcp_project:
                type: string
                default:
                    get_input: gcp_project
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                outputs:
                    application_address: application_address
                    application_endpoint: application_endpoint
                inputs:
                    main:
                        terraform:
                            - required_providers:
                                  - google:
                                        source: hashicorp/google
                                        version: 5.39.1
                        provider:
                            google:
                                - credentials: '{{ SELF.gcp_service_account_file }}'
                                  project: '{{ SELF.gcp_project }}'
                                  region: '{{ SELF.gcp_region }}'
                        output:
                            application_address:
                                - value: ${substr(google_cloud_run_v2_service.application.uri, 8, -1)}
                            application_endpoint:
                                - value: '{{ SELF.application_protocol if SELF.application_protocol.endswith("s") else SELF.application_protocol + "s" }}://${substr(google_cloud_run_v2_service.application.uri, 8, -1)}:443'
                        resource:
                            google_cloud_run_v2_service:
                                application:
                                    - ingress: INGRESS_TRAFFIC_ALL
                                      location: '{{ SELF.gcp_region }}'
                                      name: '{{ SELF.application_name }}'
                                      template:
                                          - containers:
                                                - image: '{{ ".artifacts::docker_image::file" | eval }}'
                                                  ports:
                                                      - name: http1
                                                        container_port: '{{ SELF.application_port }}'
                                                  env:
                                                      - name: MINIO_ROOT_USER
                                                        value: '"{{ SELF.access_key }}"'
                                                      - name: MINIO_ROOT_PASSWORD
                                                        value: '"{{ SELF.secret_key }}"'
                            google_cloud_run_service_iam_binding:
                                application:
                                    - location: '{{ SELF.gcp_region }}'
                                      members:
                                          - allUsers
                                      role: roles/run.invoker
                                      service: '{{ SELF.application_name }}'
    minio.server~service.application#docker.image::ansible@kubernetes.cluster:
        derived_from: minio.server
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            k8s_host:
                type: string
                default:
                    get_input: k8s_host
            k8s_ca_cert_file:
                type: string
                default:
                    get_input: k8s_ca_cert_file
            k8s_client_cert_file:
                type: string
                default:
                    get_input: k8s_client_cert_file
            k8s_client_key_file:
                type: string
                default:
                    get_input: k8s_client_key_file
        attributes:
            application_address:
                type: string
                default:
                    eval: .::application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                            environment:
                                K8S_AUTH_HOST:
                                    eval: .::k8s_host
                                K8S_AUTH_SSL_CA_CERT:
                                    eval: .::k8s_ca_cert_file
                                K8S_AUTH_CERT_FILE:
                                    eval: .::k8s_client_cert_file
                                K8S_AUTH_KEY_FILE:
                                    eval: .::k8s_client_key_file
                        inputs:
                            playbook:
                                q:
                                    - name: create deployment
                                      kubernetes.core.k8s:
                                          wait: true
                                          definition:
                                              apiVersion: apps/v1
                                              kind: Deployment
                                              metadata:
                                                  name: '{{ SELF.application_name }}'
                                                  namespace: default
                                              spec:
                                                  selector:
                                                      matchLabels:
                                                          app: '{{ SELF.application_name }}'
                                                  template:
                                                      metadata:
                                                          labels:
                                                              app: '{{ SELF.application_name }}'
                                                      spec:
                                                          containers:
                                                              - image: '{{ ".artifacts::docker_image::file" | eval }}'
                                                                name: '{{ SELF.application_name }}'
                                                                env:
                                                                    - name: MINIO_ROOT_USER
                                                                      value: '"{{ SELF.access_key }}"'
                                                                    - name: MINIO_ROOT_PASSWORD
                                                                      value: '"{{ SELF.secret_key }}"'
                                                                ports:
                                                                    - containerPort: '{{ SELF.application_port }}'
                                    - name: create service
                                      kubernetes.core.k8s:
                                          definition:
                                              apiVersion: v1
                                              kind: Service
                                              metadata:
                                                  name: '{{ SELF.application_name }}'
                                                  namespace: default
                                              spec:
                                                  ports:
                                                      - name: '{{ SELF.application_protocol }}'
                                                        port: '{{ SELF.application_port }}'
                                                        targetPort: '{{ SELF.application_port }}'
                                                  selector:
                                                      app: '{{ SELF.application_name }}'
                                                  type: ClusterIP
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                            environment:
                                K8S_AUTH_HOST:
                                    eval: .::k8s_host
                                K8S_AUTH_SSL_CA_CERT:
                                    eval: .::k8s_ca_cert_file
                                K8S_AUTH_CERT_FILE:
                                    eval: .::k8s_client_cert_file
                                K8S_AUTH_KEY_FILE:
                                    eval: .::k8s_client_key_file
                        inputs:
                            playbook:
                                q:
                                    - name: delete service
                                      kubernetes.core.k8s:
                                          state: absent
                                          api_version: v1
                                          kind: Service
                                          namespace: default
                                          name: '{{ SELF.application_name }}'
                                    - name: delete deployment
                                      kubernetes.core.k8s:
                                          state: absent
                                          api_version: app/v1
                                          kind: Deployment
                                          namespace: default
                                          name: '{{ SELF.application_name }}'
    minio.server~service.application#docker.image::kubernetes@kubernetes.cluster:
        derived_from: minio.server
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        attributes:
            application_address:
                type: string
                default:
                    eval: .::application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: touch manifest
                                      register: manifest
                                      ansible.builtin.tempfile:
                                          suffix: '{{ SELF.application_name }}.application.manifest.yaml'
                                    - name: create manifest
                                      ansible.builtin.copy:
                                          dest: '{{ manifest.path }}'
                                          content: |
                                              {{ deployment | to_yaml }}
                                              ---
                                              {{ service | to_yaml }}
                                      vars:
                                          deployment:
                                              apiVersion: apps/v1
                                              kind: Deployment
                                              metadata:
                                                  name: '{{ SELF.application_name }}'
                                                  namespace: default
                                              spec:
                                                  selector:
                                                      matchLabels:
                                                          app: '{{ SELF.application_name }}'
                                                  template:
                                                      metadata:
                                                          labels:
                                                              app: '{{ SELF.application_name }}'
                                                      spec:
                                                          containers:
                                                              - image: '{{ ".artifacts::docker_image::file" | eval }}'
                                                                name: '{{ SELF.application_name }}'
                                                                env:
                                                                    - name: MINIO_ROOT_USER
                                                                      value: '"{{ SELF.access_key }}"'
                                                                    - name: MINIO_ROOT_PASSWORD
                                                                      value: '"{{ SELF.secret_key }}"'
                                                                ports:
                                                                    - containerPort: '{{ SELF.application_port }}'
                                          service:
                                              apiVersion: v1
                                              kind: Service
                                              metadata:
                                                  name: '{{ SELF.application_name }}'
                                                  namespace: default
                                              spec:
                                                  ports:
                                                      - name: '{{ SELF.application_protocol }}'
                                                        port: '{{ SELF.application_port }}'
                                                        targetPort: '{{ SELF.application_port }}'
                                                  selector:
                                                      app: '{{ SELF.application_name }}'
                                                  type: ClusterIP
                                    - name: apply manifest
                                      ansible.builtin.shell: kubectl --server {{ SELF.k8s_host }} --certificate-authority {{ SELF.k8s_ca_cert_file }} --client-certificate {{ SELF.k8s_client_cert_file }} --client-key {{ SELF.k8s_client_key_file }} apply -f {{ manifest.path }}
                                      args:
                                          executable: /usr/bin/bash
                                    - name: wait for deployment
                                      ansible.builtin.shell: kubectl --server {{ SELF.k8s_host }} --certificate-authority {{ SELF.k8s_ca_cert_file }} --client-certificate {{ SELF.k8s_client_cert_file }} --client-key {{ SELF.k8s_client_key_file }} rollout status deployment/{{ SELF.application_name }} --timeout 60s
                                      args:
                                          executable: /usr/bin/bash
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: touch manifest
                                      register: manifest
                                      ansible.builtin.tempfile:
                                          suffix: '{{ SELF.application_name }}.application.manifest.yaml'
                                    - name: create manifest
                                      ansible.builtin.copy:
                                          dest: '{{ manifest.path }}'
                                          content: |
                                              {{ deployment | to_yaml }}
                                              ---
                                              {{ service | to_yaml }}
                                      vars:
                                          deployment:
                                              apiVersion: apps/v1
                                              kind: Deployment
                                              metadata:
                                                  name: '{{ SELF.application_name }}'
                                                  namespace: default
                                              spec:
                                                  selector:
                                                      matchLabels:
                                                          app: '{{ SELF.application_name }}'
                                                  template:
                                                      metadata:
                                                          labels:
                                                              app: '{{ SELF.application_name }}'
                                                      spec:
                                                          containers:
                                                              - image: '{{ ".artifacts::docker_image::file" | eval }}'
                                                                name: '{{ SELF.application_name }}'
                                                                env:
                                                                    - name: MINIO_ROOT_USER
                                                                      value: '"{{ SELF.access_key }}"'
                                                                    - name: MINIO_ROOT_PASSWORD
                                                                      value: '"{{ SELF.secret_key }}"'
                                                                ports:
                                                                    - containerPort: '{{ SELF.application_port }}'
                                          service:
                                              apiVersion: v1
                                              kind: Service
                                              metadata:
                                                  name: '{{ SELF.application_name }}'
                                                  namespace: default
                                              spec:
                                                  ports:
                                                      - name: '{{ SELF.application_protocol }}'
                                                        port: '{{ SELF.application_port }}'
                                                        targetPort: '{{ SELF.application_port }}'
                                                  selector:
                                                      app: '{{ SELF.application_name }}'
                                                  type: ClusterIP
                                    - name: unapply manifest
                                      ansible.builtin.shell: kubectl --server {{ SELF.k8s_host }} --certificate-authority {{ SELF.k8s_ca_cert_file }} --client-certificate {{ SELF.k8s_client_cert_file }} --client-key {{ SELF.k8s_client_key_file }} delete -f {{ manifest.path }}
                                      args:
                                          executable: /usr/bin/bash
    minio.server~service.application#docker.image::terraform@kubernetes.cluster:
        derived_from: minio.server
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            k8s_host:
                type: string
                default:
                    get_input: k8s_host
            k8s_ca_cert_file:
                type: string
                default:
                    get_input: k8s_ca_cert_file
            k8s_client_cert_file:
                type: string
                default:
                    get_input: k8s_client_cert_file
            k8s_client_key_file:
                type: string
                default:
                    get_input: k8s_client_key_file
        attributes:
            application_address:
                type: string
                default:
                    eval: .::application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        terraform:
                            - required_providers:
                                  - kubernetes:
                                        source: hashicorp/kubernetes
                                        version: 2.31.0
                              required_version: '>= 0.14.0'
                        provider:
                            kubernetes:
                                - client_certificate: ${file("{{ SELF.k8s_client_cert_file }}")}
                                  client_key: ${file("{{ SELF.k8s_client_key_file }}")}
                                  cluster_ca_certificate: ${file("{{ SELF.k8s_ca_cert_file }}")}
                                  host: '{{ SELF.k8s_host }}'
                        resource:
                            kubernetes_deployment_v1:
                                application:
                                    - metadata:
                                          - name: '{{ SELF.application_name }}'
                                      spec:
                                          - selector:
                                                - match_labels:
                                                      app: '{{ SELF.application_name }}'
                                            template:
                                                - metadata:
                                                      - labels:
                                                            app: '{{ SELF.application_name }}'
                                                  spec:
                                                      - container:
                                                            - env:
                                                                  - name: MINIO_ROOT_USER
                                                                    value: '"{{ SELF.access_key }}"'
                                                                  - name: MINIO_ROOT_PASSWORD
                                                                    value: '"{{ SELF.secret_key }}"'
                                                              image: '{{ ".artifacts::docker_image::file" | eval }}'
                                                              name: '{{ SELF.application_name }}'
                                                              port:
                                                                  - container_port: '{{ SELF.application_port }}'
                            kubernetes_service_v1:
                                application:
                                    - metadata:
                                          - name: '{{ SELF.application_name }}'
                                      spec:
                                          - port:
                                                - name: '{{ SELF.application_protocol }}'
                                                  port: '{{ SELF.application_port }}'
                                                  target_port: '{{ SELF.application_port }}'
                                            selector:
                                                app: '{{ SELF.application_name }}'
                                            type: ClusterIP
    minio.server~service.application#tar.archive::ansible@*->local.machine:
        derived_from: minio.server
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: extract deployment artifact in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          extra_opts: '{{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}'
                                      when: not (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")
                                    - name: extract deployment artifact from URL in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          remote_src: 'yes'
                                          extra_opts: '{{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}'
                                      when: (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")
                                    - name: create vintner directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}/.vintner'
                                          state: directory
                                    - name: create .env file
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.env'
                                          content: |-
                                              MINIO_ROOT_USER="{{ SELF.access_key }}"
                                              MINIO_ROOT_PASSWORD="{{ SELF.secret_key }}"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: create service
                                      ansible.builtin.copy:
                                          dest: /etc/systemd/system/{{ SELF.application_name }}.service
                                          content: |
                                              [Unit]
                                              After=network.target

                                              [Service]
                                              Type=simple
                                              ExecStart=/usr/bin/bash -c ". ./.vintner/start.sh"
                                              WorkingDirectory={{ SELF.application_directory }}
                                              EnvironmentFile={{ SELF.application_directory }}/.env

                                              [Install]
                                              WantedBy=multi-user.target
                                    - name: enable service
                                      ansible.builtin.systemd:
                                          name: '{{ SELF.application_name }}'
                                          state: stopped
                                          enabled: 'yes'
                                          daemon_reload: 'yes'
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "start" missing
                                      when: SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: start service
                                      ansible.builtin.systemd:
                                          name: '{{ SELF.application_name }}'
                                          state: started
                                          enabled: 'yes'
                                          daemon_reload: 'yes'
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "stop" missing
                                      when: SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: stop service
                                      ansible.builtin.systemd:
                                          name: '{{ SELF.application_name }}'
                                          state: stopped
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
                                    - name: delete systemd service
                                      ansible.builtin.file:
                                          path: /etc/systemd/system/{{ SELF.application_name }}.service
                                          state: absent
                                    - name: reload daemon
                                      ansible.builtin.systemd:
                                          daemon_reload: true
    minio.server~service.application#tar.archive::terraform@*->local.machine:
        derived_from: minio.server
        metadata:
            vintner_generated: 'true'
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            local_file:
                                tmp_artifact:
                                    source: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                    filename: /tmp/artifact-minio.server
                                    count: '{{ (not (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")) | ternary(1, 0) }}'
                                tmp_service:
                                    content: |
                                        [Unit]
                                        After=network.target

                                        [Service]
                                        Type=simple
                                        ExecStart=/usr/bin/bash -c ". ./.vintner/start.sh"
                                        WorkingDirectory={{ SELF.application_directory }}
                                        EnvironmentFile={{ SELF.application_directory }}/.env

                                        [Install]
                                        WantedBy=multi-user.target
                                    filename: /etc/systemd/system/{{ SELF.application_name }}.service
                                tmp_create:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Create application directory
                                        mkdir -p {{ SELF.application_directory }}

                                        # Create application environment
                                        cat <<EOF > {{ SELF.application_directory }}/.env
                                        MINIO_ROOT_USER="{{ SELF.access_key }}"
                                        MINIO_ROOT_PASSWORD="{{ SELF.secret_key }}"
                                        EOF>>

                                        # Download deployment artifact if required
                                        if [[ "{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}" == http* ]]; then 
                                            wget -O /tmp/artifact-minio.server {{ ".artifacts::*::[.type=tar.archive]::file" | eval }} 
                                        fi

                                        # Extract deployment artifact
                                        tar -xzf /tmp/artifact-minio.server -C {{ SELF.application_directory }} {{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}

                                        # Create vintner directory
                                        mkdir -p {{ SELF.application_directory }}/.vintner

                                        # Reload systemd daemon
                                        systemctl daemon-reload

                                        # Enable service 
                                        systemctl enable {{ SELF.application_name }}
                                    filename: /tmp/create-minio.server.sh
                                tmp_configure:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/configure.sh
                                    filename: /tmp/configure-minio.server.sh
                                tmp_start:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Assert operation
                                        if [[ "{{ SELF._management_start | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                            echo 'Management operation "start" missing'
                                            exit 1 
                                        fi

                                        # Start service 
                                        systemctl start {{ SELF.application_name }}
                                    filename: /tmp/start-minio.server.sh
                                tmp_stop:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Assert operation
                                        if [[ "{{ SELF._management_stop | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                            echo 'Management operation "stop" missing'
                                            exit 1 
                                        fi

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/stop.sh

                                        # Stop service 
                                        systemctl stop {{ SELF.application_name }}
                                    filename: /tmp/stop-minio.server.sh
                                tmp_delete:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/delete.sh

                                        # Delete application directory
                                        rm -rf "{{ SELF.application_directory }}"

                                        # Delete systemd service 
                                        rm -f /etc/systemd/system/{{ SELF.application_name }}.service

                                        # Reload system daemon
                                        systemctl daemon-reload
                                    filename: /tmp/delete-minio.server.sh
                            terraform_data:
                                local:
                                    - depends_on:
                                          - local_file.tmp_artifact
                                          - local_file.tmp_service
                                          - local_file.tmp_create
                                          - local_file.tmp_configure
                                          - local_file.tmp_start
                                          - local_file.tmp_stop
                                          - local_file.tmp_delete
                                      provisioner:
                                          local-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-minio.server.sh
                                                    - sudo bash /tmp/configure-minio.server.sh
                                                    - sudo bash /tmp/start-minio.server.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-minio.server.sh
                                                    - sudo bash /tmp/delete-minio.server.sh
                                                when: destroy
    minio.server~service.application#tar.archive::ansible@*->remote.machine:
        derived_from: minio.server
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: extract deployment artifact in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          extra_opts: '{{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}'
                                      when: not (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")
                                    - name: extract deployment artifact from URL in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          remote_src: 'yes'
                                          extra_opts: '{{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}'
                                      when: (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")
                                    - name: create vintner directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}/.vintner'
                                          state: directory
                                    - name: create .env file
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.env'
                                          content: |-
                                              MINIO_ROOT_USER="{{ SELF.access_key }}"
                                              MINIO_ROOT_PASSWORD="{{ SELF.secret_key }}"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: create service
                                      ansible.builtin.copy:
                                          dest: /etc/systemd/system/{{ SELF.application_name }}.service
                                          content: |
                                              [Unit]
                                              After=network.target

                                              [Service]
                                              Type=simple
                                              ExecStart=/usr/bin/bash -c ". ./.vintner/start.sh"
                                              WorkingDirectory={{ SELF.application_directory }}
                                              EnvironmentFile={{ SELF.application_directory }}/.env

                                              [Install]
                                              WantedBy=multi-user.target
                                    - name: enable service
                                      ansible.builtin.systemd:
                                          name: '{{ SELF.application_name }}'
                                          state: stopped
                                          enabled: 'yes'
                                          daemon_reload: 'yes'
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "start" missing
                                      when: SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: start service
                                      ansible.builtin.systemd:
                                          name: '{{ SELF.application_name }}'
                                          state: started
                                          enabled: 'yes'
                                          daemon_reload: 'yes'
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "stop" missing
                                      when: SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: stop service
                                      ansible.builtin.systemd:
                                          name: '{{ SELF.application_name }}'
                                          state: stopped
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
                                    - name: delete systemd service
                                      ansible.builtin.file:
                                          path: /etc/systemd/system/{{ SELF.application_name }}.service
                                          state: absent
                                    - name: reload daemon
                                      ansible.builtin.systemd:
                                          daemon_reload: true
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
    minio.server~service.application#tar.archive::terraform@*->remote.machine:
        derived_from: minio.server
        metadata:
            vintner_generated: 'true'
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            os_ssh_host:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            terraform_data:
                                vm:
                                    - connection:
                                          - host: '{{ SELF.os_ssh_host }}'
                                            private_key: ${file("{{ SELF.os_ssh_key_file }}")}
                                            type: ssh
                                            user: '{{ SELF.os_ssh_user }}'
                                      provisioner:
                                          file:
                                              - source: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                                destination: /tmp/artifact-minio.server
                                                count: '{{ (not (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")) | ternary(1, 0) }}'
                                              - content: |
                                                    [Unit]
                                                    After=network.target

                                                    [Service]
                                                    Type=simple
                                                    ExecStart=/usr/bin/bash -c ". ./.vintner/start.sh"
                                                    WorkingDirectory={{ SELF.application_directory }}
                                                    EnvironmentFile={{ SELF.application_directory }}/.env

                                                    [Install]
                                                    WantedBy=multi-user.target
                                                destination: /etc/systemd/system/{{ SELF.application_name }}.service
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Create application directory
                                                    mkdir -p {{ SELF.application_directory }}

                                                    # Create application environment
                                                    cat <<EOF > {{ SELF.application_directory }}/.env
                                                    MINIO_ROOT_USER="{{ SELF.access_key }}"
                                                    MINIO_ROOT_PASSWORD="{{ SELF.secret_key }}"
                                                    EOF>>

                                                    # Download deployment artifact if required
                                                    if [[ "{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}" == http* ]]; then 
                                                        wget -O /tmp/artifact-minio.server {{ ".artifacts::*::[.type=tar.archive]::file" | eval }} 
                                                    fi

                                                    # Extract deployment artifact
                                                    tar -xzf /tmp/artifact-minio.server -C {{ SELF.application_directory }} {{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}

                                                    # Create vintner directory
                                                    mkdir -p {{ SELF.application_directory }}/.vintner

                                                    # Reload systemd daemon
                                                    systemctl daemon-reload

                                                    # Enable service 
                                                    systemctl enable {{ SELF.application_name }}
                                                destination: /tmp/create-minio.server.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/configure.sh
                                                destination: /tmp/configure-minio.server.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Assert operation
                                                    if [[ "{{ SELF._management_start | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                                        echo 'Management operation "start" missing'
                                                        exit 1 
                                                    fi

                                                    # Start service 
                                                    systemctl start {{ SELF.application_name }}
                                                destination: /tmp/start-minio.server.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Assert operation
                                                    if [[ "{{ SELF._management_stop | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                                        echo 'Management operation "stop" missing'
                                                        exit 1 
                                                    fi

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/stop.sh

                                                    # Stop service 
                                                    systemctl stop {{ SELF.application_name }}
                                                destination: /tmp/stop-minio.server.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/delete.sh

                                                    # Delete application directory
                                                    rm -rf "{{ SELF.application_directory }}"

                                                    # Delete systemd service 
                                                    rm -f /etc/systemd/system/{{ SELF.application_name }}.service

                                                    # Reload system daemon
                                                    systemctl daemon-reload
                                                destination: /tmp/delete-minio.server.sh
                                          remote-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-minio.server.sh
                                                    - sudo bash /tmp/configure-minio.server.sh
                                                    - sudo bash /tmp/start-minio.server.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-minio.server.sh
                                                    - sudo bash /tmp/delete-minio.server.sh
                                                when: destroy
    minio.server~service.application#zip.archive::ansible@*->local.machine:
        derived_from: minio.server
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: install operational dependencies
                                      ansible.builtin.apt:
                                          name: unzip
                                          update_cache: 'yes'
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: extract deployment artifact in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          extra_opts: '{{ ".artifacts::*::[.type=zip.archive]::extra_opts" | eval | map_value }}'
                                      when: not (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")
                                    - name: extract deployment artifact from URL in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          remote_src: 'yes'
                                          extra_opts: '{{ ".artifacts::*::[.type=zip.archive]::extra_opts" | eval | map_value }}'
                                      when: (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")
                                    - name: create vintner directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}/.vintner'
                                          state: directory
                                    - name: create .env file
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.env'
                                          content: |-
                                              MINIO_ROOT_USER="{{ SELF.access_key }}"
                                              MINIO_ROOT_PASSWORD="{{ SELF.secret_key }}"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: create service
                                      ansible.builtin.copy:
                                          dest: /etc/systemd/system/{{ SELF.application_name }}.service
                                          content: |
                                              [Unit]
                                              After=network.target

                                              [Service]
                                              Type=simple
                                              ExecStart=/usr/bin/bash -c ". ./.vintner/start.sh"
                                              WorkingDirectory={{ SELF.application_directory }}
                                              EnvironmentFile={{ SELF.application_directory }}/.env

                                              [Install]
                                              WantedBy=multi-user.target
                                    - name: enable service
                                      ansible.builtin.systemd:
                                          name: '{{ SELF.application_name }}'
                                          state: stopped
                                          enabled: 'yes'
                                          daemon_reload: 'yes'
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "start" missing
                                      when: SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: start service
                                      ansible.builtin.systemd:
                                          name: '{{ SELF.application_name }}'
                                          state: started
                                          enabled: 'yes'
                                          daemon_reload: 'yes'
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "stop" missing
                                      when: SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: stop service
                                      ansible.builtin.systemd:
                                          name: '{{ SELF.application_name }}'
                                          state: stopped
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
                                    - name: delete systemd service
                                      ansible.builtin.file:
                                          path: /etc/systemd/system/{{ SELF.application_name }}.service
                                          state: absent
                                    - name: reload daemon
                                      ansible.builtin.systemd:
                                          daemon_reload: true
    minio.server~service.application#zip.archive::terraform@*->local.machine:
        derived_from: minio.server
        metadata:
            vintner_generated: 'true'
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            local_file:
                                tmp_artifact:
                                    source: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                    filename: /tmp/artifact-minio.server
                                    count: '{{ (not (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")) | ternary(1, 0) }}'
                                tmp_service:
                                    content: |
                                        [Unit]
                                        After=network.target

                                        [Service]
                                        Type=simple
                                        ExecStart=/usr/bin/bash -c ". ./.vintner/start.sh"
                                        WorkingDirectory={{ SELF.application_directory }}
                                        EnvironmentFile={{ SELF.application_directory }}/.env

                                        [Install]
                                        WantedBy=multi-user.target
                                    filename: /etc/systemd/system/{{ SELF.application_name }}.service
                                tmp_create:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Create application directory
                                        mkdir -p {{ SELF.application_directory }}

                                        # Create application environment
                                        cat <<EOF > {{ SELF.application_directory }}/.env
                                        MINIO_ROOT_USER="{{ SELF.access_key }}"
                                        MINIO_ROOT_PASSWORD="{{ SELF.secret_key }}"
                                        EOF>>

                                        # Download deployment artifact if required
                                        if [[ "{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}" == http* ]]; then 
                                            wget -O /tmp/artifact-minio.server {{ ".artifacts::*::[.type=zip.archive]::file" | eval }} 
                                        fi

                                        # Extract deployment artifact
                                        unzip /tmp/artifact-minio.server -d {{ SELF.application_directory }} {{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}

                                        # Create vintner directory
                                        mkdir -p {{ SELF.application_directory }}/.vintner

                                        # Reload systemd daemon
                                        systemctl daemon-reload

                                        # Enable service 
                                        systemctl enable {{ SELF.application_name }}
                                    filename: /tmp/create-minio.server.sh
                                tmp_configure:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/configure.sh
                                    filename: /tmp/configure-minio.server.sh
                                tmp_start:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Assert operation
                                        if [[ "{{ SELF._management_start | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                            echo 'Management operation "start" missing'
                                            exit 1 
                                        fi

                                        # Start service 
                                        systemctl start {{ SELF.application_name }}
                                    filename: /tmp/start-minio.server.sh
                                tmp_stop:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Assert operation
                                        if [[ "{{ SELF._management_stop | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                            echo 'Management operation "stop" missing'
                                            exit 1 
                                        fi

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/stop.sh

                                        # Stop service 
                                        systemctl stop {{ SELF.application_name }}
                                    filename: /tmp/stop-minio.server.sh
                                tmp_delete:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/delete.sh

                                        # Delete application directory
                                        rm -rf "{{ SELF.application_directory }}"

                                        # Delete systemd service 
                                        rm -f /etc/systemd/system/{{ SELF.application_name }}.service

                                        # Reload system daemon
                                        systemctl daemon-reload
                                    filename: /tmp/delete-minio.server.sh
                            terraform_data:
                                local:
                                    - depends_on:
                                          - local_file.tmp_artifact
                                          - local_file.tmp_service
                                          - local_file.tmp_create
                                          - local_file.tmp_configure
                                          - local_file.tmp_start
                                          - local_file.tmp_stop
                                          - local_file.tmp_delete
                                      provisioner:
                                          local-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-minio.server.sh
                                                    - sudo bash /tmp/configure-minio.server.sh
                                                    - sudo bash /tmp/start-minio.server.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-minio.server.sh
                                                    - sudo bash /tmp/delete-minio.server.sh
                                                when: destroy
    minio.server~service.application#zip.archive::ansible@*->remote.machine:
        derived_from: minio.server
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: install operational dependencies
                                      ansible.builtin.apt:
                                          name: unzip
                                          update_cache: 'yes'
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: extract deployment artifact in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          extra_opts: '{{ ".artifacts::*::[.type=zip.archive]::extra_opts" | eval | map_value }}'
                                      when: not (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")
                                    - name: extract deployment artifact from URL in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          remote_src: 'yes'
                                          extra_opts: '{{ ".artifacts::*::[.type=zip.archive]::extra_opts" | eval | map_value }}'
                                      when: (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")
                                    - name: create vintner directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}/.vintner'
                                          state: directory
                                    - name: create .env file
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.env'
                                          content: |-
                                              MINIO_ROOT_USER="{{ SELF.access_key }}"
                                              MINIO_ROOT_PASSWORD="{{ SELF.secret_key }}"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: create service
                                      ansible.builtin.copy:
                                          dest: /etc/systemd/system/{{ SELF.application_name }}.service
                                          content: |
                                              [Unit]
                                              After=network.target

                                              [Service]
                                              Type=simple
                                              ExecStart=/usr/bin/bash -c ". ./.vintner/start.sh"
                                              WorkingDirectory={{ SELF.application_directory }}
                                              EnvironmentFile={{ SELF.application_directory }}/.env

                                              [Install]
                                              WantedBy=multi-user.target
                                    - name: enable service
                                      ansible.builtin.systemd:
                                          name: '{{ SELF.application_name }}'
                                          state: stopped
                                          enabled: 'yes'
                                          daemon_reload: 'yes'
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "start" missing
                                      when: SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: start service
                                      ansible.builtin.systemd:
                                          name: '{{ SELF.application_name }}'
                                          state: started
                                          enabled: 'yes'
                                          daemon_reload: 'yes'
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "stop" missing
                                      when: SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: stop service
                                      ansible.builtin.systemd:
                                          name: '{{ SELF.application_name }}'
                                          state: stopped
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
                                    - name: delete systemd service
                                      ansible.builtin.file:
                                          path: /etc/systemd/system/{{ SELF.application_name }}.service
                                          state: absent
                                    - name: reload daemon
                                      ansible.builtin.systemd:
                                          daemon_reload: true
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
    minio.server~service.application#zip.archive::terraform@*->remote.machine:
        derived_from: minio.server
        metadata:
            vintner_generated: 'true'
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            os_ssh_host:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            terraform_data:
                                vm:
                                    - connection:
                                          - host: '{{ SELF.os_ssh_host }}'
                                            private_key: ${file("{{ SELF.os_ssh_key_file }}")}
                                            type: ssh
                                            user: '{{ SELF.os_ssh_user }}'
                                      provisioner:
                                          file:
                                              - source: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                                destination: /tmp/artifact-minio.server
                                                count: '{{ (not (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")) | ternary(1, 0) }}'
                                              - content: |
                                                    [Unit]
                                                    After=network.target

                                                    [Service]
                                                    Type=simple
                                                    ExecStart=/usr/bin/bash -c ". ./.vintner/start.sh"
                                                    WorkingDirectory={{ SELF.application_directory }}
                                                    EnvironmentFile={{ SELF.application_directory }}/.env

                                                    [Install]
                                                    WantedBy=multi-user.target
                                                destination: /etc/systemd/system/{{ SELF.application_name }}.service
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Create application directory
                                                    mkdir -p {{ SELF.application_directory }}

                                                    # Create application environment
                                                    cat <<EOF > {{ SELF.application_directory }}/.env
                                                    MINIO_ROOT_USER="{{ SELF.access_key }}"
                                                    MINIO_ROOT_PASSWORD="{{ SELF.secret_key }}"
                                                    EOF>>

                                                    # Download deployment artifact if required
                                                    if [[ "{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}" == http* ]]; then 
                                                        wget -O /tmp/artifact-minio.server {{ ".artifacts::*::[.type=zip.archive]::file" | eval }} 
                                                    fi

                                                    # Extract deployment artifact
                                                    unzip /tmp/artifact-minio.server -d {{ SELF.application_directory }} {{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}

                                                    # Create vintner directory
                                                    mkdir -p {{ SELF.application_directory }}/.vintner

                                                    # Reload systemd daemon
                                                    systemctl daemon-reload

                                                    # Enable service 
                                                    systemctl enable {{ SELF.application_name }}
                                                destination: /tmp/create-minio.server.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/configure.sh
                                                destination: /tmp/configure-minio.server.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Assert operation
                                                    if [[ "{{ SELF._management_start | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                                        echo 'Management operation "start" missing'
                                                        exit 1 
                                                    fi

                                                    # Start service 
                                                    systemctl start {{ SELF.application_name }}
                                                destination: /tmp/start-minio.server.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Assert operation
                                                    if [[ "{{ SELF._management_stop | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                                        echo 'Management operation "stop" missing'
                                                        exit 1 
                                                    fi

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/stop.sh

                                                    # Stop service 
                                                    systemctl stop {{ SELF.application_name }}
                                                destination: /tmp/stop-minio.server.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/delete.sh

                                                    # Delete application directory
                                                    rm -rf "{{ SELF.application_directory }}"

                                                    # Delete systemd service 
                                                    rm -f /etc/systemd/system/{{ SELF.application_name }}.service

                                                    # Reload system daemon
                                                    systemctl daemon-reload
                                                destination: /tmp/delete-minio.server.sh
                                          remote-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-minio.server.sh
                                                    - sudo bash /tmp/configure-minio.server.sh
                                                    - sudo bash /tmp/start-minio.server.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-minio.server.sh
                                                    - sudo bash /tmp/delete-minio.server.sh
                                                when: destroy
    minio.server~service.application#zip.archive::ansible@gcp.appengine:
        derived_from: minio.server
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            gcp_service_account_file:
                type: string
                default:
                    get_input: gcp_service_account_file
            gcp_region:
                type: string
                default:
                    get_input: gcp_region
            gcp_project:
                type: string
                default:
                    get_input: gcp_project
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: activate service account
                                      ansible.builtin.shell: gcloud auth activate-service-account --key-file {{ SELF.gcp_service_account_file }} --project {{ SELF.gcp_project }}
                                      args:
                                          executable: /bin/bash
                                    - name: enable GCP AppEngine
                                      ansible.builtin.shell: gcloud app create --region {{ SELF.gcp_region }} --quiet
                                      args:
                                          executable: /bin/bash
                                      register: app_create_command
                                      failed_when:
                                          - "'Created' not in app_create_command.stderr"
                                          - "'already contains' not in app_create_command.stderr"
                                    - name: create working directory
                                      register: directory
                                      ansible.builtin.tempfile:
                                          state: directory
                                    - name: extract deployment artifact in working directory
                                      ansible.builtin.unarchive:
                                          src: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                          dest: '{{ directory.path }}'
                                    - name: create specification
                                      ansible.builtin.copy:
                                          dest: '{{ directory.path }}/app.yaml'
                                          content: '{{ manifest | to_yaml }}'
                                      vars:
                                          manifest:
                                              runtime: '{{ SELF.application_language }}'
                                              service: '{{ SELF.application_name }}'
                                              instance_class: F1
                                              env_variables:
                                                  MINIO_ROOT_USER: '"{{ SELF.access_key }}"'
                                                  MINIO_ROOT_PASSWORD: '"{{ SELF.secret_key }}"'
                                    - name: create app
                                      ansible.builtin.shell: gcloud app deploy {{ directory.path }} --quiet
                                      args:
                                          executable: /bin/bash
                                    - name: browse app
                                      register: browse_app
                                      ansible.builtin.shell: 'gcloud app browse --service {{ SELF.application_name }} --no-launch-browser --quiet '
                                      args:
                                          executable: /bin/bash
                                    - name: set attributes
                                      set_fact:
                                          application_address: '{{ browse_app.stdout[8:] | trim }}'
                                          application_endpoint: '{{ SELF.application_protocol if SELF.application_protocol.endswith("s") else SELF.application_protocol + "s" }}://{{ browse_app.stdout[8:] | trim }}:443'
                            resultTemplate: |
                                name: SELF
                                attributes:
                                    application_address: '{{ outputs.application_address | trim }}'
                                    application_endpoint: '{{ outputs.application_endpoint | trim }}'
                        outputs:
                            application_address:
                            application_endpoint:
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: activate service account
                                      ansible.builtin.shell: gcloud auth activate-service-account --key-file {{ SELF.gcp_service_account_file }} --project {{ SELF.gcp_project }}
                                      args:
                                          executable: /bin/bash
                                    - name: delete app
                                      ansible.builtin.shell: gcloud app services delete {{ SELF.application_name }} --quiet
                                      args:
                                          executable: /bin/bash
    minio.server~service.application#zip.archive::terraform@gcp.appengine:
        derived_from: minio.server
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            gcp_service_account_file:
                type: string
                default:
                    get_input: gcp_service_account_file
            gcp_region:
                type: string
                default:
                    get_input: gcp_region
            gcp_project:
                type: string
                default:
                    get_input: gcp_project
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                outputs:
                    application_address: application_address
                    application_endpoint: application_endpoint
                inputs:
                    main:
                        terraform:
                            - required_providers:
                                  - google:
                                        source: hashicorp/google
                                        version: 5.39.1
                        provider:
                            google:
                                - credentials: '{{ SELF.gcp_service_account_file }}'
                                  project: '{{ SELF.gcp_project }}'
                                  region: '{{ SELF.gcp_region }}'
                        output:
                            application_address:
                                - value: '{{ SELF.application_name }}-dot-{{ SELF.gcp_project }}.ey.r.appspot.com'
                            application_endpoint:
                                - value: '{{ SELF.application_protocol if SELF.application_protocol.endswith("s") else SELF.application_protocol + "s" }}://{{ SELF.application_name }}-dot-{{ SELF.gcp_project }}.ey.r.appspot.com:443'
                        resource:
                            google_app_engine_standard_app_version:
                                app:
                                    - delete_service_on_destroy: true
                                      deployment:
                                          - zip:
                                                - source_url: https://storage.googleapis.com/${google_storage_bucket.bucket.name}/${google_storage_bucket_object.object.name}
                                      entrypoint:
                                          - shell: '{{ SELF._management_start }}'
                                      env_variables:
                                          MINIO_ROOT_USER: '"{{ SELF.access_key }}"'
                                          MINIO_ROOT_PASSWORD: '"{{ SELF.secret_key }}"'
                                      runtime: '{{ SELF.application_language }}'
                                      service: '{{ SELF.application_name }}'
                                      service_account: ${google_service_account.custom_service_account.email}
                                      version_id: v1
                            google_project_iam_member:
                                gae_api:
                                    - member: serviceAccount:${google_service_account.custom_service_account.email}
                                      project: ${google_service_account.custom_service_account.project}
                                      role: roles/compute.networkUser
                                storage_viewer:
                                    - member: serviceAccount:${google_service_account.custom_service_account.email}
                                      project: ${google_service_account.custom_service_account.project}
                                      role: roles/storage.objectViewer
                            google_service_account:
                                custom_service_account:
                                    - account_id: '{{ SELF.application_name }}-account'
                                      display_name: Custom Service Account
                            google_storage_bucket:
                                bucket:
                                    - location: EU
                                      name: '{{ SELF.gcp_project }}-{{ SELF.application_name }}'
                            google_storage_bucket_object:
                                object:
                                    - bucket: ${google_storage_bucket.bucket.name}
                                      name: object.zip
                                      source: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
    minio.server~software.application#apt.package::ansible@*->local.machine:
        derived_from: minio.server
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: run setup script
                                      ansible.builtin.shell: curl -fsSL {{ ".artifacts::apt_package::script" | eval }} | sudo -E bash -
                                      args:
                                          executable: /bin/bash
                                      when: '".artifacts::apt_package::script" | eval != ""'
                                    - name: add apt key
                                      ansible.builtin.apt_key:
                                          url: '{{ ".artifacts::apt_package::key" | eval }}'
                                          keyring: /usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg
                                          state: present
                                      when: '".artifacts::apt_package::key" | eval != ""'
                                    - name: add apt repository
                                      ansible.builtin.apt_repository:
                                          repo: deb [signed-by=/usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg] {{ ".artifacts::apt_package::source" | eval }}
                                          filename: '{{ ".artifacts::apt_package::repository" | eval }}'
                                          state: present
                                      when: '".artifacts::apt_package::source" | eval != ""'
                                    - name: update apt cache
                                      ansible.builtin.apt:
                                          update_cache: 'yes'
                                    - name: install dependencies
                                      ansible.builtin.apt:
                                          name: '{{ ".artifacts::apt_package::dependencies" | eval | split(",") | map("trim") }}'
                                          state: present
                                      when: '".artifacts::apt_package::dependencies" | eval != ""'
                                    - name: install package
                                      ansible.builtin.apt:
                                          name: '{{ ".artifacts::apt_package::file" | eval }}'
                                          state: present
                                      environment: '{{ ".artifacts::apt_package::env" | eval | split | map("split", "=") | community.general.dict }}'
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
                                    - name: uninstall package
                                      ansible.builtin.apt:
                                          name: '{{ ".artifacts::apt_package::file" | eval }}'
                                          state: absent
    minio.server~software.application#apt.package::terraform@*->local.machine:
        derived_from: minio.server
        metadata:
            vintner_generated: 'true'
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            local_file:
                                tmp_create:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Run setup script 
                                        if [[ "{{ ".artifacts::apt_package::script" | eval }}" != "" ]]; then 
                                            curl -fsSL {{ ".artifacts::apt_package::script" | eval }} | sudo -E bash -
                                        fi

                                        # Add apt key
                                        if [[ "{{ ".artifacts::apt_package::key" | eval }}" != "" ]]; then 
                                            curl -1sLf {{ ".artifacts::apt_package::key" | eval }} | gpg --dearmor --yes -o /usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg
                                        fi

                                        # Add apt repository
                                        if [[ "{{ ".artifacts::apt_package::source" | eval }}" != "" ]]; then 
                                            echo "deb [signed-by=/usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg] {{ ".artifacts::apt_package::source" | eval }}" | tee {{ ".artifacts::apt_package::repository" | eval }}
                                        fi

                                        # Update apt cache
                                        apt-get update -y

                                        # Install dependencies
                                        if [[ "{{ ".artifacts::apt_package::dependencies" | eval }}" != "" ]]; then 
                                            apt-get install {{ ".artifacts::apt_package::dependencies" | eval | split(",") | map("trim") }} -y
                                        fi

                                        # Install package
                                        {{ ".artifacts::apt_package::env" | eval }} apt-get install {{ ".artifacts::apt_package::file" | eval }} -y

                                        # Create application directory
                                        mkdir -p {{ SELF.application_directory }}

                                        # Create application environment
                                        cat <<EOF > {{ SELF.application_directory }}/.env
                                        MINIO_ROOT_USER="{{ SELF.access_key }}"
                                        MINIO_ROOT_PASSWORD="{{ SELF.secret_key }}"
                                        EOF>>

                                        # Create vintner directory
                                        mkdir -p {{ SELF.application_directory }}/.vintner

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/create.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/create.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/create.sh
                                    filename: /tmp/create-minio.server.sh
                                tmp_configure:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/configure.sh
                                    filename: /tmp/configure-minio.server.sh
                                tmp_start:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/start.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/start.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/start.sh
                                    filename: /tmp/start-minio.server.sh
                                tmp_stop:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/stop.sh
                                    filename: /tmp/stop-minio.server.sh
                                tmp_delete:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/delete.sh

                                        # Delete application directory
                                        rm -rf "{{ SELF.application_directory }}"

                                        # Uninstall package
                                        apt-get uninstall {{ ".artifacts::apt_package::file" | eval }} -y
                                    filename: /tmp/delete-minio.server.sh
                            terraform_data:
                                local:
                                    - provisioner:
                                          depends_on:
                                              - local_file.tmp_artifact
                                              - local_file.tmp_create
                                              - local_file.tmp_configure
                                              - local_file.tmp_start
                                              - local_file.tmp_stop
                                              - local_file.tmp_delete
                                          local-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-minio.server.sh
                                                    - sudo bash /tmp/configure-minio.server.sh
                                                    - sudo bash /tmp/start-minio.server.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-minio.server.sh
                                                    - sudo bash /tmp/delete-minio.server.sh
                                                when: destroy
    minio.server~software.application#apt.package::ansible@*->remote.machine:
        derived_from: minio.server
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: run setup script
                                      ansible.builtin.shell: curl -fsSL {{ ".artifacts::apt_package::script" | eval }} | sudo -E bash -
                                      args:
                                          executable: /bin/bash
                                      when: '".artifacts::apt_package::script" | eval != ""'
                                    - name: add apt key
                                      ansible.builtin.apt_key:
                                          url: '{{ ".artifacts::apt_package::key" | eval }}'
                                          keyring: /usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg
                                          state: present
                                      when: '".artifacts::apt_package::key" | eval != ""'
                                    - name: add apt repository
                                      ansible.builtin.apt_repository:
                                          repo: deb [signed-by=/usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg] {{ ".artifacts::apt_package::source" | eval }}
                                          filename: '{{ ".artifacts::apt_package::repository" | eval }}'
                                          state: present
                                      when: '".artifacts::apt_package::source" | eval != ""'
                                    - name: update apt cache
                                      ansible.builtin.apt:
                                          update_cache: 'yes'
                                    - name: install dependencies
                                      ansible.builtin.apt:
                                          name: '{{ ".artifacts::apt_package::dependencies" | eval | split(",") | map("trim") }}'
                                          state: present
                                      when: '".artifacts::apt_package::dependencies" | eval != ""'
                                    - name: install package
                                      ansible.builtin.apt:
                                          name: '{{ ".artifacts::apt_package::file" | eval }}'
                                          state: present
                                      environment: '{{ ".artifacts::apt_package::env" | eval | split | map("split", "=") | community.general.dict }}'
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
                                    - name: uninstall package
                                      ansible.builtin.apt:
                                          name: '{{ ".artifacts::apt_package::file" | eval }}'
                                          state: absent
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
    minio.server~software.application#apt.package::terraform@*->remote.machine:
        derived_from: minio.server
        metadata:
            vintner_generated: 'true'
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            os_ssh_host:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            terraform_data:
                                vm:
                                    - connection:
                                          - host: '{{ SELF.os_ssh_host }}'
                                            private_key: ${file("{{ SELF.os_ssh_key_file }}")}
                                            type: ssh
                                            user: '{{ SELF.os_ssh_user }}'
                                      provisioner:
                                          file:
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Run setup script 
                                                    if [[ "{{ ".artifacts::apt_package::script" | eval }}" != "" ]]; then 
                                                        curl -fsSL {{ ".artifacts::apt_package::script" | eval }} | sudo -E bash -
                                                    fi

                                                    # Add apt key
                                                    if [[ "{{ ".artifacts::apt_package::key" | eval }}" != "" ]]; then 
                                                        curl -1sLf {{ ".artifacts::apt_package::key" | eval }} | gpg --dearmor --yes -o /usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg
                                                    fi

                                                    # Add apt repository
                                                    if [[ "{{ ".artifacts::apt_package::source" | eval }}" != "" ]]; then 
                                                        echo "deb [signed-by=/usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg] {{ ".artifacts::apt_package::source" | eval }}" | tee {{ ".artifacts::apt_package::repository" | eval }}
                                                    fi

                                                    # Update apt cache
                                                    apt-get update -y

                                                    # Install dependencies
                                                    if [[ "{{ ".artifacts::apt_package::dependencies" | eval }}" != "" ]]; then 
                                                        apt-get install {{ ".artifacts::apt_package::dependencies" | eval | split(",") | map("trim") }} -y
                                                    fi

                                                    # Install package
                                                    {{ ".artifacts::apt_package::env" | eval }} apt-get install {{ ".artifacts::apt_package::file" | eval }} -y

                                                    # Create application directory
                                                    mkdir -p {{ SELF.application_directory }}

                                                    # Create application environment
                                                    cat <<EOF > {{ SELF.application_directory }}/.env
                                                    MINIO_ROOT_USER="{{ SELF.access_key }}"
                                                    MINIO_ROOT_PASSWORD="{{ SELF.secret_key }}"
                                                    EOF>>

                                                    # Create vintner directory
                                                    mkdir -p {{ SELF.application_directory }}/.vintner

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/create.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/create.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/create.sh
                                                destination: /tmp/create-minio.server.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/configure.sh
                                                destination: /tmp/configure-minio.server.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/start.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/start.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/start.sh
                                                destination: /tmp/start-minio.server.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/stop.sh
                                                destination: /tmp/stop-minio.server.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/delete.sh

                                                    # Delete application directory
                                                    rm -rf "{{ SELF.application_directory }}"

                                                    # Uninstall package
                                                    apt-get uninstall {{ ".artifacts::apt_package::file" | eval }} -y
                                                destination: /tmp/delete-minio.server.sh
                                          remote-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-minio.server.sh
                                                    - sudo bash /tmp/configure-minio.server.sh
                                                    - sudo bash /tmp/start-minio.server.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-minio.server.sh
                                                    - sudo bash /tmp/delete-minio.server.sh
                                                when: destroy
    minio.server~software.application#tar.archive::ansible@*->local.machine:
        derived_from: minio.server
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: install operational dependencies
                                      ansible.builtin.apt:
                                          name: unzip
                                          update_cache: 'yes'
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: extract deployment artifact in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          extra_opts: '{{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}'
                                      when: not (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")
                                    - name: extract deployment artifact from URL in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          remote_src: 'yes'
                                          extra_opts: '{{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}'
                                      when: (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")
                                    - name: create vintner directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}/.vintner'
                                          state: directory
                                    - name: create .env file
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.env'
                                          content: |-
                                              MINIO_ROOT_USER="{{ SELF.access_key }}"
                                              MINIO_ROOT_PASSWORD="{{ SELF.secret_key }}"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "start" missing
                                      when: SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "stop" missing
                                      when: SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
    minio.server~software.application#tar.archive::terraform@*->local.machine:
        derived_from: minio.server
        metadata:
            vintner_generated: 'true'
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            local_file:
                                tmp_artifact:
                                    source: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                    filename: /tmp/artifact-minio.server
                                    count: '{{ (not (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")) | ternary(1, 0) }}'
                                tmp_create:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Create application directory
                                        mkdir -p {{ SELF.application_directory }}

                                        # Create application environment
                                        cat <<EOF > {{ SELF.application_directory }}/.env
                                        MINIO_ROOT_USER="{{ SELF.access_key }}"
                                        MINIO_ROOT_PASSWORD="{{ SELF.secret_key }}"
                                        EOF>>

                                        # Download deployment artifact if required
                                        if [[ "{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}" == http* ]]; then 
                                            wget -O /tmp/artifact-minio.server {{ ".artifacts::*::[.type=tar.archive]::file" | eval }} 
                                        fi

                                        # Extract deployment artifact
                                        tar -xzf /tmp/artifact-minio.server -C {{ SELF.application_directory }} {{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}

                                        # Create vintner directory
                                        mkdir -p {{ SELF.application_directory }}/.vintner

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/create.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/create.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/create.sh
                                    filename: /tmp/create-minio.server.sh
                                tmp_configure:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/configure.sh
                                    filename: /tmp/configure-minio.server.sh
                                tmp_start:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Assert operation
                                        if [[ "{{ SELF._management_start | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                            echo 'Management operation "start" missing'
                                            exit 1 
                                        fi

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/start.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/start.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/start.sh
                                    filename: /tmp/start-minio.server.sh
                                tmp_stop:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Assert operation
                                        if [[ "{{ SELF._management_stop | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                            echo 'Management operation "stop" missing'
                                            exit 1 
                                        fi

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/stop.sh
                                    filename: /tmp/stop-minio.server.sh
                                tmp_delete:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/delete.sh

                                        # Delete application directory
                                        rm -rf "{{ SELF.application_directory }}"
                                    filename: /tmp/delete-minio.server.sh
                            terraform_data:
                                local:
                                    - depends_on:
                                          - local_file.tmp_artifact
                                          - local_file.tmp_create
                                          - local_file.tmp_configure
                                          - local_file.tmp_start
                                          - local_file.tmp_stop
                                          - local_file.tmp_delete
                                      provisioner:
                                          local-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-minio.server.sh
                                                    - sudo bash /tmp/configure-minio.server.sh
                                                    - sudo bash /tmp/start-minio.server.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-minio.server.sh
                                                    - sudo bash /tmp/delete-minio.server.sh
                                                when: destroy
    minio.server~software.application#tar.archive::ansible@*->remote.machine:
        derived_from: minio.server
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: extract deployment artifact in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          extra_opts: '{{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}'
                                      when: not (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")
                                    - name: extract deployment artifact from URL in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          remote_src: 'yes'
                                          extra_opts: '{{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}'
                                      when: (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")
                                    - name: create vintner directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}/.vintner'
                                          state: directory
                                    - name: create .env file
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.env'
                                          content: |-
                                              MINIO_ROOT_USER="{{ SELF.access_key }}"
                                              MINIO_ROOT_PASSWORD="{{ SELF.secret_key }}"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "start" missing
                                      when: SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "stop" missing
                                      when: SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
    minio.server~software.application#tar.archive::terraform@*->remote.machine:
        derived_from: minio.server
        metadata:
            vintner_generated: 'true'
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            os_ssh_host:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            terraform_data:
                                vm:
                                    - connection:
                                          - host: '{{ SELF.os_ssh_host }}'
                                            private_key: ${file("{{ SELF.os_ssh_key_file }}")}
                                            type: ssh
                                            user: '{{ SELF.os_ssh_user }}'
                                      provisioner:
                                          file:
                                              - source: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                                destination: /tmp/artifact-minio.server
                                                count: '{{ (not (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")) | ternary(1, 0) }}'
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Create application directory
                                                    mkdir -p {{ SELF.application_directory }}

                                                    # Create application environment
                                                    cat <<EOF > {{ SELF.application_directory }}/.env
                                                    MINIO_ROOT_USER="{{ SELF.access_key }}"
                                                    MINIO_ROOT_PASSWORD="{{ SELF.secret_key }}"
                                                    EOF>>

                                                    # Download deployment artifact if required
                                                    if [[ "{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}" == http* ]]; then 
                                                        wget -O /tmp/artifact-minio.server {{ ".artifacts::*::[.type=tar.archive]::file" | eval }} 
                                                    fi

                                                    # Extract deployment artifact
                                                    tar -xzf /tmp/artifact-minio.server -C {{ SELF.application_directory }} {{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}

                                                    # Create vintner directory
                                                    mkdir -p {{ SELF.application_directory }}/.vintner

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/create.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/create.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/create.sh
                                                destination: /tmp/create-minio.server.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/configure.sh
                                                destination: /tmp/configure-minio.server.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Assert operation
                                                    if [[ "{{ SELF._management_start | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                                        echo 'Management operation "start" missing'
                                                        exit 1 
                                                    fi

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/start.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/start.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/start.sh
                                                destination: /tmp/start-minio.server.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Assert operation
                                                    if [[ "{{ SELF._management_stop | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                                        echo 'Management operation "stop" missing'
                                                        exit 1 
                                                    fi

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/stop.sh
                                                destination: /tmp/stop-minio.server.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/delete.sh

                                                    # Delete application directory
                                                    rm -rf "{{ SELF.application_directory }}"
                                                destination: /tmp/delete-minio.server.sh
                                          remote-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-minio.server.sh
                                                    - sudo bash /tmp/configure-minio.server.sh
                                                    - sudo bash /tmp/start-minio.server.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-minio.server.sh
                                                    - sudo bash /tmp/delete-minio.server.sh
                                                when: destroy
    minio.server~software.application#zip.archive::ansible@*->local.machine:
        derived_from: minio.server
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: install operational dependencies
                                      ansible.builtin.apt:
                                          name: unzip
                                          update_cache: 'yes'
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: extract deployment artifact in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          extra_opts: '{{ ".artifacts::*::[.type=zip.archive]::extra_opts" | eval | map_value }}'
                                      when: not (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")
                                    - name: extract deployment artifact from URL in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          remote_src: 'yes'
                                          extra_opts: '{{ ".artifacts::*::[.type=zip.archive]::extra_opts" | eval | map_value }}'
                                      when: (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")
                                    - name: create vintner directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}/.vintner'
                                          state: directory
                                    - name: create .env file
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.env'
                                          content: |-
                                              MINIO_ROOT_USER="{{ SELF.access_key }}"
                                              MINIO_ROOT_PASSWORD="{{ SELF.secret_key }}"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "start" missing
                                      when: SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "stop" missing
                                      when: SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
    minio.server~software.application#zip.archive::terraform@*->local.machine:
        derived_from: minio.server
        metadata:
            vintner_generated: 'true'
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            local_file:
                                tmp_artifact:
                                    source: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                    filename: /tmp/artifact-minio.server
                                    count: '{{ (not (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")) | ternary(1, 0) }}'
                                tmp_create:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Create application directory
                                        mkdir -p {{ SELF.application_directory }}

                                        # Create application environment
                                        cat <<EOF > {{ SELF.application_directory }}/.env
                                        MINIO_ROOT_USER="{{ SELF.access_key }}"
                                        MINIO_ROOT_PASSWORD="{{ SELF.secret_key }}"
                                        EOF>>

                                        # Download deployment artifact if required
                                        if [[ "{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}" == http* ]]; then 
                                            wget -O /tmp/artifact-minio.server {{ ".artifacts::*::[.type=zip.archive]::file" | eval }} 
                                        fi

                                        # Extract deployment artifact
                                        unzip /tmp/artifact-minio.server -d {{ SELF.application_directory }} {{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}

                                        # Create vintner directory
                                        mkdir -p {{ SELF.application_directory }}/.vintner

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/create.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/create.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/create.sh
                                    filename: /tmp/create-minio.server.sh
                                tmp_configure:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/configure.sh
                                    filename: /tmp/configure-minio.server.sh
                                tmp_start:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Assert operation
                                        if [[ "{{ SELF._management_start | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                            echo 'Management operation "start" missing'
                                            exit 1 
                                        fi

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/start.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/start.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/start.sh
                                    filename: /tmp/start-minio.server.sh
                                tmp_stop:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Assert operation
                                        if [[ "{{ SELF._management_stop | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                            echo 'Management operation "stop" missing'
                                            exit 1 
                                        fi

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/stop.sh
                                    filename: /tmp/stop-minio.server.sh
                                tmp_delete:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/delete.sh

                                        # Delete application directory
                                        rm -rf "{{ SELF.application_directory }}"
                                    filename: /tmp/delete-minio.server.sh
                            terraform_data:
                                local:
                                    - depends_on:
                                          - local_file.tmp_artifact
                                          - local_file.tmp_create
                                          - local_file.tmp_configure
                                          - local_file.tmp_start
                                          - local_file.tmp_stop
                                          - local_file.tmp_delete
                                      provisioner:
                                          local-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-minio.server.sh
                                                    - sudo bash /tmp/configure-minio.server.sh
                                                    - sudo bash /tmp/start-minio.server.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-minio.server.sh
                                                    - sudo bash /tmp/delete-minio.server.sh
                                                when: destroy
    minio.server~software.application#zip.archive::ansible@*->remote.machine:
        derived_from: minio.server
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: install operational dependencies
                                      ansible.builtin.apt:
                                          name: unzip
                                          update_cache: 'yes'
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: extract deployment artifact in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          extra_opts: '{{ ".artifacts::*::[.type=zip.archive]::extra_opts" | eval | map_value }}'
                                      when: not (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")
                                    - name: extract deployment artifact from URL in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          remote_src: 'yes'
                                          extra_opts: '{{ ".artifacts::*::[.type=zip.archive]::extra_opts" | eval | map_value }}'
                                      when: (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")
                                    - name: create vintner directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}/.vintner'
                                          state: directory
                                    - name: create .env file
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.env'
                                          content: |-
                                              MINIO_ROOT_USER="{{ SELF.access_key }}"
                                              MINIO_ROOT_PASSWORD="{{ SELF.secret_key }}"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "start" missing
                                      when: SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "stop" missing
                                      when: SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
    minio.server~software.application#zip.archive::terraform@*->remote.machine:
        derived_from: minio.server
        metadata:
            vintner_generated: 'true'
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            os_ssh_host:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            terraform_data:
                                vm:
                                    - connection:
                                          - host: '{{ SELF.os_ssh_host }}'
                                            private_key: ${file("{{ SELF.os_ssh_key_file }}")}
                                            type: ssh
                                            user: '{{ SELF.os_ssh_user }}'
                                      provisioner:
                                          file:
                                              - source: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                                destination: /tmp/artifact-minio.server
                                                count: '{{ (not (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")) | ternary(1, 0) }}'
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Create application directory
                                                    mkdir -p {{ SELF.application_directory }}

                                                    # Create application environment
                                                    cat <<EOF > {{ SELF.application_directory }}/.env
                                                    MINIO_ROOT_USER="{{ SELF.access_key }}"
                                                    MINIO_ROOT_PASSWORD="{{ SELF.secret_key }}"
                                                    EOF>>

                                                    # Download deployment artifact if required
                                                    if [[ "{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}" == http* ]]; then 
                                                        wget -O /tmp/artifact-minio.server {{ ".artifacts::*::[.type=zip.archive]::file" | eval }} 
                                                    fi

                                                    # Extract deployment artifact
                                                    unzip /tmp/artifact-minio.server -d {{ SELF.application_directory }} {{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}

                                                    # Create vintner directory
                                                    mkdir -p {{ SELF.application_directory }}/.vintner

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/create.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/create.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/create.sh
                                                destination: /tmp/create-minio.server.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/configure.sh
                                                destination: /tmp/configure-minio.server.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Assert operation
                                                    if [[ "{{ SELF._management_start | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                                        echo 'Management operation "start" missing'
                                                        exit 1 
                                                    fi

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/start.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/start.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/start.sh
                                                destination: /tmp/start-minio.server.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Assert operation
                                                    if [[ "{{ SELF._management_stop | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                                        echo 'Management operation "stop" missing'
                                                        exit 1 
                                                    fi

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/stop.sh
                                                destination: /tmp/stop-minio.server.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/delete.sh

                                                    # Delete application directory
                                                    rm -rf "{{ SELF.application_directory }}"
                                                destination: /tmp/delete-minio.server.sh
                                          remote-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-minio.server.sh
                                                    - sudo bash /tmp/configure-minio.server.sh
                                                    - sudo bash /tmp/start-minio.server.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-minio.server.sh
                                                    - sudo bash /tmp/delete-minio.server.sh
                                                when: destroy
    redis.server~redis.server#cache.image::ansible@docker.engine->local.machine:
        derived_from: redis.server
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        attributes:
            application_address:
                type: string
                default: 127.0.0.1
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: start container
                                      community.docker.docker_container:
                                          name: '{{ SELF.cache_name }}'
                                          image: redis:{{ ".artifacts::cache_image::file" | eval }}
                                          network_mode: host
                                          command: redis --port {{ SELF.application_port }}
                                          env:
                                              APPLICATION_PROTOCOL: '"{{ SELF.application_protocol }}"'
                                              APPLICATION_NAME: '"{{ SELF.application_name }}"'
                                              APPLICATION_PORT: '"{{ SELF.application_port }}"'
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: stop container
                                      community.docker.docker_container:
                                          name: '{{ SELF.cache_name }}'
                                          state: absent
    redis.server~redis.server#cache.image::compose@docker.engine->local.machine:
        derived_from: redis.server
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        attributes:
            application_address:
                type: string
                default: 127.0.0.1
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: touch compose
                                      register: compose
                                      ansible.builtin.tempfile:
                                          suffix: '{{ SELF.cache_name }}.compose.yaml'
                                    - name: create compose
                                      ansible.builtin.copy:
                                          dest: '{{ compose.path }}'
                                          content: '{{ manifest | to_yaml }}'
                                      vars:
                                          manifest:
                                              name: '{{ SELF.cache_name }}'
                                              services:
                                                  application:
                                                      container_name: '{{ SELF.cache_name }}'
                                                      image: redis:{{ ".artifacts::cache_image::file" | eval }}
                                                      network_mode: host
                                                      command:
                                                          - redis
                                                          - '--port'
                                                          - '{{ SELF.application_port }}'
                                                      environment:
                                                          APPLICATION_PROTOCOL: '"{{ SELF.application_protocol }}"'
                                                          APPLICATION_NAME: '"{{ SELF.application_name }}"'
                                                          APPLICATION_PORT: '"{{ SELF.application_port }}"'
                                    - name: apply compose
                                      ansible.builtin.shell: docker compose -f {{ compose.path }} up -d
                                      args:
                                          executable: /usr/bin/bash
                                      environment: {}
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: touch compose
                                      register: compose
                                      ansible.builtin.tempfile:
                                          suffix: '{{ SELF.cache_name }}.compose.yaml'
                                    - name: create compose
                                      ansible.builtin.copy:
                                          dest: '{{ compose.path }}'
                                          content: '{{ manifest | to_yaml }}'
                                      vars:
                                          manifest:
                                              name: '{{ SELF.cache_name }}'
                                              services:
                                                  application:
                                                      container_name: '{{ SELF.cache_name }}'
                                                      image: redis:{{ ".artifacts::cache_image::file" | eval }}
                                                      network_mode: host
                                                      command:
                                                          - redis
                                                          - '--port'
                                                          - '{{ SELF.application_port }}'
                                                      environment:
                                                          APPLICATION_PROTOCOL: '"{{ SELF.application_protocol }}"'
                                                          APPLICATION_NAME: '"{{ SELF.application_name }}"'
                                                          APPLICATION_PORT: '"{{ SELF.application_port }}"'
                                    - name: unapply compose
                                      ansible.builtin.shell: docker compose -f {{ compose.path }} down
                                      args:
                                          executable: /usr/bin/bash
                                      environment: {}
    redis.server~redis.server#cache.image::terraform@docker.engine->local.machine:
        derived_from: redis.server
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        attributes:
            application_address:
                type: string
                default: 127.0.0.1
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        terraform:
                            - required_providers:
                                  - docker:
                                        source: kreuzwerker/docker
                                        version: 3.0.2
                        provider:
                            docker:
                                - host: unix:///var/run/docker.sock
                        resource:
                            docker_container:
                                application:
                                    - env:
                                          - APPLICATION_PROTOCOL={{ SELF.application_protocol }}
                                          - APPLICATION_NAME={{ SELF.application_name }}
                                          - APPLICATION_PORT={{ SELF.application_port }}
                                      image: ${docker_image.image.image_id}
                                      name: '{{ SELF.cache_name }}'
                                      command:
                                          - redis
                                          - '--port'
                                          - '{{ SELF.application_port }}'
                                      network_mode: host
                            docker_image:
                                image:
                                    - name: redis:{{ ".artifacts::cache_image::file" | eval }}
    redis.server~redis.server#cache.image::ansible@docker.engine->remote.machine:
        derived_from: redis.server
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
        attributes:
            application_address:
                type: string
                default: 127.0.0.1
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: start container
                                      community.docker.docker_container:
                                          name: '{{ SELF.cache_name }}'
                                          image: redis:{{ ".artifacts::cache_image::file" | eval }}
                                          network_mode: host
                                          command: redis --port {{ SELF.application_port }}
                                          env:
                                              APPLICATION_PROTOCOL: '"{{ SELF.application_protocol }}"'
                                              APPLICATION_NAME: '"{{ SELF.application_name }}"'
                                              APPLICATION_PORT: '"{{ SELF.application_port }}"'
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: stop container
                                      community.docker.docker_container:
                                          name: '{{ SELF.cache_name }}'
                                          state: absent
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
    redis.server~redis.server#cache.image::compose@docker.engine->remote.machine:
        derived_from: redis.server
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            os_ssh_host:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
        attributes:
            application_address:
                type: string
                default: 127.0.0.1
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: touch compose
                                      register: compose
                                      ansible.builtin.tempfile:
                                          suffix: '{{ SELF.cache_name }}.compose.yaml'
                                    - name: create compose
                                      ansible.builtin.copy:
                                          dest: '{{ compose.path }}'
                                          content: '{{ manifest | to_yaml }}'
                                      vars:
                                          manifest:
                                              name: '{{ SELF.cache_name }}'
                                              services:
                                                  application:
                                                      container_name: '{{ SELF.cache_name }}'
                                                      image: redis:{{ ".artifacts::cache_image::file" | eval }}
                                                      network_mode: host
                                                      command:
                                                          - redis
                                                          - '--port'
                                                          - '{{ SELF.application_port }}'
                                                      environment:
                                                          APPLICATION_PROTOCOL: '"{{ SELF.application_protocol }}"'
                                                          APPLICATION_NAME: '"{{ SELF.application_name }}"'
                                                          APPLICATION_PORT: '"{{ SELF.application_port }}"'
                                    - name: add ssh credentials
                                      community.general.ssh_config:
                                          user: "{{ lookup('env', 'USER') }}"
                                          host: '{{ SELF.os_ssh_host }}'
                                          remote_user: '{{ SELF.os_ssh_user }}'
                                          identity_file: '{{ SELF.os_ssh_key_file }}'
                                          strict_host_key_checking: 'no'
                                          user_known_hosts_file: /dev/null
                                    - name: apply compose
                                      ansible.builtin.shell: docker compose -f {{ compose.path }} up -d
                                      args:
                                          executable: /usr/bin/bash
                                      environment:
                                          DOCKER_HOST: ssh://{{ SELF.os_ssh_host }}
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: touch compose
                                      register: compose
                                      ansible.builtin.tempfile:
                                          suffix: '{{ SELF.cache_name }}.compose.yaml'
                                    - name: create compose
                                      ansible.builtin.copy:
                                          dest: '{{ compose.path }}'
                                          content: '{{ manifest | to_yaml }}'
                                      vars:
                                          manifest:
                                              name: '{{ SELF.cache_name }}'
                                              services:
                                                  application:
                                                      container_name: '{{ SELF.cache_name }}'
                                                      image: redis:{{ ".artifacts::cache_image::file" | eval }}
                                                      network_mode: host
                                                      command:
                                                          - redis
                                                          - '--port'
                                                          - '{{ SELF.application_port }}'
                                                      environment:
                                                          APPLICATION_PROTOCOL: '"{{ SELF.application_protocol }}"'
                                                          APPLICATION_NAME: '"{{ SELF.application_name }}"'
                                                          APPLICATION_PORT: '"{{ SELF.application_port }}"'
                                    - name: unapply compose
                                      ansible.builtin.shell: docker compose -f {{ compose.path }} down
                                      args:
                                          executable: /usr/bin/bash
                                      environment:
                                          DOCKER_HOST: ssh://{{ SELF.os_ssh_host }}
                                    - name: remove ssh credentials
                                      community.general.ssh_config:
                                          user: "{{ lookup('env', 'USER') }}"
                                          host: '{{ SELF.os_ssh_host }}'
                                          state: absent
    redis.server~redis.server#cache.image::terraform@docker.engine->remote.machine:
        derived_from: redis.server
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            os_ssh_host:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
        attributes:
            application_address:
                type: string
                default: 127.0.0.1
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        terraform:
                            - required_providers:
                                  - docker:
                                        source: kreuzwerker/docker
                                        version: 3.0.2
                        provider:
                            docker:
                                - host: ssh://{{ SELF.os_ssh_user }}@{{ SELF.os_ssh_host }}:22
                                  ssh_opts:
                                      - '-i'
                                      - '{{ SELF.os_ssh_key_file }}'
                                      - '-o'
                                      - IdentitiesOnly=yes
                                      - '-o'
                                      - BatchMode=yes
                                      - '-o'
                                      - UserKnownHostsFile=/dev/null
                                      - '-o'
                                      - StrictHostKeyChecking=no
                        resource:
                            docker_container:
                                application:
                                    - env:
                                          - APPLICATION_PROTOCOL={{ SELF.application_protocol }}
                                          - APPLICATION_NAME={{ SELF.application_name }}
                                          - APPLICATION_PORT={{ SELF.application_port }}
                                      image: ${docker_image.image.image_id}
                                      name: '{{ SELF.cache_name }}'
                                      command:
                                          - redis
                                          - '--port'
                                          - '{{ SELF.application_port }}'
                                      network_mode: host
                            docker_image:
                                image:
                                    - name: redis:{{ ".artifacts::cache_image::file" | eval }}
    redis.server~redis.server#cache.image::ansible@gcp.memorystore:
        derived_from: redis.server
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            gcp_service_account_file:
                type: string
                default:
                    get_input: gcp_service_account_file
            gcp_region:
                type: string
                default:
                    get_input: gcp_region
            gcp_project:
                type: string
                default:
                    get_input: gcp_project
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                            environment:
                                GCP_SERVICE_ACCOUNT_FILE:
                                    eval: .::gcp_service_account_file
                                GCP_AUTH_KIND: serviceaccount
                        inputs:
                            playbook:
                                q:
                                    - name: create redis
                                      google.cloud.gcp_redis_instance:
                                          name: '{{ SELF.cache_name }}'
                                          memory_size_gb: 1
                                          region: '{{ SELF.gcp_region }}'
                                          project: '{{ SELF.gcp_project }}'
                                      register: redis_info
                                    - name: set attributes
                                      set_fact:
                                          application_endpoint: '{{ redis_info.host }}:{{ redis_info.port }}'
                                          application_address: '{{ redis_info.host }}'
                                          application_port: '{{ redis_info.port }}'
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                            environment:
                                GCP_SERVICE_ACCOUNT_FILE:
                                    eval: .::gcp_service_account_file
                                GCP_AUTH_KIND: serviceaccount
                        inputs:
                            playbook:
                                q:
                                    - name: delete redis
                                      google.cloud.gcp_redis_instance:
                                          name: '{{ SELF.cache_name }}'
                                          project: '{{ SELF.gcp_project }}'
                                          state: absent
    redis.server~redis.server#cache.image::terraform@gcp.memorystore:
        derived_from: redis.server
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            gcp_service_account_file:
                type: string
                default:
                    get_input: gcp_service_account_file
            gcp_region:
                type: string
                default:
                    get_input: gcp_region
            gcp_project:
                type: string
                default:
                    get_input: gcp_project
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                            environment:
                                GOOGLE_APPLICATION_CREDENTIALS:
                                    eval: .::gcp_service_account_file
                    delete:
                        implementation:
                            primary: Terraform
                            environment:
                                GOOGLE_APPLICATION_CREDENTIALS:
                                    eval: .::gcp_service_account_file
            defaults:
                inputs:
                    main:
                        terraform:
                            - required_providers:
                                  - google:
                                        source: hashicorp/google
                                        version: 5.39.1
                        provider:
                            google:
                                - credentials: '{{ SELF.gcp_service_account_file }}'
                                  project: '{{ SELF.gcp_project }}'
                                  region: '{{ SELF.gcp_region }}'
                        resource:
                            google_redis_instance:
                                cache:
                                    - name: '{{ SELF.cache_name }}'
                                      memory_size_gb: 1
                                      lifecycle:
                                          prevent_destroy: true
                        output:
                            application_endpoint:
                                - value: ${google_redis_instance.cache.host}:${google_redis_instance.cache.port}
                            application_address:
                                - value: ${google_redis_instance.cache.host}
                            application_port:
                                - value: ${google_redis_instance.cache.port}
                outputs:
                    application_endpoint: application_endpoint
                    application_address: application_address
                    application_port: application_port
    redis.server~redis.server#cache.image::ansible@kubernetes.cluster:
        derived_from: redis.server
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            k8s_host:
                type: string
                default:
                    get_input: k8s_host
            k8s_ca_cert_file:
                type: string
                default:
                    get_input: k8s_ca_cert_file
            k8s_client_cert_file:
                type: string
                default:
                    get_input: k8s_client_cert_file
            k8s_client_key_file:
                type: string
                default:
                    get_input: k8s_client_key_file
        attributes:
            application_address:
                type: string
                default:
                    eval: .::cache_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                            environment:
                                K8S_AUTH_HOST:
                                    eval: .::k8s_host
                                K8S_AUTH_SSL_CA_CERT:
                                    eval: .::k8s_ca_cert_file
                                K8S_AUTH_CERT_FILE:
                                    eval: .::k8s_client_cert_file
                                K8S_AUTH_KEY_FILE:
                                    eval: .::k8s_client_key_file
                        inputs:
                            playbook:
                                q:
                                    - name: create deployment
                                      kubernetes.core.k8s:
                                          wait: true
                                          definition:
                                              apiVersion: apps/v1
                                              kind: Deployment
                                              metadata:
                                                  name: '{{ SELF.application_name }}'
                                                  namespace: default
                                              spec:
                                                  selector:
                                                      matchLabels:
                                                          app: '{{ SELF.application_name }}'
                                                  template:
                                                      metadata:
                                                          labels:
                                                              app: '{{ SELF.application_name }}'
                                                      spec:
                                                          containers:
                                                              - image: redis:{{ ".artifacts::cache_image::file" | eval }}
                                                                name: '{{ SELF.application_name }}'
                                                                env:
                                                                    - name: APPLICATION_PROTOCOL
                                                                      value: '"{{ SELF.application_protocol }}"'
                                                                    - name: APPLICATION_NAME
                                                                      value: '"{{ SELF.application_name }}"'
                                                                    - name: APPLICATION_PORT
                                                                      value: '"{{ SELF.application_port }}"'
                                                                command: redis --port {{ SELF.application_port }}
                                                                ports:
                                                                    - containerPort: '{{ SELF.application_port }}'
                                    - name: create service
                                      kubernetes.core.k8s:
                                          definition:
                                              apiVersion: v1
                                              kind: Service
                                              metadata:
                                                  name: '{{ SELF.application_name }}'
                                                  namespace: default
                                              spec:
                                                  ports:
                                                      - name: '{{ SELF.application_protocol }}'
                                                        port: '{{ SELF.application_port }}'
                                                        targetPort: '{{ SELF.application_port }}'
                                                  selector:
                                                      app: '{{ SELF.application_name }}'
                                                  type: ClusterIP
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                            environment:
                                K8S_AUTH_HOST:
                                    eval: .::k8s_host
                                K8S_AUTH_SSL_CA_CERT:
                                    eval: .::k8s_ca_cert_file
                                K8S_AUTH_CERT_FILE:
                                    eval: .::k8s_client_cert_file
                                K8S_AUTH_KEY_FILE:
                                    eval: .::k8s_client_key_file
                        inputs:
                            playbook:
                                q:
                                    - name: delete service
                                      kubernetes.core.k8s:
                                          state: absent
                                          api_version: v1
                                          kind: Service
                                          namespace: default
                                          name: '{{ SELF.application_name }}'
                                    - name: delete deployment
                                      kubernetes.core.k8s:
                                          state: absent
                                          api_version: app/v1
                                          kind: Deployment
                                          namespace: default
                                          name: '{{ SELF.application_name }}'
    redis.server~redis.server#cache.image::kubernetes@kubernetes.cluster:
        derived_from: redis.server
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        attributes:
            application_address:
                type: string
                default:
                    eval: .::cache_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: touch manifest
                                      register: manifest
                                      ansible.builtin.tempfile:
                                          suffix: '{{ SELF.application_name }}.application.manifest.yaml'
                                    - name: create manifest
                                      ansible.builtin.copy:
                                          dest: '{{ manifest.path }}'
                                          content: |
                                              {{ deployment | to_yaml }}
                                              ---
                                              {{ service | to_yaml }}
                                      vars:
                                          deployment:
                                              apiVersion: apps/v1
                                              kind: Deployment
                                              metadata:
                                                  name: '{{ SELF.cache_name }}'
                                                  namespace: default
                                              spec:
                                                  selector:
                                                      matchLabels:
                                                          app: '{{ SELF.cache_name }}'
                                                  template:
                                                      metadata:
                                                          labels:
                                                              app: '{{ SELF.cache_name }}'
                                                      spec:
                                                          containers:
                                                              - image: redis:{{ ".artifacts::cache_image::file" | eval }}
                                                                name: '{{ SELF.cache_name }}'
                                                                env:
                                                                    - name: APPLICATION_PROTOCOL
                                                                      value: '"{{ SELF.application_protocol }}"'
                                                                    - name: APPLICATION_NAME
                                                                      value: '"{{ SELF.application_name }}"'
                                                                    - name: APPLICATION_PORT
                                                                      value: '"{{ SELF.application_port }}"'
                                                                command: redis --port {{ SELF.application_port }}
                                                                ports:
                                                                    - containerPort: '{{ SELF.cache_port }}'
                                          service:
                                              apiVersion: v1
                                              kind: Service
                                              metadata:
                                                  name: '{{ SELF.cache_name }}'
                                                  namespace: default
                                              spec:
                                                  ports:
                                                      - name: redis
                                                        port: '{{ SELF.cache_port }}'
                                                        targetPort: '{{ SELF.cache_port }}'
                                                  selector:
                                                      app: '{{ SELF.cache_name }}'
                                                  type: ClusterIP
                                    - name: apply manifest
                                      ansible.builtin.shell: kubectl --server {{ SELF.k8s_host }} --certificate-authority {{ SELF.k8s_ca_cert_file }} --client-certificate {{ SELF.k8s_client_cert_file }} --client-key {{ SELF.k8s_client_key_file }} apply -f {{ manifest.path }}
                                      args:
                                          executable: /usr/bin/bash
                                    - name: wait for deployment
                                      ansible.builtin.shell: kubectl --server {{ SELF.k8s_host }} --certificate-authority {{ SELF.k8s_ca_cert_file }} --client-certificate {{ SELF.k8s_client_cert_file }} --client-key {{ SELF.k8s_client_key_file }} rollout status deployment/{{ SELF.application_name }} --timeout 60s
                                      args:
                                          executable: /usr/bin/bash
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: touch manifest
                                      register: manifest
                                      ansible.builtin.tempfile:
                                          suffix: '{{ SELF.application_name }}.application.manifest.yaml'
                                    - name: create manifest
                                      ansible.builtin.copy:
                                          dest: '{{ manifest.path }}'
                                          content: |
                                              {{ deployment | to_yaml }}
                                              ---
                                              {{ service | to_yaml }}
                                      vars:
                                          deployment:
                                              apiVersion: apps/v1
                                              kind: Deployment
                                              metadata:
                                                  name: '{{ SELF.cache_name }}'
                                                  namespace: default
                                              spec:
                                                  selector:
                                                      matchLabels:
                                                          app: '{{ SELF.cache_name }}'
                                                  template:
                                                      metadata:
                                                          labels:
                                                              app: '{{ SELF.cache_name }}'
                                                      spec:
                                                          containers:
                                                              - image: redis:{{ ".artifacts::cache_image::file" | eval }}
                                                                name: '{{ SELF.cache_name }}'
                                                                env:
                                                                    - name: APPLICATION_PROTOCOL
                                                                      value: '"{{ SELF.application_protocol }}"'
                                                                    - name: APPLICATION_NAME
                                                                      value: '"{{ SELF.application_name }}"'
                                                                    - name: APPLICATION_PORT
                                                                      value: '"{{ SELF.application_port }}"'
                                                                command: redis --port {{ SELF.application_port }}
                                                                ports:
                                                                    - containerPort: '{{ SELF.cache_port }}'
                                          service:
                                              apiVersion: v1
                                              kind: Service
                                              metadata:
                                                  name: '{{ SELF.cache_name }}'
                                                  namespace: default
                                              spec:
                                                  ports:
                                                      - name: redis
                                                        port: '{{ SELF.cache_port }}'
                                                        targetPort: '{{ SELF.cache_port }}'
                                                  selector:
                                                      app: '{{ SELF.cache_name }}'
                                                  type: ClusterIP
                                    - name: unapply manifest
                                      ansible.builtin.shell: kubectl --server {{ SELF.k8s_host }} --certificate-authority {{ SELF.k8s_ca_cert_file }} --client-certificate {{ SELF.k8s_client_cert_file }} --client-key {{ SELF.k8s_client_key_file }} delete -f {{ manifest.path }}
                                      args:
                                          executable: /usr/bin/bash
    redis.server~redis.server#cache.image::terraform@kubernetes.cluster:
        derived_from: redis.server
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            k8s_host:
                type: string
                default:
                    get_input: k8s_host
            k8s_ca_cert_file:
                type: string
                default:
                    get_input: k8s_ca_cert_file
            k8s_client_cert_file:
                type: string
                default:
                    get_input: k8s_client_cert_file
            k8s_client_key_file:
                type: string
                default:
                    get_input: k8s_client_key_file
        attributes:
            application_address:
                type: string
                default:
                    eval: .::application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        terraform:
                            - required_providers:
                                  - kubernetes:
                                        source: hashicorp/kubernetes
                                        version: 2.31.0
                              required_version: '>= 0.14.0'
                        provider:
                            kubernetes:
                                - client_certificate: ${file("{{ SELF.k8s_client_cert_file }}")}
                                  client_key: ${file("{{ SELF.k8s_client_key_file }}")}
                                  cluster_ca_certificate: ${file("{{ SELF.k8s_ca_cert_file }}")}
                                  host: '{{ SELF.k8s_host }}'
                        resource:
                            kubernetes_deployment_v1:
                                application:
                                    - metadata:
                                          - name: '{{ SELF.application_name }}'
                                      spec:
                                          - selector:
                                                - match_labels:
                                                      app: '{{ SELF.application_name }}'
                                            template:
                                                - metadata:
                                                      - labels:
                                                            app: '{{ SELF.application_name }}'
                                                  spec:
                                                      - container:
                                                            - env:
                                                                  - name: APPLICATION_PROTOCOL
                                                                    value: '"{{ SELF.application_protocol }}"'
                                                                  - name: APPLICATION_NAME
                                                                    value: '"{{ SELF.application_name }}"'
                                                                  - name: APPLICATION_PORT
                                                                    value: '"{{ SELF.application_port }}"'
                                                              image: redis:{{ ".artifacts::cache_image::file" | eval }}
                                                              name: '{{ SELF.application_name }}'
                                                              command: redis --port {{ SELF.application_port }}
                                                              port:
                                                                  - container_port: '{{ SELF.application_port }}'
                            kubernetes_service_v1:
                                application:
                                    - metadata:
                                          - name: '{{ SELF.application_name }}'
                                      spec:
                                          - port:
                                                - name: '{{ SELF.application_protocol }}'
                                                  port: '{{ SELF.application_port }}'
                                                  target_port: '{{ SELF.application_port }}'
                                            selector:
                                                app: '{{ SELF.application_name }}'
                                            type: ClusterIP
    redis.server~software.application#apt.package::ansible@*->local.machine:
        derived_from: redis.server
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: run setup script
                                      ansible.builtin.shell: curl -fsSL {{ ".artifacts::apt_package::script" | eval }} | sudo -E bash -
                                      args:
                                          executable: /bin/bash
                                      when: '".artifacts::apt_package::script" | eval != ""'
                                    - name: add apt key
                                      ansible.builtin.apt_key:
                                          url: '{{ ".artifacts::apt_package::key" | eval }}'
                                          keyring: /usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg
                                          state: present
                                      when: '".artifacts::apt_package::key" | eval != ""'
                                    - name: add apt repository
                                      ansible.builtin.apt_repository:
                                          repo: deb [signed-by=/usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg] {{ ".artifacts::apt_package::source" | eval }}
                                          filename: '{{ ".artifacts::apt_package::repository" | eval }}'
                                          state: present
                                      when: '".artifacts::apt_package::source" | eval != ""'
                                    - name: update apt cache
                                      ansible.builtin.apt:
                                          update_cache: 'yes'
                                    - name: install dependencies
                                      ansible.builtin.apt:
                                          name: '{{ ".artifacts::apt_package::dependencies" | eval | split(",") | map("trim") }}'
                                          state: present
                                      when: '".artifacts::apt_package::dependencies" | eval != ""'
                                    - name: install package
                                      ansible.builtin.apt:
                                          name: '{{ ".artifacts::apt_package::file" | eval }}'
                                          state: present
                                      environment: '{{ ".artifacts::apt_package::env" | eval | split | map("split", "=") | community.general.dict }}'
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
                                    - name: uninstall package
                                      ansible.builtin.apt:
                                          name: '{{ ".artifacts::apt_package::file" | eval }}'
                                          state: absent
    redis.server~software.application#apt.package::terraform@*->local.machine:
        derived_from: redis.server
        metadata:
            vintner_generated: 'true'
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            local_file:
                                tmp_create:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Run setup script 
                                        if [[ "{{ ".artifacts::apt_package::script" | eval }}" != "" ]]; then 
                                            curl -fsSL {{ ".artifacts::apt_package::script" | eval }} | sudo -E bash -
                                        fi

                                        # Add apt key
                                        if [[ "{{ ".artifacts::apt_package::key" | eval }}" != "" ]]; then 
                                            curl -1sLf {{ ".artifacts::apt_package::key" | eval }} | gpg --dearmor --yes -o /usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg
                                        fi

                                        # Add apt repository
                                        if [[ "{{ ".artifacts::apt_package::source" | eval }}" != "" ]]; then 
                                            echo "deb [signed-by=/usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg] {{ ".artifacts::apt_package::source" | eval }}" | tee {{ ".artifacts::apt_package::repository" | eval }}
                                        fi

                                        # Update apt cache
                                        apt-get update -y

                                        # Install dependencies
                                        if [[ "{{ ".artifacts::apt_package::dependencies" | eval }}" != "" ]]; then 
                                            apt-get install {{ ".artifacts::apt_package::dependencies" | eval | split(",") | map("trim") }} -y
                                        fi

                                        # Install package
                                        {{ ".artifacts::apt_package::env" | eval }} apt-get install {{ ".artifacts::apt_package::file" | eval }} -y

                                        # Create application directory
                                        mkdir -p {{ SELF.application_directory }}

                                        # Create application environment
                                        cat <<EOF > {{ SELF.application_directory }}/.env
                                        APPLICATION_PROTOCOL="{{ SELF.application_protocol }}"
                                        APPLICATION_NAME="{{ SELF.application_name }}"
                                        APPLICATION_PORT="{{ SELF.application_port }}"
                                        EOF>>

                                        # Create vintner directory
                                        mkdir -p {{ SELF.application_directory }}/.vintner

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/create.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/create.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/create.sh
                                    filename: /tmp/create-redis.server.sh
                                tmp_configure:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/configure.sh
                                    filename: /tmp/configure-redis.server.sh
                                tmp_start:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/start.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/start.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/start.sh
                                    filename: /tmp/start-redis.server.sh
                                tmp_stop:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/stop.sh
                                    filename: /tmp/stop-redis.server.sh
                                tmp_delete:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/delete.sh

                                        # Delete application directory
                                        rm -rf "{{ SELF.application_directory }}"

                                        # Uninstall package
                                        apt-get uninstall {{ ".artifacts::apt_package::file" | eval }} -y
                                    filename: /tmp/delete-redis.server.sh
                            terraform_data:
                                local:
                                    - provisioner:
                                          depends_on:
                                              - local_file.tmp_artifact
                                              - local_file.tmp_create
                                              - local_file.tmp_configure
                                              - local_file.tmp_start
                                              - local_file.tmp_stop
                                              - local_file.tmp_delete
                                          local-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-redis.server.sh
                                                    - sudo bash /tmp/configure-redis.server.sh
                                                    - sudo bash /tmp/start-redis.server.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-redis.server.sh
                                                    - sudo bash /tmp/delete-redis.server.sh
                                                when: destroy
    redis.server~software.application#apt.package::ansible@*->remote.machine:
        derived_from: redis.server
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: run setup script
                                      ansible.builtin.shell: curl -fsSL {{ ".artifacts::apt_package::script" | eval }} | sudo -E bash -
                                      args:
                                          executable: /bin/bash
                                      when: '".artifacts::apt_package::script" | eval != ""'
                                    - name: add apt key
                                      ansible.builtin.apt_key:
                                          url: '{{ ".artifacts::apt_package::key" | eval }}'
                                          keyring: /usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg
                                          state: present
                                      when: '".artifacts::apt_package::key" | eval != ""'
                                    - name: add apt repository
                                      ansible.builtin.apt_repository:
                                          repo: deb [signed-by=/usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg] {{ ".artifacts::apt_package::source" | eval }}
                                          filename: '{{ ".artifacts::apt_package::repository" | eval }}'
                                          state: present
                                      when: '".artifacts::apt_package::source" | eval != ""'
                                    - name: update apt cache
                                      ansible.builtin.apt:
                                          update_cache: 'yes'
                                    - name: install dependencies
                                      ansible.builtin.apt:
                                          name: '{{ ".artifacts::apt_package::dependencies" | eval | split(",") | map("trim") }}'
                                          state: present
                                      when: '".artifacts::apt_package::dependencies" | eval != ""'
                                    - name: install package
                                      ansible.builtin.apt:
                                          name: '{{ ".artifacts::apt_package::file" | eval }}'
                                          state: present
                                      environment: '{{ ".artifacts::apt_package::env" | eval | split | map("split", "=") | community.general.dict }}'
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
                                    - name: uninstall package
                                      ansible.builtin.apt:
                                          name: '{{ ".artifacts::apt_package::file" | eval }}'
                                          state: absent
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
    redis.server~software.application#apt.package::terraform@*->remote.machine:
        derived_from: redis.server
        metadata:
            vintner_generated: 'true'
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            os_ssh_host:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            terraform_data:
                                vm:
                                    - connection:
                                          - host: '{{ SELF.os_ssh_host }}'
                                            private_key: ${file("{{ SELF.os_ssh_key_file }}")}
                                            type: ssh
                                            user: '{{ SELF.os_ssh_user }}'
                                      provisioner:
                                          file:
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Run setup script 
                                                    if [[ "{{ ".artifacts::apt_package::script" | eval }}" != "" ]]; then 
                                                        curl -fsSL {{ ".artifacts::apt_package::script" | eval }} | sudo -E bash -
                                                    fi

                                                    # Add apt key
                                                    if [[ "{{ ".artifacts::apt_package::key" | eval }}" != "" ]]; then 
                                                        curl -1sLf {{ ".artifacts::apt_package::key" | eval }} | gpg --dearmor --yes -o /usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg
                                                    fi

                                                    # Add apt repository
                                                    if [[ "{{ ".artifacts::apt_package::source" | eval }}" != "" ]]; then 
                                                        echo "deb [signed-by=/usr/share/keyrings/{{ ".artifacts::apt_package::repository" | eval }}.gpg] {{ ".artifacts::apt_package::source" | eval }}" | tee {{ ".artifacts::apt_package::repository" | eval }}
                                                    fi

                                                    # Update apt cache
                                                    apt-get update -y

                                                    # Install dependencies
                                                    if [[ "{{ ".artifacts::apt_package::dependencies" | eval }}" != "" ]]; then 
                                                        apt-get install {{ ".artifacts::apt_package::dependencies" | eval | split(",") | map("trim") }} -y
                                                    fi

                                                    # Install package
                                                    {{ ".artifacts::apt_package::env" | eval }} apt-get install {{ ".artifacts::apt_package::file" | eval }} -y

                                                    # Create application directory
                                                    mkdir -p {{ SELF.application_directory }}

                                                    # Create application environment
                                                    cat <<EOF > {{ SELF.application_directory }}/.env
                                                    APPLICATION_PROTOCOL="{{ SELF.application_protocol }}"
                                                    APPLICATION_NAME="{{ SELF.application_name }}"
                                                    APPLICATION_PORT="{{ SELF.application_port }}"
                                                    EOF>>

                                                    # Create vintner directory
                                                    mkdir -p {{ SELF.application_directory }}/.vintner

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/create.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/create.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/create.sh
                                                destination: /tmp/create-redis.server.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/configure.sh
                                                destination: /tmp/configure-redis.server.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/start.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/start.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/start.sh
                                                destination: /tmp/start-redis.server.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/stop.sh
                                                destination: /tmp/stop-redis.server.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/delete.sh

                                                    # Delete application directory
                                                    rm -rf "{{ SELF.application_directory }}"

                                                    # Uninstall package
                                                    apt-get uninstall {{ ".artifacts::apt_package::file" | eval }} -y
                                                destination: /tmp/delete-redis.server.sh
                                          remote-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-redis.server.sh
                                                    - sudo bash /tmp/configure-redis.server.sh
                                                    - sudo bash /tmp/start-redis.server.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-redis.server.sh
                                                    - sudo bash /tmp/delete-redis.server.sh
                                                when: destroy
    redis.server~software.application#tar.archive::ansible@*->local.machine:
        derived_from: redis.server
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: install operational dependencies
                                      ansible.builtin.apt:
                                          name: unzip
                                          update_cache: 'yes'
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: extract deployment artifact in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          extra_opts: '{{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}'
                                      when: not (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")
                                    - name: extract deployment artifact from URL in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          remote_src: 'yes'
                                          extra_opts: '{{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}'
                                      when: (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")
                                    - name: create vintner directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}/.vintner'
                                          state: directory
                                    - name: create .env file
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.env'
                                          content: |-
                                              APPLICATION_PROTOCOL="{{ SELF.application_protocol }}"
                                              APPLICATION_NAME="{{ SELF.application_name }}"
                                              APPLICATION_PORT="{{ SELF.application_port }}"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "start" missing
                                      when: SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "stop" missing
                                      when: SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
    redis.server~software.application#tar.archive::terraform@*->local.machine:
        derived_from: redis.server
        metadata:
            vintner_generated: 'true'
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            local_file:
                                tmp_artifact:
                                    source: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                    filename: /tmp/artifact-redis.server
                                    count: '{{ (not (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")) | ternary(1, 0) }}'
                                tmp_create:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Create application directory
                                        mkdir -p {{ SELF.application_directory }}

                                        # Create application environment
                                        cat <<EOF > {{ SELF.application_directory }}/.env
                                        APPLICATION_PROTOCOL="{{ SELF.application_protocol }}"
                                        APPLICATION_NAME="{{ SELF.application_name }}"
                                        APPLICATION_PORT="{{ SELF.application_port }}"
                                        EOF>>

                                        # Download deployment artifact if required
                                        if [[ "{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}" == http* ]]; then 
                                            wget -O /tmp/artifact-redis.server {{ ".artifacts::*::[.type=tar.archive]::file" | eval }} 
                                        fi

                                        # Extract deployment artifact
                                        tar -xzf /tmp/artifact-redis.server -C {{ SELF.application_directory }} {{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}

                                        # Create vintner directory
                                        mkdir -p {{ SELF.application_directory }}/.vintner

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/create.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/create.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/create.sh
                                    filename: /tmp/create-redis.server.sh
                                tmp_configure:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/configure.sh
                                    filename: /tmp/configure-redis.server.sh
                                tmp_start:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Assert operation
                                        if [[ "{{ SELF._management_start | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                            echo 'Management operation "start" missing'
                                            exit 1 
                                        fi

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/start.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/start.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/start.sh
                                    filename: /tmp/start-redis.server.sh
                                tmp_stop:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Assert operation
                                        if [[ "{{ SELF._management_stop | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                            echo 'Management operation "stop" missing'
                                            exit 1 
                                        fi

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/stop.sh
                                    filename: /tmp/stop-redis.server.sh
                                tmp_delete:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/delete.sh

                                        # Delete application directory
                                        rm -rf "{{ SELF.application_directory }}"
                                    filename: /tmp/delete-redis.server.sh
                            terraform_data:
                                local:
                                    - depends_on:
                                          - local_file.tmp_artifact
                                          - local_file.tmp_create
                                          - local_file.tmp_configure
                                          - local_file.tmp_start
                                          - local_file.tmp_stop
                                          - local_file.tmp_delete
                                      provisioner:
                                          local-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-redis.server.sh
                                                    - sudo bash /tmp/configure-redis.server.sh
                                                    - sudo bash /tmp/start-redis.server.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-redis.server.sh
                                                    - sudo bash /tmp/delete-redis.server.sh
                                                when: destroy
    redis.server~software.application#tar.archive::ansible@*->remote.machine:
        derived_from: redis.server
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: extract deployment artifact in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          extra_opts: '{{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}'
                                      when: not (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")
                                    - name: extract deployment artifact from URL in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          remote_src: 'yes'
                                          extra_opts: '{{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}'
                                      when: (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")
                                    - name: create vintner directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}/.vintner'
                                          state: directory
                                    - name: create .env file
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.env'
                                          content: |-
                                              APPLICATION_PROTOCOL="{{ SELF.application_protocol }}"
                                              APPLICATION_NAME="{{ SELF.application_name }}"
                                              APPLICATION_PORT="{{ SELF.application_port }}"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "start" missing
                                      when: SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "stop" missing
                                      when: SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
    redis.server~software.application#tar.archive::terraform@*->remote.machine:
        derived_from: redis.server
        metadata:
            vintner_generated: 'true'
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            os_ssh_host:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            terraform_data:
                                vm:
                                    - connection:
                                          - host: '{{ SELF.os_ssh_host }}'
                                            private_key: ${file("{{ SELF.os_ssh_key_file }}")}
                                            type: ssh
                                            user: '{{ SELF.os_ssh_user }}'
                                      provisioner:
                                          file:
                                              - source: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}'
                                                destination: /tmp/artifact-redis.server
                                                count: '{{ (not (".artifacts::*::[.type=tar.archive]::file" | eval).startswith("http")) | ternary(1, 0) }}'
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Create application directory
                                                    mkdir -p {{ SELF.application_directory }}

                                                    # Create application environment
                                                    cat <<EOF > {{ SELF.application_directory }}/.env
                                                    APPLICATION_PROTOCOL="{{ SELF.application_protocol }}"
                                                    APPLICATION_NAME="{{ SELF.application_name }}"
                                                    APPLICATION_PORT="{{ SELF.application_port }}"
                                                    EOF>>

                                                    # Download deployment artifact if required
                                                    if [[ "{{ ".artifacts::*::[.type=tar.archive]::file" | eval }}" == http* ]]; then 
                                                        wget -O /tmp/artifact-redis.server {{ ".artifacts::*::[.type=tar.archive]::file" | eval }} 
                                                    fi

                                                    # Extract deployment artifact
                                                    tar -xzf /tmp/artifact-redis.server -C {{ SELF.application_directory }} {{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}

                                                    # Create vintner directory
                                                    mkdir -p {{ SELF.application_directory }}/.vintner

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/create.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/create.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/create.sh
                                                destination: /tmp/create-redis.server.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/configure.sh
                                                destination: /tmp/configure-redis.server.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Assert operation
                                                    if [[ "{{ SELF._management_start | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                                        echo 'Management operation "start" missing'
                                                        exit 1 
                                                    fi

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/start.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/start.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/start.sh
                                                destination: /tmp/start-redis.server.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Assert operation
                                                    if [[ "{{ SELF._management_stop | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                                        echo 'Management operation "stop" missing'
                                                        exit 1 
                                                    fi

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/stop.sh
                                                destination: /tmp/stop-redis.server.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/delete.sh

                                                    # Delete application directory
                                                    rm -rf "{{ SELF.application_directory }}"
                                                destination: /tmp/delete-redis.server.sh
                                          remote-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-redis.server.sh
                                                    - sudo bash /tmp/configure-redis.server.sh
                                                    - sudo bash /tmp/start-redis.server.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-redis.server.sh
                                                    - sudo bash /tmp/delete-redis.server.sh
                                                when: destroy
    redis.server~software.application#zip.archive::ansible@*->local.machine:
        derived_from: redis.server
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: install operational dependencies
                                      ansible.builtin.apt:
                                          name: unzip
                                          update_cache: 'yes'
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: extract deployment artifact in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          extra_opts: '{{ ".artifacts::*::[.type=zip.archive]::extra_opts" | eval | map_value }}'
                                      when: not (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")
                                    - name: extract deployment artifact from URL in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          remote_src: 'yes'
                                          extra_opts: '{{ ".artifacts::*::[.type=zip.archive]::extra_opts" | eval | map_value }}'
                                      when: (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")
                                    - name: create vintner directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}/.vintner'
                                          state: directory
                                    - name: create .env file
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.env'
                                          content: |-
                                              APPLICATION_PROTOCOL="{{ SELF.application_protocol }}"
                                              APPLICATION_NAME="{{ SELF.application_name }}"
                                              APPLICATION_PORT="{{ SELF.application_port }}"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "start" missing
                                      when: SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "stop" missing
                                      when: SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: ORCHESTRATOR
                        inputs:
                            playbook:
                                q:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
    redis.server~software.application#zip.archive::terraform@*->local.machine:
        derived_from: redis.server
        metadata:
            vintner_generated: 'true'
        properties:
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            local_file:
                                tmp_artifact:
                                    source: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                    filename: /tmp/artifact-redis.server
                                    count: '{{ (not (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")) | ternary(1, 0) }}'
                                tmp_create:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Create application directory
                                        mkdir -p {{ SELF.application_directory }}

                                        # Create application environment
                                        cat <<EOF > {{ SELF.application_directory }}/.env
                                        APPLICATION_PROTOCOL="{{ SELF.application_protocol }}"
                                        APPLICATION_NAME="{{ SELF.application_name }}"
                                        APPLICATION_PORT="{{ SELF.application_port }}"
                                        EOF>>

                                        # Download deployment artifact if required
                                        if [[ "{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}" == http* ]]; then 
                                            wget -O /tmp/artifact-redis.server {{ ".artifacts::*::[.type=zip.archive]::file" | eval }} 
                                        fi

                                        # Extract deployment artifact
                                        unzip /tmp/artifact-redis.server -d {{ SELF.application_directory }} {{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}

                                        # Create vintner directory
                                        mkdir -p {{ SELF.application_directory }}/.vintner

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/create.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/create.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/create.sh
                                    filename: /tmp/create-redis.server.sh
                                tmp_configure:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/configure.sh
                                    filename: /tmp/configure-redis.server.sh
                                tmp_start:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Assert operation
                                        if [[ "{{ SELF._management_start | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                            echo 'Management operation "start" missing'
                                            exit 1 
                                        fi

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/start.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/start.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/start.sh
                                    filename: /tmp/start-redis.server.sh
                                tmp_stop:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Assert operation
                                        if [[ "{{ SELF._management_stop | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                            echo 'Management operation "stop" missing'
                                            exit 1 
                                        fi

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/stop.sh
                                    filename: /tmp/stop-redis.server.sh
                                tmp_delete:
                                    content: |
                                        #!/usr/bin/bash
                                        set -e

                                        # Copy operation
                                        cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                        #!/usr/bin/bash
                                        set -e

                                        {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                        EOF>>
                                        chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                        # Execute operation
                                        cd {{ SELF.application_directory }}
                                        . .env
                                        . .vintner/delete.sh

                                        # Delete application directory
                                        rm -rf "{{ SELF.application_directory }}"
                                    filename: /tmp/delete-redis.server.sh
                            terraform_data:
                                local:
                                    - depends_on:
                                          - local_file.tmp_artifact
                                          - local_file.tmp_create
                                          - local_file.tmp_configure
                                          - local_file.tmp_start
                                          - local_file.tmp_stop
                                          - local_file.tmp_delete
                                      provisioner:
                                          local-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-redis.server.sh
                                                    - sudo bash /tmp/configure-redis.server.sh
                                                    - sudo bash /tmp/start-redis.server.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-redis.server.sh
                                                    - sudo bash /tmp/delete-redis.server.sh
                                                when: destroy
    redis.server~software.application#zip.archive::ansible@*->remote.machine:
        derived_from: redis.server
        metadata:
            vintner_generated: 'true'
            vintner_orchestrator: unfurl
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    create:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: install operational dependencies
                                      ansible.builtin.apt:
                                          name: unzip
                                          update_cache: 'yes'
                                    - name: create application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: directory
                                    - name: extract deployment artifact in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          extra_opts: '{{ ".artifacts::*::[.type=zip.archive]::extra_opts" | eval | map_value }}'
                                      when: not (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")
                                    - name: extract deployment artifact from URL in application directory
                                      ansible.builtin.unarchive:
                                          src: '{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                          dest: '{{ SELF.application_directory }}'
                                          remote_src: 'yes'
                                          extra_opts: '{{ ".artifacts::*::[.type=zip.archive]::extra_opts" | eval | map_value }}'
                                      when: (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")
                                    - name: create vintner directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}/.vintner'
                                          state: directory
                                    - name: create .env file
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.env'
                                          content: |-
                                              APPLICATION_PROTOCOL="{{ SELF.application_protocol }}"
                                              APPLICATION_NAME="{{ SELF.application_name }}"
                                              APPLICATION_PORT="{{ SELF.application_port }}"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/create.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                          mode: '0755'
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/create.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_create != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    configure:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/configure.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                          mode: '0755'
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/configure.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_configure != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    start:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "start" missing
                                      when: SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/start.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                          mode: '0755'
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/start.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_start != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    stop:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: assert management operation
                                      ansible.builtin.fail:
                                          msg: Management operation "stop" missing
                                      when: SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/stop.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                          mode: '0755'
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/stop.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_stop != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
                    delete:
                        implementation:
                            primary: Ansible
                            operation_host: HOST
                            environment:
                                ANSIBLE_HOST_KEY_CHECKING: 'False'
                        inputs:
                            playbook:
                                q:
                                    - name: wait for ssh
                                      wait_for_connection:
                                    - name: copy management operation
                                      ansible.builtin.copy:
                                          dest: '{{ SELF.application_directory }}/.vintner/delete.sh'
                                          content: |-
                                              #!/usr/bin/bash
                                              set -e

                                              {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                          mode: '0755'
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: call management operation
                                      ansible.builtin.shell: . .env && . .vintner/delete.sh
                                      args:
                                          chdir: '{{ SELF.application_directory }}'
                                          executable: /bin/bash
                                      when: SELF._management_delete != "VINTNER_MANAGEMENT_OPERATION_UNDEFINED"
                                    - name: delete application directory
                                      ansible.builtin.file:
                                          path: '{{ SELF.application_directory }}'
                                          state: absent
                            playbookArgs:
                                - '--become'
                                - '--key-file={{ SELF.os_ssh_key_file }}'
                                - '--user={{ SELF.os_ssh_user }}'
    redis.server~software.application#zip.archive::terraform@*->remote.machine:
        derived_from: redis.server
        metadata:
            vintner_generated: 'true'
        properties:
            os_ssh_user:
                type: string
                default:
                    get_input: os_ssh_user
            os_ssh_key_file:
                type: string
                default:
                    get_input: os_ssh_key_file
            os_ssh_host:
                type: string
                default:
                    eval: .::.requirements::[.name=host]::.target::management_address
            application_directory:
                type: string
                default:
                    concat:
                        - /var/lib/
                        - get_property:
                              - SELF
                              - application_name
        interfaces:
            Standard:
                operations:
                    configure:
                        implementation:
                            primary: Terraform
                    delete:
                        implementation:
                            primary: Terraform
            defaults:
                inputs:
                    main:
                        resource:
                            terraform_data:
                                vm:
                                    - connection:
                                          - host: '{{ SELF.os_ssh_host }}'
                                            private_key: ${file("{{ SELF.os_ssh_key_file }}")}
                                            type: ssh
                                            user: '{{ SELF.os_ssh_user }}'
                                      provisioner:
                                          file:
                                              - source: '{{ "project" | get_dir }}/ensemble/{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}'
                                                destination: /tmp/artifact-redis.server
                                                count: '{{ (not (".artifacts::*::[.type=zip.archive]::file" | eval).startswith("http")) | ternary(1, 0) }}'
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Create application directory
                                                    mkdir -p {{ SELF.application_directory }}

                                                    # Create application environment
                                                    cat <<EOF > {{ SELF.application_directory }}/.env
                                                    APPLICATION_PROTOCOL="{{ SELF.application_protocol }}"
                                                    APPLICATION_NAME="{{ SELF.application_name }}"
                                                    APPLICATION_PORT="{{ SELF.application_port }}"
                                                    EOF>>

                                                    # Download deployment artifact if required
                                                    if [[ "{{ ".artifacts::*::[.type=zip.archive]::file" | eval }}" == http* ]]; then 
                                                        wget -O /tmp/artifact-redis.server {{ ".artifacts::*::[.type=zip.archive]::file" | eval }} 
                                                    fi

                                                    # Extract deployment artifact
                                                    unzip /tmp/artifact-redis.server -d {{ SELF.application_directory }} {{ ".artifacts::*::[.type=tar.archive]::extra_opts" | eval | map_value }}

                                                    # Create vintner directory
                                                    mkdir -p {{ SELF.application_directory }}/.vintner

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/create.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_create == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_create) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/create.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/create.sh
                                                destination: /tmp/create-redis.server.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/configure.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_configure == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_configure) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/configure.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/configure.sh
                                                destination: /tmp/configure-redis.server.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Assert operation
                                                    if [[ "{{ SELF._management_start | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                                        echo 'Management operation "start" missing'
                                                        exit 1 
                                                    fi

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/start.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_start == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_start) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/start.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/start.sh
                                                destination: /tmp/start-redis.server.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Assert operation
                                                    if [[ "{{ SELF._management_stop | split('\n') | first }}" == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ]]; then
                                                        echo 'Management operation "stop" missing'
                                                        exit 1 
                                                    fi

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/stop.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_stop == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_stop) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/stop.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/stop.sh
                                                destination: /tmp/stop-redis.server.sh
                                              - content: |
                                                    #!/usr/bin/bash
                                                    set -e

                                                    # Copy operation
                                                    cat <<EOF > {{ SELF.application_directory }}/.vintner/delete.sh
                                                    #!/usr/bin/bash
                                                    set -e

                                                    {{ (SELF._management_delete == "VINTNER_MANAGEMENT_OPERATION_UNDEFINED" ) | ternary("echo 0", SELF._management_delete) }}
                                                    EOF>>
                                                    chmod +x {{ SELF.application_directory }}/.vintner/delete.sh

                                                    # Execute operation
                                                    cd {{ SELF.application_directory }}
                                                    . .env
                                                    . .vintner/delete.sh

                                                    # Delete application directory
                                                    rm -rf "{{ SELF.application_directory }}"
                                                destination: /tmp/delete-redis.server.sh
                                          remote-exec:
                                              - inline:
                                                    - sudo bash /tmp/create-redis.server.sh
                                                    - sudo bash /tmp/configure-redis.server.sh
                                                    - sudo bash /tmp/start-redis.server.sh
                                              - inline:
                                                    - sudo bash /tmp/stop-redis.server.sh
                                                    - sudo bash /tmp/delete-redis.server.sh
                                                when: destroy
